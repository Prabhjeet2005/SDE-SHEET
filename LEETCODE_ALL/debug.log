2026-01-10 09:17:40,105 [INFO] __main__.py:145 - leetcode-export run with arguments: Namespace(cookies='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfYXV0aF91c2VyX2lkIjoiMTMyMzYxNzQiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJhbGxhdXRoLmFjY291bnQuYXV0aF9iYWNrZW5kcy5BdXRoZW50aWNhdGlvbkJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIyMDY4MGNlNWUzZDVkY2E2NGUxYWE0YjkzNWIxOTJkMjhhMDYxODU0NmMzMTRmYTc1YTY2MDYxZmJjODVmOTIyIiwic2Vzc2lvbl91dWlkIjoiYjIzNGRkMmUiLCJpZCI6MTMyMzYxNzQsImVtYWlsIjoicHJhYmhqZWV0c2FuZGh1MDEwQGdtYWlsLmNvbSIsInVzZXJuYW1lIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwidXNlcl9zbHVnIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwiYXZhdGFyIjoiaHR0cHM6Ly9hc3NldHMubGVldGNvZGUuY29tL3VzZXJzL1ByYWJoamVldHNhbmRodTAxMC9hdmF0YXJfMTc1ODYwNzg5NS5wbmciLCJyZWZyZXNoZWRfYXQiOjE3NjgwMTQ5NjEsImlwIjoiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0IiwiaWRlbnRpdHkiOiI2ODRmYWMzZDhlNTk1ODQ1NjQwZTUwN2E5MTIyYmQ1NSIsImRldmljZV93aXRoX2lwIjpbImIzNDAxZTcwNGY2YzFkMWNiMDQyMzU4NTZiN2I4ODViIiwiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0Il19.Dtk4MvwrHcvqddMauocdcANJ7v_cdAwn4tXZp4uXjT0', folder='my_solutions', problem_folder_name='${question_id}-${title_slug}', no_problem_statement=False, problem_statement_filename='${question_id}-${title_slug}.md', problem_statement_content='<h1>${question_id} - ${title}</h1><h2>Difficulty: ${difficulty} - <a href="https://leetcode.com/problems/${title_slug}/">${title_slug}</a></h2>${content}', submission_filename='${date_formatted} - ${status_display} - runtime ${runtime} - memory ${memory}.${extension}', only_accepted=False, only_last_submission=False, language_unprocessed=None, verbose=False, extra_verbose=False, language=None)
2026-01-10 09:17:40,105 [DEBUG] leetcode.py:29 - LeetCode class instantiated
2026-01-10 09:17:40,105 [ERROR] leetcode.py:87 - Cookie format not valid. Expected: 'csrftoken=value1;LEETCODE_SESSION=value2;...'
2026-01-10 09:17:40,105 [ERROR] __main__.py:159 - Cookies not valid. Copy them from the Network tab of your browser by clicking on any leetcode.com request and going in Request Headers > cookie. Check README.md file for more information
2026-01-10 09:19:32,627 [INFO] __main__.py:145 - leetcode-export run with arguments: Namespace(cookies='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfYXV0aF91c2VyX2lkIjoiMTMyMzYxNzQiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJhbGxhdXRoLmFjY291bnQuYXV0aF9iYWNrZW5kcy5BdXRoZW50aWNhdGlvbkJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIyMDY4MGNlNWUzZDVkY2E2NGUxYWE0YjkzNWIxOTJkMjhhMDYxODU0NmMzMTRmYTc1YTY2MDYxZmJjODVmOTIyIiwic2Vzc2lvbl91dWlkIjoiYjIzNGRkMmUiLCJpZCI6MTMyMzYxNzQsImVtYWlsIjoicHJhYmhqZWV0c2FuZGh1MDEwQGdtYWlsLmNvbSIsInVzZXJuYW1lIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwidXNlcl9zbHVnIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwiYXZhdGFyIjoiaHR0cHM6Ly9hc3NldHMubGVldGNvZGUuY29tL3VzZXJzL1ByYWJoamVldHNhbmRodTAxMC9hdmF0YXJfMTc1ODYwNzg5NS5wbmciLCJyZWZyZXNoZWRfYXQiOjE3NjgwMTQ5NjEsImlwIjoiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0IiwiaWRlbnRpdHkiOiI2ODRmYWMzZDhlNTk1ODQ1NjQwZTUwN2E5MTIyYmQ1NSIsImRldmljZV93aXRoX2lwIjpbImIzNDAxZTcwNGY2YzFkMWNiMDQyMzU4NTZiN2I4ODViIiwiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0Il19.Dtk4MvwrHcvqddMauocdcANJ7v_cdAwn4tXZp4uXjT0', folder='./my_leetcode_solutions', problem_folder_name='${question_id}-${title_slug}', no_problem_statement=False, problem_statement_filename='${question_id}-${title_slug}.md', problem_statement_content='<h1>${question_id} - ${title}</h1><h2>Difficulty: ${difficulty} - <a href="https://leetcode.com/problems/${title_slug}/">${title_slug}</a></h2>${content}', submission_filename='${date_formatted} - ${status_display} - runtime ${runtime} - memory ${memory}.${extension}', only_accepted=True, only_last_submission=False, language_unprocessed=None, verbose=False, extra_verbose=False, language=None)
2026-01-10 09:19:32,627 [DEBUG] leetcode.py:29 - LeetCode class instantiated
2026-01-10 09:19:32,627 [ERROR] leetcode.py:87 - Cookie format not valid. Expected: 'csrftoken=value1;LEETCODE_SESSION=value2;...'
2026-01-10 09:19:32,627 [ERROR] __main__.py:159 - Cookies not valid. Copy them from the Network tab of your browser by clicking on any leetcode.com request and going in Request Headers > cookie. Check README.md file for more information
2026-01-10 09:21:50,502 [INFO] __main__.py:145 - leetcode-export run with arguments: Namespace(cookies='csrftoken=bBAoEvj51v5KwoGeRE4EWlOuPIJD7are; LEETCODE_SESSION=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfYXV0aF91c2VyX2lkIjoiMTMyMzYxNzQiLCJfYXV0aF91c2VyX2JhY2tlbmQiOiJhbGxhdXRoLmFjY291bnQuYXV0aF9iYWNrZW5kcy5BdXRoZW50aWNhdGlvbkJhY2tlbmQiLCJfYXV0aF91c2VyX2hhc2giOiIyMDY4MGNlNWUzZDVkY2E2NGUxYWE0YjkzNWIxOTJkMjhhMDYxODU0NmMzMTRmYTc1YTY2MDYxZmJjODVmOTIyIiwic2Vzc2lvbl91dWlkIjoiYjIzNGRkMmUiLCJpZCI6MTMyMzYxNzQsImVtYWlsIjoicHJhYmhqZWV0c2FuZGh1MDEwQGdtYWlsLmNvbSIsInVzZXJuYW1lIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwidXNlcl9zbHVnIjoiUHJhYmhqZWV0c2FuZGh1MDEwIiwiYXZhdGFyIjoiaHR0cHM6Ly9hc3NldHMubGVldGNvZGUuY29tL3VzZXJzL1ByYWJoamVldHNhbmRodTAxMC9hdmF0YXJfMTc1ODYwNzg5NS5wbmciLCJyZWZyZXNoZWRfYXQiOjE3NjgwMTQ5NjEsImlwIjoiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0IiwiaWRlbnRpdHkiOiI2ODRmYWMzZDhlNTk1ODQ1NjQwZTUwN2E5MTIyYmQ1NSIsImRldmljZV93aXRoX2lwIjpbImIzNDAxZTcwNGY2YzFkMWNiMDQyMzU4NTZiN2I4ODViIiwiMjQwMTo0OTAwOjFjNTI6YWQ2NTo4OWM2OmM2NmE6MjZiMDpiZDk0Il19.Dtk4MvwrHcvqddMauocdcANJ7v_cdAwn4tXZp4uXjT0', folder='./my_leetcode_solutions', problem_folder_name='${question_id}-${title_slug}', no_problem_statement=False, problem_statement_filename='${question_id}-${title_slug}.md', problem_statement_content='<h1>${question_id} - ${title}</h1><h2>Difficulty: ${difficulty} - <a href="https://leetcode.com/problems/${title_slug}/">${title_slug}</a></h2>${content}', submission_filename='${date_formatted} - ${status_display} - runtime ${runtime} - memory ${memory}.${extension}', only_accepted=True, only_last_submission=False, language_unprocessed=None, verbose=False, extra_verbose=False, language=None)
2026-01-10 09:21:50,502 [DEBUG] leetcode.py:29 - LeetCode class instantiated
2026-01-10 09:21:50,527 [DEBUG] connectionpool.py:1049 - Starting new HTTPS connection (1): leetcode.com:443
2026-01-10 09:21:51,926 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=0&limit=1 HTTP/1.1" 200 None
2026-01-10 09:21:51,930 [DEBUG] leetcode.py:109 - {"submissions_dump":[{"id":1880304247,"question_id":437,"lang":"cpp","lang_name":"C++","time":"16Â minutes","timestamp":1768016143,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1880304247/","is_pending":"Not Pending","title":"Path Sum III","memory":"20.7 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int targetSum) {\n        unordered_map<long long,int>path_sum_count_map;\n        long long path_sum=0;\n        int count_path = 0;\n        path_sum_count_map[0]++;\n        get_count_path(root,targetSum,path_sum,count_path,path_sum_count_map);\n        return count_path;\n\n    }\n\n    private:\n    int get_count_path(TreeNode*& root,int targetSum,long long path_sum, int &count_path,unordered_map<long long,int>&path_sum_count_map){\n        if(!root){\n            return 0;\n        }\n        path_sum += root->val;\n        \n        if(path_sum_count_map.count( path_sum - targetSum)){\n            count_path += path_sum_count_map[ path_sum - targetSum ];\n        }\n\n        path_sum_count_map[path_sum]++; // It will be after checking in map\n        get_count_path(root->left,targetSum,path_sum,count_path,path_sum_count_map);\n        get_count_path(root->right,targetSum,path_sum,count_path,path_sum_count_map);\n        path_sum_count_map[path_sum]--;\n        return count_path;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":550}],"has_next":true,"last_key":""}
2026-01-10 09:21:52,935 [DEBUG] leetcode.py:112 - User is logged in
2026-01-10 09:21:52,936 [INFO] leetcode.py:95 - Cookie set successful
2026-01-10 09:21:52,936 [INFO] __main__.py:166 - Output folder not found, creating it
2026-01-10 09:21:52,937 [DEBUG] leetcode.py:150 - Exporting submissions from 0 to 20
2026-01-10 09:22:00,190 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=0&limit=20 HTTP/1.1" 200 None
2026-01-10 09:22:00,192 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1880304247,"question_id":437,"lang":"cpp","lang_name":"C++","time":"16\xc2\xa0minutes","timestamp":1768016143,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1880304247/","is_pending":"Not Pending","title":"Path Sum III","memory":"20.7 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        unordered_map<long long,int>path_sum_count_map;\\n        long long path_sum=0;\\n        int count_path = 0;\\n        path_sum_count_map[0]++;\\n        get_count_path(root,targetSum,path_sum,count_path,path_sum_count_map);\\n        return count_path;\\n\\n    }\\n\\n    private:\\n    int get_count_path(TreeNode*& root,int targetSum,long long path_sum, int &count_path,unordered_map<long long,int>&path_sum_count_map){\\n        if(!root){\\n            return 0;\\n        }\\n        path_sum += root->val;\\n        \\n        if(path_sum_count_map.count( path_sum - targetSum)){\\n            count_path += path_sum_count_map[ path_sum - targetSum ];\\n        }\\n\\n        path_sum_count_map[path_sum]++; // It will be after checking in map\\n        get_count_path(root->left,targetSum,path_sum,count_path,path_sum_count_map);\\n        get_count_path(root->right,targetSum,path_sum,count_path,path_sum_count_map);\\n        path_sum_count_map[path_sum]--;\\n        return count_path;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":550},{"id":1880303680,"question_id":437,"lang":"cpp","lang_name":"C++","time":"17\xc2\xa0minutes","timestamp":1768016066,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1880303680/","is_pending":"Not Pending","title":"Path Sum III","memory":"21.9 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        unordered_map<long long,int>path_sum_count_map;\\n        long long path_sum=0;\\n        int count_path = 0;\\n        path_sum_count_map[0]++;\\n        get_count_path(root,targetSum,path_sum,count_path,path_sum_count_map);\\n        return count_path;\\n\\n    }\\n\\n    private:\\n    int get_count_path(TreeNode*& root,int targetSum,long long path_sum, int &count_path,unordered_map<long long,int>&path_sum_count_map){\\n        if(!root){\\n            return 0;\\n        }\\n        path_sum += root->val;\\n        \\n        if(path_sum_count_map[ path_sum - targetSum]){\\n            count_path += path_sum_count_map[ path_sum - targetSum ];\\n        }\\n\\n        path_sum_count_map[path_sum]++;\\n        get_count_path(root->left,targetSum,path_sum,count_path,path_sum_count_map);\\n        get_count_path(root->right,targetSum,path_sum,count_path,path_sum_count_map);\\n        path_sum_count_map[path_sum]--;\\n        return count_path;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":549},{"id":1880303379,"question_id":437,"lang":"cpp","lang_name":"C++","time":"18\xc2\xa0minutes","timestamp":1768016026,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1880303379/","is_pending":"Not Pending","title":"Path Sum III","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        unordered_map<long long,int>path_sum_count_map;\\n        long long path_sum=0;\\n        int count_path = 0;\\n        path_sum_count_map[0]++;\\n        get_count_path(root,targetSum,path_sum,count_path,path_sum_count_map);\\n        return count_path;\\n\\n    }\\n\\n    private:\\n    int get_count_path(TreeNode*& root,int targetSum,long long path_sum, int &count_path,unordered_map<long long,int>&path_sum_count_map){\\n        if(!root){\\n            return 0;\\n        }\\n        path_sum += root->val;\\n        path_sum_count_map[path_sum]++;\\n        \\n        if(path_sum_count_map[ path_sum - targetSum]){\\n            count_path += path_sum_count_map[ path_sum - targetSum ];\\n        }\\n\\n        get_count_path(root->left,targetSum,path_sum,count_path,path_sum_count_map);\\n        get_count_path(root->right,targetSum,path_sum,count_path,path_sum_count_map);\\n        path_sum_count_map[path_sum]--;\\n        return count_path;\\n    }\\n};","compare_result":"1111100111111111111110111111110111111111111111111111111111111111111101111111111111111111111111111111111111111111111100010111111101","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":548},{"id":1879841982,"question_id":113,"lang":"cpp","lang_name":"C++","time":"13\xc2\xa0hours, 17\xc2\xa0minutes","timestamp":1767969248,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1879841982/","is_pending":"Not Pending","title":"Path Sum II","memory":"21 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\\n        vector<vector<int>> ans;\\n        vector<int> curr_path;\\n        long long curr_sum = 0;\\n        get_target_path(root, targetSum, curr_sum, curr_path, ans);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void get_target_path(TreeNode*& root, int targetSum, long long curr_sum,\\n                         vector<int>& curr_path, vector<vector<int>>& ans) {\\n\\n        if (!root){\\n            return;\\n        }\\n\\n        curr_sum += root->val;\\n        curr_path.push_back(root->val);\\n\\n        if (!root->left && !root->right) {\\n            // LEAF\\n            if (curr_sum == targetSum) {\\n                ans.push_back(curr_path);\\n            }\\n        }\\n\\n        get_target_path(root->left, targetSum, curr_sum, curr_path, ans);\\n        get_target_path(root->right, targetSum, curr_sum, curr_path, ans);\\n        curr_sum -= root->val;\\n        curr_path.pop_back();\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum-ii","has_notes":false,"flag_type":1,"frontend_id":547},{"id":1878258549,"question_id":112,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0days","timestamp":1767844152,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1878258549/","is_pending":"Not Pending","title":"Path Sum","memory":"21.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasPathSum(TreeNode* root, int targetSum) {\\n        if(!root)return false;\\n        if(!root->left && !root->right){\\n            if(targetSum == root->val)return true;\\n            else return false;\\n        }\\n\\n        bool left = hasPathSum(root->left,targetSum - root->val);\\n        bool right = hasPathSum(root->right,targetSum - root->val);\\n\\n        return left || right;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"path-sum","has_notes":false,"flag_type":1,"frontend_id":546},{"id":1877105666,"question_id":450,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0days","timestamp":1767756935,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1877105666/","is_pending":"Not Pending","title":"Delete Node in a BST","memory":"34.4 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* deleteNode(TreeNode* root, int key) {\\n        if(!root)return nullptr;\\n        if(root->val == key){\\n            return delete_from_BST(root,key);\\n        }\\n        if(root->val < key){\\n            root->right = deleteNode(root->right,key);\\n        }else if(root->val > key){\\n            root->left = deleteNode(root->left,key);\\n        }\\n\\n        return root;\\n    }\\n\\n    private:\\n    TreeNode* delete_from_BST(TreeNode*& root,int key){\\n        if(!root->left && !root->right){\\n            delete root;\\n            return nullptr;\\n        }\\n        if(!root->left || !root->right){\\n            // 1 Child\\n            if(!root->left){\\n                TreeNode* remaining_tree = root->right;\\n                delete root;\\n                return remaining_tree;\\n            }\\n            else{\\n                TreeNode* remaining_tree = root->left;\\n                delete root;\\n                return remaining_tree;\\n            }\\n        }\\n        else{\\n            // 2 Children\\n            TreeNode* inorder_successor = get_inorder_successor(root->right);\\n            root->val = inorder_successor->val;\\n            root->right = deleteNode(root->right,inorder_successor->val);\\n            return root;\\n        }\\n    }\\n\\n    TreeNode* get_inorder_successor(TreeNode* &root){\\n        if(!root)return nullptr;\\n        if(!root->left)return root;\\n        return get_inorder_successor(root->left);\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"delete-node-in-a-bst","has_notes":false,"flag_type":1,"frontend_id":545},{"id":1877084775,"question_id":108,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0days","timestamp":1767754836,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1877084775/","is_pending":"Not Pending","title":"Convert Sorted Array to Binary Search Tree","memory":"23 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1;\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = get_BST(nums,start,end);\\n        return root;\\n    }\\n\\n    private:\\n    TreeNode* get_BST(vector<int>&nums,int start,int end){\\n        if(start > end)return nullptr;\\n\\n        int mid = start + (end - start)/2;\\n        TreeNode* root = new TreeNode(nums[mid]);\\n        root->left = get_BST(nums,start,mid-1);\\n        root->right = get_BST(nums,mid+1,end);\\n\\n        return root;\\n    }\\n};","compare_result":"1111111111111111111111111111111","title_slug":"convert-sorted-array-to-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":544},{"id":1873200489,"question_id":1544,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0days, 12\xc2\xa0hours","timestamp":1767452119,"status":10,"status_display":"Accepted","runtime":"109 ms","url":"/submissions/detail/1873200489/","is_pending":"Not Pending","title":"Count Good Nodes in Binary Tree","memory":"88.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count_good_nodes = 0,max_till_now = INT_MIN;\\n        get_count_good_nodes(root,count_good_nodes,max_till_now);\\n        return count_good_nodes;\\n    }\\n\\n    private:\\n    int get_count_good_nodes(TreeNode*& root,int &count_good_nodes,int max_till_now){\\n        if(!root)return 0;\\n        if(root->val >= max_till_now)count_good_nodes++;\\n        max_till_now = max(max_till_now,root->val);\\n        int left_count = get_count_good_nodes(root->left,count_good_nodes,max_till_now);\\n        int right_count = get_count_good_nodes(root->right,count_good_nodes,max_till_now);\\n  \\n        return left_count + right_count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-good-nodes-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":543},{"id":1873198116,"question_id":1544,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0days, 12\xc2\xa0hours","timestamp":1767452058,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1873198116/","is_pending":"Not Pending","title":"Count Good Nodes in Binary Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count_good_nodes = 0,max_till_now = INT_MIN;\\n        get_count_good_nodes(root,count_good_nodes,max_till_now);\\n        return count_good_nodes;\\n    }\\n\\n    private:\\n    int get_count_good_nodes(TreeNode*& root,int &count_good_nodes,int &max_till_now){\\n        if(!root)return 0;\\n        if(root->val >= max_till_now)count_good_nodes++;\\n        max_till_now = max(max_till_now,root->val);\\n        int left_count = get_count_good_nodes(root->left,count_good_nodes,max_till_now);\\n        int right_count = get_count_good_nodes(root->right,count_good_nodes,max_till_now);\\n  \\n        return left_count + right_count;\\n    }\\n};","compare_result":"111011011111101100000001001000101000000000000000000000000000000","title_slug":"count-good-nodes-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":542},{"id":1873162753,"question_id":1544,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0days, 13\xc2\xa0hours","timestamp":1767451057,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1873162753/","is_pending":"Not Pending","title":"Count Good Nodes in Binary Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count_good_nodes = 0,max_till_now = INT_MIN;\\n        get_count_good_nodes(root,count_good_nodes,max_till_now);\\n        return count_good_nodes;\\n    }\\n\\n    private:\\n    int get_count_good_nodes(TreeNode*& root,int &count_good_nodes,int &max_till_now){\\n        if(!root)return 0;\\n        if(root->val >= max_till_now)count_good_nodes++;\\n        max_till_now = max(max_till_now,root->val);\\n        int left_count = get_count_good_nodes(root->left,count_good_nodes,max_till_now);\\n        int right_count = get_count_good_nodes(root->right,count_good_nodes,max_till_now);\\n  \\n        return left_count + right_count;\\n    }\\n};","compare_result":"111011011111101100000001001000101000000000000000000000000000000","title_slug":"count-good-nodes-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":541},{"id":1873162484,"question_id":1544,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0days, 13\xc2\xa0hours","timestamp":1767451050,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1873162484/","is_pending":"Not Pending","title":"Count Good Nodes in Binary Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int goodNodes(TreeNode* root) {\\n        int count_good_nodes = 0,max_till_now = INT_MIN;\\n        get_count_good_nodes(root,count_good_nodes,max_till_now);\\n        return count_good_nodes;\\n    }\\n\\n    private:\\n    int get_count_good_nodes(TreeNode*& root,int &count_good_nodes,int &max_till_now){\\n        if(!root)return 0;\\n        if(root->val >= max_till_now)count_good_nodes++;\\n        max_till_now = max(max_till_now,root->val);\\n        int left_count = get_count_good_nodes(root->left,count_good_nodes,max_till_now);\\n        int right_count = get_count_good_nodes(root->right,count_good_nodes,max_till_now);\\n  \\n        return left_count + right_count;\\n    }\\n};","compare_result":"111011011111101100000001001000101000000000000000000000000000000","title_slug":"count-good-nodes-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":540},{"id":1872663262,"question_id":543,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0days, 23\xc2\xa0hours","timestamp":1767413646,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1872663262/","is_pending":"Not Pending","title":"Diameter of Binary Tree","memory":"23.7 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        if(!root)return 0;\\n        int max_diameter = 0;\\n        get_max_diameter(root,max_diameter);\\n        return max_diameter;\\n    }\\n    private:\\n    int get_max_diameter(TreeNode* root,int &max_diameter){\\n        if(!root)return 0;\\n        int left_height = get_max_diameter(root->left,max_diameter);\\n        int right_height = get_max_diameter(root->right,max_diameter);\\n        max_diameter = max(max_diameter,left_height + right_height);\\n        return 1+max(left_height,right_height);\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"diameter-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":539},{"id":1872647721,"question_id":199,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767411946,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872647721/","is_pending":"Not Pending","title":"Binary Tree Right Side View","memory":"15.2 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        ans = get_right_view(root);\\n        return ans;\\n    }\\n    private:\\n    vector<int>get_right_view(TreeNode* &root){\\n        if(!root)return {};\\n        vector<int>ans;\\n        queue<TreeNode*>level_queue;\\n        level_queue.push(root);\\n\\n        while(!level_queue.empty()){\\n            int level_queue_size = level_queue.size();\\n            int right_most_element = INT_MIN;\\n            for(int i=0; i<level_queue_size; i++){\\n                TreeNode* front = level_queue.front();\\n                level_queue.pop();\\n                if(front->left)level_queue.push(front->left);\\n                if(front->right)level_queue.push(front->right);\\n                right_most_element = front->val;\\n            }\\n            ans.push_back(right_most_element);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-right-side-view","has_notes":false,"flag_type":1,"frontend_id":538},{"id":1872642640,"question_id":199,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767411307,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872642640/","is_pending":"Not Pending","title":"Binary Tree Right Side View","memory":"15.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int>ans;\\n        ans = get_right_view(root);\\n        return ans;\\n    }\\n    private:\\n    vector<int>get_right_view(TreeNode* &root){\\n        if(!root)return {};\\n        vector<int>ans;\\n        queue<TreeNode*>level_queue;\\n        level_queue.push(root);\\n\\n        while(!level_queue.empty()){\\n            int level_queue_size = level_queue.size();\\n            int right_most_element = INT_MIN;\\n            for(int i=0; i<level_queue_size; i++){\\n                TreeNode* front = level_queue.front();\\n                level_queue.pop();\\n                if(front->left)level_queue.push(front->left);\\n                if(front->right)level_queue.push(front->right);\\n                right_most_element = front->val;\\n            }\\n            ans.push_back(right_most_element);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-right-side-view","has_notes":false,"flag_type":1,"frontend_id":537},{"id":1872605701,"question_id":110,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767405782,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872605701/","is_pending":"Not Pending","title":"Balanced Binary Tree","memory":"23.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        return check_balanced(root).is_height_balanced;\\n    }\\n    struct Balance{\\n        int height;\\n        bool is_height_balanced;\\n    };\\n    private:\\n    Balance check_balanced(TreeNode* root){\\n        if(!root)return {0,true};\\n        Balance left = check_balanced(root->left);\\n        Balance right = check_balanced(root->right);\\n\\n        bool is_balanced = left.is_height_balanced && right.is_height_balanced && abs(left.height - right.height)<=1;\\n\\n        return {max(left.height,right.height)+1,is_balanced};\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"balanced-binary-tree","has_notes":false,"flag_type":1,"frontend_id":536},{"id":1872603285,"question_id":110,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767405386,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872603285/","is_pending":"Not Pending","title":"Balanced Binary Tree","memory":"23 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        return check_balanced(root).second;\\n    }\\n    private:\\n    pair<int,bool> check_balanced(TreeNode* root){\\n        if(!root)return {0,true};\\n        pair<int,bool> left = check_balanced(root->left);\\n        pair<int,bool> right = check_balanced(root->right);\\n\\n        bool is_balanced = left.second && right.second && abs(left.first - right.first)<=1;\\n\\n        return {max(left.first,right.first)+1,is_balanced};\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"balanced-binary-tree","has_notes":false,"flag_type":1,"frontend_id":535},{"id":1872597758,"question_id":100,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767404439,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872597758/","is_pending":"Not Pending","title":"Same Tree","memory":"12.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        if(!p && !q)return true;\\n        if((!p && q) || (p && !q))return false;\\n        if(p->val != q->val)return false;\\n\\n        return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111","title_slug":"same-tree","has_notes":false,"flag_type":1,"frontend_id":534},{"id":1872587713,"question_id":572,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week","timestamp":1767402740,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1872587713/","is_pending":"Not Pending","title":"Subtree of Another Tree","memory":"28.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\\n        if(!root)return false;\\n\\n        bool same_check = is_same(root,subRoot);\\n        if(same_check)return true;\\n\\n        return isSubtree(root->left,subRoot) || isSubtree(root->right,subRoot);\\n    }\\n    private:\\n    bool is_same(TreeNode*root,TreeNode*sub_root){\\n        if(!root && !sub_root)return true;\\n\\n        if(( !root && sub_root ) || (root && !sub_root))return false;\\n\\n        if(root->val != sub_root->val)return false;\\n\\n        bool left = is_same(root->left,sub_root->left);\\n        bool right = is_same(root->right, sub_root->right);\\n\\n        return left && right; // This important [Both must give true for tree to be identical]\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subtree-of-another-tree","has_notes":false,"flag_type":1,"frontend_id":533},{"id":1871516984,"question_id":226,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767319953,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1871516984/","is_pending":"Not Pending","title":"Invert Binary Tree","memory":"12.4 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* invertTree(TreeNode* root) {\\n        if(!root)return nullptr;\\n        TreeNode* left = invertTree(root->left);\\n        TreeNode* right = invertTree(root->right);\\n        root->left = right;\\n        root->right = left;\\n        return root;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"invert-binary-tree","has_notes":false,"flag_type":1,"frontend_id":532},{"id":1871498097,"question_id":297,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767317251,"status":10,"status_display":"Accepted","runtime":"34 ms","url":"/submissions/detail/1871498097/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"35.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Codec {\\npublic:\\n\\n    // Encodes a tree to a single string.\\n    string serialize(TreeNode* root) {\\n        string encoded_str = \\"\\";\\n        // PREORDER BECAUSE NATURAL FLOW\\n        calculate_preorder(root,encoded_str);\\n        return encoded_str;\\n    }\\n\\n    // Decodes your encoded data to tree.\\n    TreeNode* deserialize(string data) {\\n        int curr = 0;\\n        TreeNode* root = build_tree(data,curr);\\n        return root;\\n    }\\n\\nprivate:\\n\\n    TreeNode* build_tree(string &data,int &curr_index){\\n        if(curr_index >= data.size())return nullptr;\\n\\n        int next_space = data.find(\' \',curr_index);\\n        string curr_node = data.substr(curr_index,next_space-curr_index);\\n        curr_index = next_space+1;\\n\\n        if(curr_node == \\"N\\"){\\n            return nullptr;\\n        }\\n        TreeNode* node = new TreeNode(stoi(curr_node));\\n        node->left = build_tree(data,curr_index);\\n        node->right = build_tree(data,curr_index);\\n        return node;\\n    }\\n\\n\\n    void calculate_preorder(TreeNode* root,string &encoded_str){\\n        if(!root){\\n            encoded_str += \\"N \\";\\n            return;\\n        } \\n        encoded_str += to_string(root->val) + \\" \\";\\n        calculate_preorder(root->left,encoded_str);\\n        calculate_preorder(root->right,encoded_str);\\n    }\\n};\\n\\n// Your Codec object will be instantiated and called as such:\\n// Codec ser, deser;\\n// TreeNode* ans = deser.deserialize(ser.serialize(root));","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"serialize-and-deserialize-binary-tree","has_notes":false,"flag_type":1,"frontend_id":531}],"has_next":true,"last_key":""}'
2026-01-10 09:22:00,533 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:00,536 [INFO] __main__.py:245 - Writing path-sum-iii/2026-01-10 09.05.43 - Accepted - runtime 0ms - memory 20.7MB.cpp
2026-01-10 09:22:00,537 [INFO] __main__.py:245 - Writing path-sum-iii/2026-01-10 09.04.26 - Accepted - runtime 4ms - memory 21.9MB.cpp
2026-01-10 09:22:00,537 [INFO] __main__.py:188 - Skipping path-sum-iii 2026-01-10 09.03.46 because its status is 'Wrong Answer'
2026-01-10 09:22:00,862 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:00,864 [INFO] __main__.py:245 - Writing path-sum-ii/2026-01-09 20.04.08 - Accepted - runtime 0ms - memory 21MB.cpp
2026-01-10 09:22:01,659 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:01,661 [INFO] __main__.py:245 - Writing path-sum/2026-01-08 09.19.12 - Accepted - runtime 0ms - memory 21.5MB.cpp
2026-01-10 09:22:02,226 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:02,229 [INFO] __main__.py:245 - Writing delete-node-in-a-bst/2026-01-07 09.05.35 - Accepted - runtime 0ms - memory 34.4MB.cpp
2026-01-10 09:22:04,348 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:04,350 [INFO] __main__.py:245 - Writing convert-sorted-array-to-binary-search-tree/2026-01-07 08.30.36 - Accepted - runtime 4ms - memory 23MB.cpp
2026-01-10 09:22:05,237 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:05,239 [INFO] __main__.py:245 - Writing count-good-nodes-in-binary-tree/2026-01-03 20.25.19 - Accepted - runtime 109ms - memory 88.3MB.cpp
2026-01-10 09:22:05,240 [INFO] __main__.py:188 - Skipping count-good-nodes-in-binary-tree 2026-01-03 20.24.18 because its status is 'Wrong Answer'
2026-01-10 09:22:05,240 [INFO] __main__.py:188 - Skipping count-good-nodes-in-binary-tree 2026-01-03 20.07.37 because its status is 'Wrong Answer'
2026-01-10 09:22:05,241 [INFO] __main__.py:188 - Skipping count-good-nodes-in-binary-tree 2026-01-03 20.07.30 because its status is 'Wrong Answer'
2026-01-10 09:22:07,094 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:07,095 [INFO] __main__.py:245 - Writing diameter-of-binary-tree/2026-01-03 09.44.06 - Accepted - runtime 3ms - memory 23.7MB.cpp
2026-01-10 09:22:08,621 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:08,624 [INFO] __main__.py:245 - Writing binary-tree-right-side-view/2026-01-03 09.15.46 - Accepted - runtime 0ms - memory 15.2MB.cpp
2026-01-10 09:22:08,626 [INFO] __main__.py:245 - Writing binary-tree-right-side-view/2026-01-03 09.05.07 - Accepted - runtime 0ms - memory 15.1MB.cpp
2026-01-10 09:22:08,939 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:08,940 [INFO] __main__.py:245 - Writing balanced-binary-tree/2026-01-03 07.33.02 - Accepted - runtime 0ms - memory 23.1MB.cpp
2026-01-10 09:22:08,940 [INFO] __main__.py:245 - Writing balanced-binary-tree/2026-01-03 07.26.26 - Accepted - runtime 0ms - memory 23MB.cpp
2026-01-10 09:22:10,388 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:10,389 [INFO] __main__.py:245 - Writing same-tree/2026-01-03 07.10.39 - Accepted - runtime 0ms - memory 12.8MB.cpp
2026-01-10 09:22:10,699 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:10,700 [INFO] __main__.py:245 - Writing subtree-of-another-tree/2026-01-03 06.42.20 - Accepted - runtime 0ms - memory 28.8MB.cpp
2026-01-10 09:22:11,000 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:11,000 [INFO] __main__.py:245 - Writing invert-binary-tree/2026-01-02 07.42.33 - Accepted - runtime 0ms - memory 12.4MB.cpp
2026-01-10 09:22:11,301 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:11,302 [INFO] __main__.py:245 - Writing serialize-and-deserialize-binary-tree/2026-01-02 06.57.31 - Accepted - runtime 34ms - memory 35.5MB.cpp
2026-01-10 09:22:16,307 [DEBUG] leetcode.py:150 - Exporting submissions from 20 to 40
2026-01-10 09:22:21,875 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=20&limit=20 HTTP/1.1" 200 None
2026-01-10 09:22:21,876 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1870760494,"question_id":124,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767248842,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1870760494/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"27.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = INT_MIN,curr_sum = 0;\\n        curr_sum = calculate_sum(root,max_sum);\\n        return max_sum;\\n    }\\n    private:\\n    int calculate_sum(TreeNode* root,int &max_sum){\\n        if(!root)return 0;\\n        int left_sum = calculate_sum(root->left,max_sum);\\n        int right_sum = calculate_sum(root->right,max_sum);\\n        if(left_sum < 0)left_sum = 0;\\n        if(right_sum < 0)right_sum = 0;\\n        max_sum = max(max_sum,left_sum + right_sum + root->val);\\n        return root->val + max(left_sum,right_sum); // THis IMPORTANT\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1,"frontend_id":530},{"id":1870759403,"question_id":124,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767248747,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1870759403/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = INT_MIN,curr_sum = 0;\\n        curr_sum = calculate_sum(root,max_sum);\\n        return max_sum;\\n    }\\n    private:\\n    int calculate_sum(TreeNode* root,int &max_sum){\\n        if(!root)return 0;\\n        int left_sum = calculate_sum(root->left,max_sum);\\n        int right_sum = calculate_sum(root->right,max_sum);\\n        if(left_sum < 0)left_sum = 0;\\n        if(right_sum < 0)right_sum = 0;\\n        max_sum = max(max_sum,left_sum + right_sum + root->val);\\n        return left_sum + right_sum + root->val;\\n    }\\n};","compare_result":"111111111111111111100011011111111111111111011111111111110111011111101111111011111000000000000010","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1,"frontend_id":529},{"id":1870759209,"question_id":124,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767248730,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1870759209/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        int max_sum = INT_MIN,curr_sum = 0;\\n        curr_sum = calculate_sum(root,max_sum);\\n        return max_sum;\\n    }\\n    private:\\n    int calculate_sum(TreeNode* root,int &max_sum){\\n        if(!root)return 0;\\n        int left_sum = calculate_sum(root->left,max_sum);\\n        int right_sum = calculate_sum(root->right,max_sum);\\n        // if(left_sum < 0)left_sum = 0;\\n        // if(right_sum < 0)right_sum = 0;\\n        max_sum = max(max_sum,left_sum + right_sum + root->val);\\n        return left_sum + right_sum + root->val;\\n    }\\n};","compare_result":"111111011001101101100101001110001100010000000010100000010001001010110000001001011000000000000010","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1,"frontend_id":528},{"id":1870702078,"question_id":230,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767242767,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1870702078/","is_pending":"Not Pending","title":"Kth Smallest Element in a BST","memory":"24.4 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        int current_count = 0;\\n        int ans = -1;\\n        inorder_calculate_k(root, k, current_count,ans);\\n        return ans;\\n    }\\n\\nprivate:\\n    void inorder_calculate_k(TreeNode*& root, int k, int& current_count,int &ans) {\\n        if (!root)\\n            return;\\n        inorder_calculate_k(root->left, k, current_count,ans);\\n        current_count++;\\n        if (current_count == k) {\\n            ans = root->val;\\n            return;\\n        }\\n        inorder_calculate_k(root->right, k, current_count,ans);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"kth-smallest-element-in-a-bst","has_notes":false,"flag_type":1,"frontend_id":527},{"id":1870693363,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 1\xc2\xa0day","timestamp":1767241653,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1870693363/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"27.7 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> inorder_index;\\n        for (int i = 0; i < inorder.size(); i++) {\\n            inorder_index[inorder[i]] = i;\\n        }\\n        TreeNode* root =\\n            create_tree(preorder, inorder, inorder_index, 0,\\n                        preorder.size() - 1, 0, inorder.size() - 1);\\n\\n        return root;\\n    }\\n\\nprivate:\\n    TreeNode* create_tree(vector<int>& preorder, vector<int>& inorder,\\n                          unordered_map<int, int>& inorder_index, int pre_start,\\n                          int pre_end, int in_start, int in_end) {\\n        if (pre_start > pre_end || in_start > in_end) {\\n            return nullptr;\\n        }\\n        TreeNode* root_node = new TreeNode(preorder[pre_start]);\\n        int root_inorder_index = inorder_index[preorder[pre_start]];\\n\\n        int left_inorder_start = in_start;             //\\n        int left_inorder_end = root_inorder_index - 1; //\\n        int left_inorder_size = left_inorder_end - left_inorder_start + 1;\\n        int left_preorder_start = pre_start + 1; //\\n        int left_preorder_end = left_preorder_start + left_inorder_size - 1;\\n\\n        int right_inorder_start = root_inorder_index + 1; //\\n        int right_inorder_end = in_end;                   //\\n        int right_preorder_start = left_preorder_end + 1;\\n        int right_preorder_end = pre_end;\\n\\n        root_node->left = create_tree(preorder, inorder, inorder_index,\\n                                      left_preorder_start, left_preorder_end,\\n                                      left_inorder_start, left_inorder_end);\\n\\n        root_node->right = create_tree(preorder, inorder, inorder_index,\\n                                       right_preorder_start, right_preorder_end,\\n                                       right_inorder_start, right_inorder_end);\\n        return root_node;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1,"frontend_id":526},{"id":1870671348,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0week, 2\xc2\xa0days","timestamp":1767238581,"status":10,"status_display":"Accepted","runtime":"23 ms","url":"/submissions/detail/1870671348/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"74.7 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        if(preorder.empty() || inorder.empty())return nullptr;\\n\\n        TreeNode* root = new TreeNode(preorder[0]);\\n        \\n        int mid = -1;\\n        for(int i=0; i<inorder.size(); i++){\\n            if(preorder[0] == inorder[i] ){mid = i;break;}\\n        }\\n        if(mid == -1)return nullptr;\\n\\n        vector<int>left_inorder(inorder.begin(),inorder.begin()+mid);\\n        vector<int>right_inorder(inorder.begin()+mid+1,inorder.end());\\n        vector<int>left_preorder(preorder.begin()+1,preorder.begin()+left_inorder.size()+1);\\n        vector<int>right_preorder(preorder.begin()+left_inorder.size()+1,preorder.end());\\n\\n        root->left = buildTree(left_preorder,left_inorder);\\n        root->right = buildTree(right_preorder,right_inorder);\\n        return root;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":null,"flag_type":1,"frontend_id":525},{"id":1855052609,"question_id":89,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0weeks, 5\xc2\xa0days","timestamp":1765685956,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1855052609/","is_pending":"Not Pending","title":"Gray Code","memory":"15.6 MB","code":"class Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int>ans;\\n        solve(n,ans);\\n        return ans;\\n    }\\n\\n    private:\\n    void solve(int n, vector<int>&ans){\\n        if(n<=1){\\n            ans.push_back(0);\\n            ans.push_back(1);\\n            return;\\n        }\\n\\n        solve(n-1,ans);\\n        vector<int>copy(ans);\\n        reverse(copy.begin(),copy.end());\\n        for(auto &element: copy){\\n            element = element | 1 << (n-1);\\n        }\\n        for(auto &el:copy){\\n            ans.push_back(el);\\n        }\\n    }\\n};","compare_result":"1111111111111111","title_slug":"gray-code","has_notes":false,"flag_type":1,"frontend_id":524},{"id":1851395797,"question_id":104,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765305764,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1851395797/","is_pending":"Not Pending","title":"Maximum Depth of Binary Tree","memory":"19 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxDepth(TreeNode* root) {\\n        if(!root)return 0;\\n        int left_depth = maxDepth(root->left);\\n        int right_depth = maxDepth(root->right);\\n\\n        return 1 + max(left_depth,right_depth);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"maximum-depth-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":523},{"id":1851389744,"question_id":235,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765305285,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1851389744/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Search Tree","memory":"23.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return root;\\n\\n        if(p->val  < root->val && q->val  < root->val)return lowestCommonAncestor(root->left, p, q);\\n        if(p->val  > root->val && q->val  > root->val) return lowestCommonAncestor(root->right, p, q);\\n        else return root;\\n    }\\n};","compare_result":"111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":522},{"id":1851384087,"question_id":235,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765304875,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1851384087/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Search Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return root;\\n        if(p == root || q==root)return root;\\n        if(p->val < root->val && root->val < q->val )return root;\\n        else if(p->val  < root->val && q->val  < root->val)return lowestCommonAncestor(root->left, p, q);\\n        else if(p->val  > root->val && q->val  > root->val)return lowestCommonAncestor(root->right, p, q);\\n\\n        return nullptr;\\n    }\\n};","compare_result":"111111101101111011110011010111","title_slug":"lowest-common-ancestor-of-a-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":521},{"id":1851366196,"question_id":236,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765303729,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/1851366196/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"17.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if(!root)return nullptr;\\n        if(root == p || root == q)return root;\\n\\n        TreeNode* left_tree = lowestCommonAncestor(root->left,p,q);\\n        TreeNode* right_tree = lowestCommonAncestor(root->right,p,q);\\n\\n        if(left_tree && right_tree)return root;\\n        if(left_tree && !right_tree){\\n            // In Left Part\\n            return left_tree;\\n        }\\n        if(right_tree && !left_tree){\\n            // in right part\\n            return right_tree;\\n        }\\n\\n        return nullptr;\\n    }\\n};","compare_result":"11111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1,"frontend_id":520},{"id":1851350042,"question_id":98,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765302725,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1851350042/","is_pending":"Not Pending","title":"Validate Binary Search Tree","memory":"22 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return calculate_inorder(root,prev);\\n    }\\n    private:\\n    bool calculate_inorder(TreeNode*& root,TreeNode* &prev){\\n        if(!root)return true;\\n        bool left = calculate_inorder(root->left,prev);\\n        if(prev && prev->val >= root->val)return false;\\n        prev = root;\\n        bool right = calculate_inorder(root->right,prev);\\n        return left & right;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"validate-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":519},{"id":1851346766,"question_id":98,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765302526,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1851346766/","is_pending":"Not Pending","title":"Validate Binary Search Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return calculate_inorder(root,prev);\\n    }\\n    private:\\n    bool calculate_inorder(TreeNode*& root,TreeNode* prev){\\n        if(!root)return true;\\n        bool left = calculate_inorder(root->left,prev);\\n        if(prev && prev->val >= root->val)return false;\\n        prev = root;\\n        bool right = calculate_inorder(root->right,prev);\\n        return left & right;\\n    }\\n};","compare_result":"11111011100110101110011111111111111111111101111111011110010011110011111011111110101110","title_slug":"validate-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":518},{"id":1851335447,"question_id":98,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765301844,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1851335447/","is_pending":"Not Pending","title":"Validate Binary Search Tree","memory":"22.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        vector<int>inorder;\\n        calculate_inorder(root,inorder);\\n        return check_sorted(inorder);\\n    }\\n    private:\\n    void calculate_inorder(TreeNode*& root,vector<int>&inorder){\\n        if(!root)return;\\n        calculate_inorder(root->left,inorder);\\n        inorder.push_back(root->val);\\n        calculate_inorder(root->right,inorder);\\n    }\\n    bool check_sorted(vector<int>&arr){\\n        for(int i=1; i<arr.size(); i++){\\n            if(arr[i-1] >= arr[i])return false;\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"validate-binary-search-tree","has_notes":false,"flag_type":1,"frontend_id":517},{"id":1851322162,"question_id":102,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765301057,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1851322162/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"17.2 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        queue<TreeNode*>queue;\\n        queue.push(root);\\n        while(!queue.empty()){\\n            int size = queue.size();\\n            vector<int>curr;\\n            for(int i=0; i<size; i++){\\n                TreeNode* front_node = queue.front();queue.pop();\\n                curr.push_back(front_node->val);\\n                if(front_node->left)queue.push(front_node->left);\\n                if(front_node->right)queue.push(front_node->right);\\n            }\\n            ans.push_back(curr);\\n        }\\n\\n        return ans;\\n\\n    }\\n};","compare_result":"11111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":516},{"id":1851315345,"question_id":102,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765300657,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1851315345/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"17.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>ans;\\n        if(!root)return ans;\\n        vector<int>curr;\\n        queue<TreeNode*>queue;\\n        queue.push(root);\\n        queue.push(nullptr);\\n\\n        while(!queue.empty()){\\n            TreeNode* front_node = queue.front();\\n            queue.pop();\\n\\n            if(front_node == nullptr){\\n                if(!queue.empty()){\\n                    queue.push(nullptr);\\n                }\\n                ans.push_back(curr);\\n                curr.clear();\\n            }else{\\n                curr.push_back(front_node->val);\\n                if(front_node->left){\\n                    queue.push(front_node->left);\\n                }\\n                if(front_node->right){\\n                    queue.push(front_node->right);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};","compare_result":"11111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":515},{"id":1851152452,"question_id":1331,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765289953,"status":10,"status_display":"Accepted","runtime":"2441 ms","url":"/submissions/detail/1851152452/","is_pending":"Not Pending","title":"Path with Maximum Gold","memory":"358.1 MB","code":"class Solution {\\npublic:\\n    int getMaximumGold(vector<vector<int>>& grid) {\\n        int row_size = grid.size(),col_size = grid[0].size();\\n        vector<vector<bool>>visited(row_size,vector<bool>(col_size,false));\\n        int max_sum = INT_MIN,curr_sum = 0;\\n        for(int i=0; i<row_size; i++)\\n            for(int j=0; j<col_size; j++){\\n                if(grid[i][j]==0)continue;\\n                solve(grid,visited,i,j,curr_sum,max_sum);\\n            }\\n\\n        return max_sum == INT_MIN ? 0 : max_sum;\\n    }\\n\\n    private:\\n    void solve(vector<vector<int>>&grid,vector<vector<bool>>&visited,int row,int col,int  &curr_sum,int &max_sum){\\n\\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size()){\\n            return;\\n        }\\n        if(visited[row][col] == true || grid[row][col] == 0)return;\\n\\n        \\n        // DLRU\\n        vector<int>move_row = {1,0,0,-1};\\n        vector<int>move_col = {0,-1,1,0};\\n\\n        \\n        for(int i=0; i<4; i++){\\n            visited[row][col] = true;\\n            curr_sum += grid[row][col];\\n            max_sum = max(max_sum,curr_sum);\\n            solve(grid,visited,row+move_row[i],col + move_col[i],curr_sum,max_sum);\\n            curr_sum -= grid[row][col];\\n            visited[row][col] = false;\\n            \\n        }\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"path-with-maximum-gold","has_notes":false,"flag_type":1,"frontend_id":514},{"id":1851151586,"question_id":1331,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765289891,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1851151586/","is_pending":"Not Pending","title":"Path with Maximum Gold","memory":"N/A","code":"class Solution {\\npublic:\\n    int getMaximumGold(vector<vector<int>>& grid) {\\n        int row_size = grid.size(),col_size = grid[0].size();\\n        vector<vector<bool>>visited(row_size,vector<bool>(col_size,false));\\n        int max_sum = INT_MIN,curr_sum = 0;\\n        for(int i=0; i<row_size; i++)\\n            for(int j=0; j<col_size; j++){\\n                if(grid[i][j]==0)continue;\\n                solve(grid,visited,i,j,curr_sum,max_sum);\\n            }\\n\\n        return max_sum;\\n    }\\n\\n    private:\\n    void solve(vector<vector<int>>&grid,vector<vector<bool>>&visited,int row,int col,int  &curr_sum,int &max_sum){\\n\\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size()){\\n            return;\\n        }\\n        if(visited[row][col] == true || grid[row][col] == 0)return;\\n\\n        \\n        // DLRU\\n        vector<int>move_row = {1,0,0,-1};\\n        vector<int>move_col = {0,-1,1,0};\\n\\n        \\n        for(int i=0; i<4; i++){\\n            visited[row][col] = true;\\n            curr_sum += grid[row][col];\\n            max_sum = max(max_sum,curr_sum);\\n            solve(grid,visited,row+move_row[i],col + move_col[i],curr_sum,max_sum);\\n            curr_sum -= grid[row][col];\\n            visited[row][col] = false;\\n            \\n        }\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111101111111","title_slug":"path-with-maximum-gold","has_notes":false,"flag_type":1,"frontend_id":513},{"id":1849765091,"question_id":2662,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765165097,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1849765091/","is_pending":"Not Pending","title":"Check Knight Tour Configuration","memory":"32.8 MB","code":"class Solution {\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        bool is_possible = false;\\n        int n = grid.size();\\n        solve(grid,is_possible,0,0,0,n);\\n        return is_possible;\\n    }\\n\\n    private:\\n    void solve(vector<vector<int>>&grid,bool &is_possible,int index,int row,int col, int n){\\n        if(row < 0 || row >= n || col < 0 || col >= n){\\n            return;\\n        }\\n        if(grid[row][col] != index){\\n            return;\\n        }\\n        if(index >= n*n-1){\\n            is_possible = true;\\n            return;\\n        }\\n\\n        vector<int>move_row = {-2,-2,-1,1,2,2,1,-1};\\n        vector<int>move_col = {-1,1,2,2,1,-1,-2,-2};\\n\\n        for(int i=0; i<8; i++){\\n            solve(grid,is_possible,index+1,row + move_row[i],col + move_col[i],n);\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"check-knight-tour-configuration","has_notes":false,"flag_type":1,"frontend_id":512},{"id":1848258724,"question_id":282,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765018807,"status":10,"status_display":"Accepted","runtime":"422 ms","url":"/submissions/detail/1848258724/","is_pending":"Not Pending","title":"Expression Add Operators","memory":"93.4 MB","code":"class Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        string curr_str = \\"\\";\\n        long long curr_value = 0;\\n        long long last_operand = 0;\\n        solve(num, target, 0, ans, curr_str, curr_value, last_operand);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void solve(string& nums, int target, int index, vector<string>& ans,\\n               string curr_str, long long curr_value, long long last_operand) {\\n        if (index >= nums.size()) {\\n            if (curr_value == target) {\\n                ans.push_back(curr_str);\\n            }\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); i++) {\\n            if (i > index && nums[index] == \'0\') {\\n                break;\\n            }\\n            string curr_substr = nums.substr(index, i - index + 1);\\n            long long curr_digit = stoll(curr_substr);\\n\\n            if (index == 0) {\\n                // Don\'t Add Operator at beginning\\n                solve(nums, target, i + 1, ans, curr_str + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n\\n            } else {\\n                // ADD\\n                solve(nums, target, i + 1, ans, curr_str + \\"+\\" + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n                // Subtract\\n                solve(nums, target, i + 1, ans, curr_str + \\"-\\" + curr_substr,\\n                      curr_value - curr_digit, -curr_digit);\\n\\n                // Multiply (UNDO & MULTIPLY)\\n                solve(nums, target, i + 1, ans, curr_str + \\"*\\" + curr_substr,\\n                      (curr_value - last_operand) + (last_operand * curr_digit),\\n                      curr_digit * last_operand);\\n            }\\n        }\\n    }\\n};","compare_result":"1111111111111111111111111","title_slug":"expression-add-operators","has_notes":false,"flag_type":1,"frontend_id":511}],"has_next":true,"last_key":""}'
2026-01-10 09:22:22,188 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:22,189 [INFO] __main__.py:245 - Writing binary-tree-maximum-path-sum/2026-01-01 11.57.22 - Accepted - runtime 0ms - memory 27.8MB.cpp
2026-01-10 09:22:22,190 [INFO] __main__.py:188 - Skipping binary-tree-maximum-path-sum 2026-01-01 11.55.47 because its status is 'Wrong Answer'
2026-01-10 09:22:22,190 [INFO] __main__.py:188 - Skipping binary-tree-maximum-path-sum 2026-01-01 11.55.30 because its status is 'Wrong Answer'
2026-01-10 09:22:23,931 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:23,933 [INFO] __main__.py:245 - Writing kth-smallest-element-in-a-bst/2026-01-01 10.16.07 - Accepted - runtime 0ms - memory 24.4MB.cpp
2026-01-10 09:22:24,396 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:24,399 [INFO] __main__.py:245 - Writing construct-binary-tree-from-preorder-and-inorder-traversal/2026-01-01 09.57.33 - Accepted - runtime 3ms - memory 27.7MB.cpp
2026-01-10 09:22:24,400 [INFO] __main__.py:245 - Writing construct-binary-tree-from-preorder-and-inorder-traversal/2026-01-01 09.06.21 - Accepted - runtime 23ms - memory 74.7MB.cpp
2026-01-10 09:22:24,898 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:24,900 [INFO] __main__.py:245 - Writing gray-code/2025-12-14 09.49.16 - Accepted - runtime 2ms - memory 15.6MB.cpp
2026-01-10 09:22:25,211 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:25,212 [INFO] __main__.py:245 - Writing maximum-depth-of-binary-tree/2025-12-10 00.12.44 - Accepted - runtime 3ms - memory 19MB.cpp
2026-01-10 09:22:25,522 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:25,523 [INFO] __main__.py:245 - Writing lowest-common-ancestor-of-a-binary-search-tree/2025-12-10 00.04.45 - Accepted - runtime 20ms - memory 23.3MB.cpp
2026-01-10 09:22:25,523 [INFO] __main__.py:188 - Skipping lowest-common-ancestor-of-a-binary-search-tree 2025-12-09 23.57.55 because its status is 'Wrong Answer'
2026-01-10 09:22:26,453 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:26,456 [INFO] __main__.py:245 - Writing lowest-common-ancestor-of-a-binary-tree/2025-12-09 23.38.49 - Accepted - runtime 10ms - memory 17.3MB.cpp
2026-01-10 09:22:26,876 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:26,879 [INFO] __main__.py:245 - Writing validate-binary-search-tree/2025-12-09 23.22.05 - Accepted - runtime 0ms - memory 22MB.cpp
2026-01-10 09:22:26,880 [INFO] __main__.py:188 - Skipping validate-binary-search-tree 2025-12-09 23.18.46 because its status is 'Wrong Answer'
2026-01-10 09:22:26,881 [INFO] __main__.py:245 - Writing validate-binary-search-tree/2025-12-09 23.07.24 - Accepted - runtime 0ms - memory 22.1MB.cpp
2026-01-10 09:22:27,698 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:27,699 [INFO] __main__.py:245 - Writing binary-tree-level-order-traversal/2025-12-09 22.54.17 - Accepted - runtime 3ms - memory 17.2MB.cpp
2026-01-10 09:22:27,700 [INFO] __main__.py:245 - Writing binary-tree-level-order-traversal/2025-12-09 22.47.37 - Accepted - runtime 0ms - memory 17.1MB.cpp
2026-01-10 09:22:28,700 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:28,702 [INFO] __main__.py:245 - Writing path-with-maximum-gold/2025-12-09 19.49.13 - Accepted - runtime 2441ms - memory 358.1MB.cpp
2026-01-10 09:22:28,703 [INFO] __main__.py:188 - Skipping path-with-maximum-gold 2025-12-09 19.48.11 because its status is 'Wrong Answer'
2026-01-10 09:22:30,822 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:30,824 [INFO] __main__.py:245 - Writing check-knight-tour-configuration/2025-12-08 09.08.17 - Accepted - runtime 1ms - memory 32.8MB.cpp
2026-01-10 09:22:31,869 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:31,871 [INFO] __main__.py:245 - Writing expression-add-operators/2025-12-06 16.30.07 - Accepted - runtime 422ms - memory 93.4MB.cpp
2026-01-10 09:22:36,873 [DEBUG] leetcode.py:150 - Exporting submissions from 40 to 60
2026-01-10 09:22:37,611 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=40&limit=20 HTTP/1.1" 200 None
2026-01-10 09:22:37,648 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1848257027,"question_id":282,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765018622,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1848257027/","is_pending":"Not Pending","title":"Expression Add Operators","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        string curr_str = \\"\\";\\n        int curr_value = 0;\\n        int last_operand = 0;\\n        solve(num, target, 0, ans, curr_str, curr_value, last_operand);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void solve(string& nums, int target, int index, vector<string>& ans,\\n               string curr_str, int curr_value, int last_operand) {\\n        if (index >= nums.size()) {\\n            if (curr_value == target) {\\n                ans.push_back(curr_str);\\n            }\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); i++) {\\n            if (i > index && nums[index] == \'0\') {\\n                break;\\n            }\\n            string curr_substr = nums.substr(index, i - index + 1);\\n            long long curr_digit = stoll(curr_substr);\\n\\n            if (index == 0) {\\n                // Don\'t Add Operator at beginning\\n                solve(nums, target, i + 1, ans, curr_str + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n\\n            } else {\\n                // ADD\\n                solve(nums, target, i + 1, ans, curr_str + \\"+\\" + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n                // Subtract\\n                solve(nums, target, i + 1, ans, curr_str + \\"-\\" + curr_substr,\\n                      curr_value - curr_digit, -curr_digit);\\n\\n                // Multiply (UNDO & MULTIPLY)\\n                solve(nums, target, i + 1, ans, curr_str + \\"*\\" + curr_substr,\\n                      (curr_value - last_operand) + (last_operand * curr_digit),\\n                      curr_digit * last_operand);\\n            }\\n        }\\n    }\\n};","compare_result":"1111111111111111101111011","title_slug":"expression-add-operators","has_notes":false,"flag_type":1,"frontend_id":510},{"id":1848252151,"question_id":282,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month","timestamp":1765018076,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1848252151/","is_pending":"Not Pending","title":"Expression Add Operators","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<string> addOperators(string num, int target) {\\n        vector<string> ans;\\n        string curr_str = \\"\\";\\n        int curr_value = 0;\\n        int last_operand = 0;\\n        solve(num, target, 0, ans, curr_str, curr_value, last_operand);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void solve(string& nums, int target, int index, vector<string>& ans,\\n               string curr_str, int curr_value, int last_operand) {\\n        if (index >= nums.size()) {\\n            if (curr_value == target) {\\n                ans.push_back(curr_str);\\n            }\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); i++) {\\n            string curr_substr = nums.substr(index, i - index + 1);\\n            long long curr_digit = stoll(curr_substr);\\n\\n            if (i == 0) {\\n                solve(nums, target, i + 1, ans, curr_str + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n\\n            } else {\\n                // ADD\\n                solve(nums, target, i + 1, ans, curr_str + \\"+\\" + curr_substr,\\n                      curr_value + curr_digit, curr_digit);\\n                // Subtract\\n                solve(nums, target, i + 1, ans, curr_str + \\"-\\" + curr_substr,\\n                      curr_value - curr_digit, -curr_digit);\\n\\n                // Multiply (UNDO & MULTIPLY)\\n                solve(nums, target, i + 1, ans, curr_str + \\"*\\" + curr_substr,\\n                      (curr_value - last_operand) + (last_operand * curr_digit),\\n                      curr_digit * last_operand);\\n            }\\n        }\\n    }\\n};","compare_result":"1110000001011010001100010","title_slug":"expression-add-operators","has_notes":false,"flag_type":1,"frontend_id":509},{"id":1842183676,"question_id":93,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 1\xc2\xa0week","timestamp":1764390312,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1842183676/","is_pending":"Not Pending","title":"Restore IP Addresses","memory":"11.1 MB","code":"class Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> final_ans;\\n        int curr_index = 0, curr_segments = 0;\\n        string curr_str = \\"\\";\\n\\n        solve(s, curr_index, curr_segments, curr_str, final_ans);\\n        return final_ans;\\n    }\\n\\nprivate:\\n    void solve(string& s, int curr_index, int& curr_segments, string& curr_str,\\n               vector<string>& final_ans) {\\n        if (curr_segments >= 4 && curr_index >= s.size()) {\\n            final_ans.push_back(curr_str);\\n            return;\\n        }\\n        if (curr_segments >= 4 || curr_index >= s.size()) {\\n            return;\\n        }\\n        // Only 3 length each sub IP Address\\n        for (int i = curr_index; i < s.size() && i < curr_index+3; i++) {\\n            string ip_substr = s.substr(curr_index, i - curr_index + 1);\\n\\n            if (is_valid(ip_substr)) {\\n                int size = curr_str.size();\\n                if (curr_str.size() > 0) {\\n                    curr_str += \\".\\" + ip_substr;\\n                } else {\\n                    curr_str += ip_substr;\\n                }\\n                curr_segments++; // This incremented regardless\\n                solve(s, i+1, curr_segments, curr_str, final_ans);\\n                curr_segments--;\\n                curr_str.erase(size);\\n            }\\n        }\\n    }\\n\\n    bool is_valid(string& str) {\\n        if (str.size() > 1 && str[0] == \'0\')\\n            return false;\\n        if (stoi(str) < 0 || stoi(str) > 255)\\n            return false;\\n\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"restore-ip-addresses","has_notes":false,"flag_type":1,"frontend_id":508},{"id":1842183155,"question_id":93,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 1\xc2\xa0week","timestamp":1764390247,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1842183155/","is_pending":"Not Pending","title":"Restore IP Addresses","memory":"11.1 MB","code":"class Solution {\\npublic:\\n    vector<string> restoreIpAddresses(string s) {\\n        vector<string> final_ans;\\n        int curr_index = 0, curr_dots = 0;\\n        string curr_str = \\"\\";\\n\\n        solve(s, curr_index, curr_dots, curr_str, final_ans);\\n        return final_ans;\\n    }\\n\\nprivate:\\n    void solve(string& s, int curr_index, int& curr_dots, string& curr_str,\\n               vector<string>& final_ans) {\\n        if (curr_dots >= 4 && curr_index >= s.size()) {\\n            final_ans.push_back(curr_str);\\n            return;\\n        }\\n        if (curr_dots >= 4 || curr_index >= s.size()) {\\n            return;\\n        }\\n        // Only 3 length each sub IP Address\\n        for (int i = curr_index; i < s.size() && i < curr_index+3; i++) {\\n            string ip_substr = s.substr(curr_index, i - curr_index + 1);\\n\\n            if (is_valid(ip_substr)) {\\n                int size = curr_str.size();\\n                if (curr_str.size() > 0) {\\n                    curr_str += \\".\\" + ip_substr;\\n                } else {\\n                    curr_str += ip_substr;\\n                }\\n                curr_dots++; // This incremented regardless\\n                solve(s, i+1, curr_dots, curr_str, final_ans);\\n                curr_dots--;\\n                curr_str.erase(size);\\n            }\\n        }\\n    }\\n\\n    bool is_valid(string& str) {\\n        if (str.size() > 1 && str[0] == \'0\')\\n            return false;\\n        if (stoi(str) < 0 || stoi(str) > 255)\\n            return false;\\n\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"restore-ip-addresses","has_notes":false,"flag_type":1,"frontend_id":507},{"id":1841592460,"question_id":77,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 1\xc2\xa0week","timestamp":1764315116,"status":10,"status_display":"Accepted","runtime":"37 ms","url":"/submissions/detail/1841592460/","is_pending":"Not Pending","title":"Combinations","memory":"62.4 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>>final_ans;\\n        vector<int>curr;\\n\\n        find_combo(n,k,1,final_ans,curr);\\n\\n        return final_ans;\\n    }\\n    private:\\n    void find_combo(int n,int k, int index,vector<vector<int>>&final_ans,vector<int>&curr){\\n        if(curr.size() >= k ){\\n            final_ans.push_back(curr);\\n            return;\\n        }\\n\\n        for(int i=index; i<=n; i++){\\n            curr.push_back(i);\\n            find_combo(n,k,i+1,final_ans,curr);\\n            curr.pop_back();\\n\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111","title_slug":"combinations","has_notes":false,"flag_type":1,"frontend_id":506},{"id":1841539177,"question_id":140,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 1\xc2\xa0week","timestamp":1764309898,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1841539177/","is_pending":"Not Pending","title":"Word Break II","memory":"10.2 MB","code":"class Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>final_ans;\\n        unordered_set<string>wordDictSet(wordDict.begin(),wordDict.end());\\n        string curr_str = \\"\\";\\n\\n        find_word_break(s,wordDictSet,0,curr_str,final_ans);\\n\\n        return final_ans;\\n    }\\nprivate:\\n\\n    void find_word_break(string s,unordered_set<string>& wordDict, int index,string& curr_str,vector<string>& final_ans){\\n        if(index >= s.size()){\\n            final_ans.push_back(curr_str);\\n            return;\\n        }\\n\\n        for(int i=index;i <s.size(); i++){\\n            string curr_substr = s.substr(index,i-index+1);\\n\\n            if(wordDict.count(curr_substr)){\\n                int curr_str_size = curr_str.size();\\n\\n                curr_str.size() == 0 ? curr_str += curr_substr : curr_str += \\" \\" + curr_substr;\\n                find_word_break(s,wordDict,i+1,curr_str,final_ans);\\n                curr_str.erase(curr_str_size);\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"word-break-ii","has_notes":false,"flag_type":1,"frontend_id":505},{"id":1841535139,"question_id":140,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 1\xc2\xa0week","timestamp":1764309529,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1841535139/","is_pending":"Not Pending","title":"Word Break II","memory":"10 MB","code":"class Solution {\\npublic:\\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\\n        vector<string>final_ans;\\n        string curr_str = \\"\\";\\n\\n        find_word_break(s,wordDict,0,curr_str,final_ans);\\n\\n        return final_ans;\\n    }\\nprivate:\\n\\n    void find_word_break(string s,vector<string>& wordDict, int index,string& curr_str,vector<string>& final_ans){\\n        if(index >= s.size()){\\n            final_ans.push_back(curr_str);\\n            return;\\n        }\\n\\n        for(int i=index;i <s.size(); i++){\\n            string curr_substr = s.substr(index,i-index+1);\\n\\n            if(find(wordDict.begin(),wordDict.end(),curr_substr) != wordDict.end()){\\n                int curr_str_size = curr_str.size();\\n\\n                curr_str.size() == 0 ? curr_str += curr_substr : curr_str += \\" \\" + curr_substr;\\n                find_word_break(s,wordDict,i+1,curr_str,final_ans);\\n                curr_str.erase(curr_str_size);\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"word-break-ii","has_notes":false,"flag_type":1,"frontend_id":504},{"id":1839202547,"question_id":526,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1764056024,"status":10,"status_display":"Accepted","runtime":"55 ms","url":"/submissions/detail/1839202547/","is_pending":"Not Pending","title":"Beautiful Arrangement","memory":"8 MB","code":"class Solution {\\npublic:\\n    int countArrangement(int n) {\\n        int count = 0;\\n        vector<bool>visited(n+1,false); // n+1 because directly 1 based indexing used\\n        int curr_pos = 1;\\n        count_beauty(n,count,visited,curr_pos);\\n        return count;\\n    }\\n\\n    private:\\n    void count_beauty(int n, int &count,vector<bool>&visited,int curr_pos){\\n        if( curr_pos > n){\\n            count++;\\n            return ;\\n        }\\n    // curr_pos -> slot, i -> value at slot\\n        for(int i=1; i<=n; i++){\\n            if(visited[i])continue;\\n                visited[i]=1;\\n            if(( curr_pos % i == 0 ) || (i % curr_pos ==0)){\\n                count_beauty(n,count,visited,curr_pos+1);\\n            }\\n                visited[i]=0;\\n           \\n        }\\n\\n    }\\n};","compare_result":"111111111111111","title_slug":"beautiful-arrangement","has_notes":false,"flag_type":1,"frontend_id":503},{"id":1839201076,"question_id":526,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1764055880,"status":10,"status_display":"Accepted","runtime":"49 ms","url":"/submissions/detail/1839201076/","is_pending":"Not Pending","title":"Beautiful Arrangement","memory":"7.9 MB","code":"class Solution {\\npublic:\\n    int countArrangement(int n) {\\n        int count = 0;\\n        vector<bool>visited(n+1,false); // So directly 1-based index used\\n        int curr_pos = 1;\\n        count_beauty(n,count,visited,curr_pos);\\n        return count;\\n    }\\n\\n    private:\\n    void count_beauty(int n, int &count,vector<bool>&visited,int curr_pos){\\n        if( curr_pos > n){\\n            count++;\\n            return ;\\n        }\\n\\n        for(int i=1; i<=n; i++){\\n            if(visited[i])continue;\\n            if(( curr_pos % i == 0 ) || (i % curr_pos ==0)){\\n                visited[i]=1;\\n                count_beauty(n,count,visited,curr_pos+1);\\n                visited[i]=0;\\n            }\\n           \\n        }\\n\\n    }\\n};","compare_result":"111111111111111","title_slug":"beautiful-arrangement","has_notes":false,"flag_type":1,"frontend_id":502},{"id":1839200455,"question_id":526,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1764055821,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1839200455/","is_pending":"Not Pending","title":"Beautiful Arrangement","memory":"N/A","code":"class Solution {\\npublic:\\n    int countArrangement(int n) {\\n        int count = 0;\\n        vector<bool>visited(n+1,false); // So directly 1-based index used\\n        int curr_pos = 1;\\n        count_beauty(n,count,visited,curr_pos);\\n        return count;\\n    }\\n\\n    private:\\n    void count_beauty(int n, int &count,vector<bool>&visited,int curr_pos){\\n        if( curr_pos >= n){\\n            count++;\\n            return ;\\n        }\\n\\n        for(int i=1; i<=n; i++){\\n            if(visited[i])continue;\\n            visited[i]=1;\\n            if(( curr_pos % i == 0 ) || (i % curr_pos ==0)){\\n                count_beauty(n,count,visited,curr_pos+1);\\n            }\\n            visited[i]=0;\\n           \\n        }\\n\\n    }\\n};","compare_result":"110000000000000","title_slug":"beautiful-arrangement","has_notes":false,"flag_type":1,"frontend_id":501},{"id":1839149505,"question_id":216,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1764051625,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1839149505/","is_pending":"Not Pending","title":"Combination Sum III","memory":"8.8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> final_ans;\\n        vector<int> curr_combo;\\n        long long curr_sum = 0;\\n        solve(k, n, final_ans, curr_combo, curr_sum, 1);\\n        return final_ans;\\n    }\\n\\nprivate:\\n    // k -> size, n -> target\\n    void solve(int k_size, int target_sum, vector<vector<int>>& final_ans,\\n               vector<int>& curr_combo, long long& curr_sum, int start_index) {\\n        if (curr_combo.size() >= k_size && curr_sum == target_sum) {\\n            final_ans.push_back(curr_combo);\\n            return;\\n        } else if (curr_combo.size() >= k_size && curr_sum != target_sum) {\\n            return;\\n        }\\n\\n        for (int j = start_index; j <= 9; j++) {\\n            curr_sum += j;\\n            curr_combo.push_back(j);\\n            solve(k_size, target_sum, final_ans, curr_combo, curr_sum, j + 1);\\n            // Backtrack\\n            curr_sum -= j;\\n            curr_combo.pop_back();\\n        }\\n    }\\n};","compare_result":"1111111111111111111","title_slug":"combination-sum-iii","has_notes":false,"flag_type":1,"frontend_id":500},{"id":1839050943,"question_id":37,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1764043473,"status":10,"status_display":"Accepted","runtime":"417 ms","url":"/submissions/detail/1839050943/","is_pending":"Not Pending","title":"Sudoku Solver","memory":"8.6 MB","code":"class Solution {\\npublic:\\n    void solveSudoku(vector<vector<char>>& board) {\\n        solve(board);\\n    }\\n    private:\\n\\n    bool solve(vector<vector<char>>&board){\\n        for(int i=0; i<9; i++){\\n            for(int j=0; j<9; j++){\\n                if(board[i][j]==\'.\'){\\n                    for(int k=1; k<=9; k++){\\n                        if(is_valid(board,i,j,k)){\\n                            board[i][j] = k + \'0\';\\n                            if(solve(board)){\\n                                return true;\\n                            }\\n                            board[i][j]=\'.\';\\n                        }\\n                    }\\n                    return false; // invalid path\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool is_valid(vector<vector<char>>&board,int row,int col,int curr_digit){\\n        for(int i=0; i<9;i++){\\n            if(board[row][i]==curr_digit+\'0\')return false;\\n            if(board[i][col]==curr_digit+\'0\')return false;\\n            if(board[3* (row/3) + i/3][3* (col/3) + i%3]==curr_digit+\'0\')return false;\\n        }\\n        return true;\\n    }\\n};","compare_result":"1111111","title_slug":"sudoku-solver","has_notes":false,"flag_type":1,"frontend_id":499},{"id":1837302829,"question_id":3946,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763868054,"status":10,"status_display":"Accepted","runtime":"733 ms","url":"/submissions/detail/1837302829/","is_pending":"Not Pending","title":"Find Maximum Balanced XOR Subarray Length","memory":"350.9 MB","code":"class Solution {\\npublic:\\n    int maxBalancedSubarray(vector<int>& nums) {\\n        map<pair<int,int>,int>fo;\\n        fo[{0,0}]=-1;\\n        int cx = 0,cb=0,ml=0;\\n\\n        for(int i=0; i<nums.size();i++){\\n            cx ^= nums[i];\\n            if(nums[i] % 2 != 0)cb+=1;\\n            else cb-=1;\\n\\n            if(fo.count({cx,cb})){\\n                int prev = fo[{cx,cb}];\\n                ml = max(ml,i-prev);\\n            }else fo[{cx,cb}] = i;\\n    }\\n    \\n\\n        return ml;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-maximum-balanced-xor-subarray-length","has_notes":false,"flag_type":1,"frontend_id":498},{"id":1837292864,"question_id":4134,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763867548,"status":10,"status_display":"Accepted","runtime":"327 ms","url":"/submissions/detail/1837292864/","is_pending":"Not Pending","title":"Number of Effective Subsequences","memory":"198.9 MB","code":"class Solution {\\npublic:\\n    int countEffective(vector<int>& nums) {\\n        long long MOD = 1e9+7;\\n        int n = nums.size(),s=0;\\n        for(auto num:nums)s = s | num;\\n\\n\\n        int nb = 0;\\n        while((1<<nb)<=s)nb++;\\n        \\n        int limit = 1<<nb;\\n        vector<long long>fi(limit,0);\\n\\n        for(auto x:nums)fi[x]++;\\n\\n        for(int i=0; i<nb; i++)\\n            for(int j=0; j<limit; j++){\\n                if(j & ( 1<<i))fi[j] += fi[j^(1<<i)];\\n            }\\n\\n        vector<long long> power_2(n+1);\\n        power_2[0]=1;\\n        for(int i=1; i<n+1;i++)power_2[i] = (power_2[i-1]*2)%MOD;\\n\\n        long long count = 0;\\n        int pops = __builtin_popcount(s); \\n\\n        for(int i=0; i<s+1; i++){\\n            if((i | s)==s){\\n                int pop = __builtin_popcount(i);\\n                long long difference = pops - pop;\\n\\n                long long paths = power_2[fi[i]];\\n\\n                if(difference % 2 == 1)count = (count - paths + MOD) % MOD;\\n                else count = (count+paths) % MOD;\\n            }\\n        }\\n\\n        long long all_sets = power_2[nums.size()],final_ans = (all_sets - count + MOD)%MOD;\\n        return final_ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-effective-subsequences","has_notes":false,"flag_type":1,"frontend_id":497},{"id":1837289301,"question_id":4136,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763867372,"status":10,"status_display":"Accepted","runtime":"74 ms","url":"/submissions/detail/1837289301/","is_pending":"Not Pending","title":"Concatenate Non-Zero Digits and Multiply by Sum II","memory":"174.2 MB","code":"class Solution {\\npublic:\\n    vector<int> sumAndMultiply(string s, vector<vector<int>>& queries) {\\n        int m = s.length();\\n        long long MOD = 1e9+7;\\n\\n        vector<long long>ps(m+1,0),pc(m+1,0),pv(m+1,0),pow(m+1,1);\\n        vector<int>result;\\n\\n        for(int i=0; i<m; i++){\\n            int d = s[i] - \'0\';\\n            ps[i+1] = ps[i] + d;\\n\\n            if(d!= 0){\\n                pc[i+1] = pc[i]+1;\\n                pv[i+1] = (pv[i]*10+d)%MOD;\\n                \\n            }else{\\n                pc[i+1] = pc[i];\\n                pv[i+1] = pv[i];\\n            }\\n            pow[i+1] = (pow[i]*10)%MOD;\\n        }\\n\\n        for(auto q:queries){\\n            int li = q[0],ri=q[1];\\n            long long cs = ps[ri+1]-ps[li],cnt = pc[ri+1]-pc[li];\\n            if(cnt == 0){\\n                result.push_back(0);continue;\\n            }\\n\\n            long long t = (pv[li]*pow[cnt])%MOD;\\n            long long cx = (pv[ri+1]-t + MOD)%MOD;\\n            long long ans = (cx*(cs%MOD))%MOD;\\n            result.push_back((int)ans);\\n        }\\n        return result;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"concatenate-non-zero-digits-and-multiply-by-sum-ii","has_notes":false,"flag_type":1,"frontend_id":496},{"id":1837287756,"question_id":4134,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763867292,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1837287756/","is_pending":"Not Pending","title":"Number of Effective Subsequences","memory":"N/A","code":"class Solution {\\npublic:\\n    int countEffective(vector<int>& nums) {\\n        long long MOD = 1e9+7;\\n        int n = nums.size(),s=0;\\n        for(auto num:nums)s = s | num;\\n\\n        int limit = 1<<20;\\n        vector<long long>fi(limit,0);\\n\\n        for(auto x:nums)fi[x]++;\\n\\n        for(int i=0; i<20; i++)\\n            for(int j=0; j<limit; j++){\\n                if(j & ( 1<<i))fi[j] += fi[j^(1<<i)];\\n            }\\n\\n        vector<long long> power_2(n+1);\\n        power_2[0]=1;\\n        for(int i=1; i<n+1;i++)power_2[i] = (power_2[i-1]*2)%MOD;\\n\\n        long long count = 0;\\n        int pops = __builtin_popcount(s); \\n\\n        for(int i=0; i<s+1; i++){\\n            if((i | s)==s){\\n                int pop = __builtin_popcount(i);\\n                long long difference = pops - pop;\\n\\n                long long paths = power_2[fi[i]];\\n\\n                if(difference % 2 == 1)count = (count - paths + MOD) % MOD;\\n                else count = (count+paths) % MOD;\\n            }\\n        }\\n\\n        long long all_sets = power_2[nums.size()],final_ans = (all_sets - count + MOD)%MOD;\\n        return final_ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"number-of-effective-subsequences","has_notes":false,"flag_type":1,"frontend_id":495},{"id":1837249838,"question_id":4135,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763865555,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1837249838/","is_pending":"Not Pending","title":"Concatenate Non-Zero Digits and Multiply by Sum I","memory":"9.5 MB","code":"class Solution {\\npublic:\\n    long long sumAndMultiply(int n) {\\n        vector<int>digits;\\n        long long sum = 0;\\n        string non_zero = \\"\\";\\n        while(n!=0){\\n            if(n%10 != 0){\\n                sum += n%10;\\n                non_zero += to_string(n%10);\\n            }\\n            n/=10;\\n        }\\n\\n        if(non_zero.empty())return 0;\\n\\n        reverse(non_zero.begin(),non_zero.end());\\n\\n        return sum * stoll(non_zero);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"concatenate-non-zero-digits-and-multiply-by-sum-i","has_notes":false,"flag_type":1,"frontend_id":494},{"id":1837245678,"question_id":4135,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763865414,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1837245678/","is_pending":"Not Pending","title":"Concatenate Non-Zero Digits and Multiply by Sum I","memory":"N/A","code":"class Solution {\\npublic:\\n    long long sumAndMultiply(int n) {\\n        vector<int>digits;\\n        long long sum = 0;\\n        string non_zero = \\"\\";\\n        while(n!=0){\\n            if(n%10 != 0){\\n                sum += n%10;\\n                non_zero += to_string(n%10);\\n            }\\n            n/=10;\\n        }\\n\\n        reverse(non_zero.begin(),non_zero.end());\\n\\n        return sum * stoi(non_zero);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000","title_slug":"concatenate-non-zero-digits-and-multiply-by-sum-i","has_notes":false,"flag_type":1,"frontend_id":493},{"id":1836895356,"question_id":4128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763825453,"status":10,"status_display":"Accepted","runtime":"39 ms","url":"/submissions/detail/1836895356/","is_pending":"Not Pending","title":"Total Waviness of Numbers in Range II","memory":"10.3 MB","code":"class Solution {\\npublic:\\n    long long totalWaviness(long long num1, long long num2) {\\n        long long answer =  solve(num2) - solve(num1-1);\\n        return answer;\\n    }\\n    private:\\n    string s;\\n    struct Result{\\n        long long count,wavy;\\n    }dp[17][11][4][2][2];\\n\\n    Result dp_function(int index,int prev,int tr, bool ti, bool le){\\n        if(index == s.size())return {1,0};\\n        if(dp[index][prev][tr][ti][le].count!= -1)\\n        return dp[index][prev][tr][ti][le];\\n\\n        long long tc = 0,tw=0,limit = ti ?( s[index] - \'0\'):9;\\n\\n        for(int d = 0; d<= limit; d++){\\n            bool nt = ti && (d == limit),nl = le && !d;\\n\\n            if(nl){\\n                Result res_obj = dp_function(index+1,10,0,nt,1);\\n                tc += res_obj.count;\\n                tw += res_obj.wavy;\\n            }else{\\n                int ntr = 0;\\n                int peak_or_valley = 0;\\n                if(prev != 10){\\n                    if(prev > d)ntr = 2;\\n                    else if(prev < d)ntr = 1;\\n                    else ntr= 3;\\n\\n                    if(tr == 1 && prev > d || tr == 2 && prev < d)peak_or_valley = 1;\\n        }\\n\\n                    Result res_obj = dp_function(index+1,d,ntr,nt,0);\\n                    tc += res_obj.count;\\n                    tw += res_obj.wavy + (res_obj.count * peak_or_valley);\\n                }\\n            }\\n            return dp[index][prev][tr][ti][le] = {tc,tw};\\n        }\\n        long long solve(long long n){\\n            if(n<=0)return 0;\\n            s = to_string(n);\\n            for(int i=0; i<17;i++)\\n                for(int j=0; j<11; j++)\\n                    for(int k=0; k<4; k++)\\n                        for(int l=0; l<2; l++)\\n                            for(int m=0; m<2; m++)\\n                                dp[i][j][k][l][m]={-1,-1};\\n\\n            return dp_function(0,10,0,1,1).wavy;\\n    }\\n    \\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"total-waviness-of-numbers-in-range-ii","has_notes":false,"flag_type":1,"frontend_id":492},{"id":1836860400,"question_id":4077,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763823998,"status":10,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/1836860400/","is_pending":"Not Pending","title":"Lexicographically Smallest Negated Permutation that Sums to Target","memory":"90.7 MB","code":"class Solution {\\npublic:\\n    vector<int> lexSmallestNegatedPerm(int n, long long target) {\\n        long long ts = (long long) n*(n+1)/2, diff = ts - target;\\n\\n        if(diff % 2!= 0 || diff < 0)return {};\\n\\n        long long k = diff/2;\\n        vector<int>res;\\n        vector<bool>is_neg(n+1,0);\\n\\n        for(int i=n;i>0;i--){\\n            if(k>=i){\\n                k-=i;\\n                is_neg[i] = 1;\\n                res.push_back(-i);\\n            }\\n        }\\n\\n        if(k>0)return {};\\n\\n        for(int i=1; i<n+1; i++){\\n            if(!is_neg[i])res.push_back(i);\\n        }\\n        return res;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"lexicographically-smallest-negated-permutation-that-sums-to-target","has_notes":false,"flag_type":1,"frontend_id":491}],"has_next":true,"last_key":""}'
2026-01-10 09:22:37,649 [INFO] __main__.py:188 - Skipping expression-add-operators 2025-12-06 16.27.02 because its status is 'Wrong Answer'
2026-01-10 09:22:37,650 [INFO] __main__.py:188 - Skipping expression-add-operators 2025-12-06 16.17.56 because its status is 'Wrong Answer'
2026-01-10 09:22:39,199 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:39,199 [INFO] __main__.py:245 - Writing restore-ip-addresses/2025-11-29 09.55.12 - Accepted - runtime 4ms - memory 11.1MB.cpp
2026-01-10 09:22:39,200 [INFO] __main__.py:245 - Writing restore-ip-addresses/2025-11-29 09.54.07 - Accepted - runtime 3ms - memory 11.1MB.cpp
2026-01-10 09:22:40,400 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:40,401 [INFO] __main__.py:245 - Writing combinations/2025-11-28 13.01.56 - Accepted - runtime 37ms - memory 62.4MB.cpp
2026-01-10 09:22:41,734 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:41,735 [INFO] __main__.py:245 - Writing word-break-ii/2025-11-28 11.34.58 - Accepted - runtime 0ms - memory 10.2MB.cpp
2026-01-10 09:22:41,735 [INFO] __main__.py:245 - Writing word-break-ii/2025-11-28 11.28.49 - Accepted - runtime 0ms - memory 10MB.cpp
2026-01-10 09:22:43,851 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:43,852 [INFO] __main__.py:245 - Writing beautiful-arrangement/2025-11-25 13.03.44 - Accepted - runtime 55ms - memory 8MB.cpp
2026-01-10 09:22:43,853 [INFO] __main__.py:245 - Writing beautiful-arrangement/2025-11-25 13.01.20 - Accepted - runtime 49ms - memory 7.9MB.cpp
2026-01-10 09:22:43,854 [INFO] __main__.py:188 - Skipping beautiful-arrangement 2025-11-25 13.00.21 because its status is 'Wrong Answer'
2026-01-10 09:22:44,859 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:44,861 [INFO] __main__.py:245 - Writing combination-sum-iii/2025-11-25 11.50.25 - Accepted - runtime 0ms - memory 8.8MB.cpp
2026-01-10 09:22:45,174 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:45,176 [INFO] __main__.py:245 - Writing sudoku-solver/2025-11-25 09.34.33 - Accepted - runtime 417ms - memory 8.6MB.cpp
2026-01-10 09:22:45,613 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:45,615 [INFO] __main__.py:245 - Writing find-maximum-balanced-xor-subarray-length/2025-11-23 08.50.54 - Accepted - runtime 733ms - memory 350.9MB.cpp
2026-01-10 09:22:45,960 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:45,965 [INFO] __main__.py:245 - Writing number-of-effective-subsequences/2025-11-23 08.42.28 - Accepted - runtime 327ms - memory 198.9MB.cpp
2026-01-10 09:22:46,796 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:46,799 [INFO] __main__.py:245 - Writing concatenate-non-zero-digits-and-multiply-by-sum-ii/2025-11-23 08.39.32 - Accepted - runtime 74ms - memory 174.2MB.cpp
2026-01-10 09:22:46,800 [INFO] __main__.py:188 - Skipping number-of-effective-subsequences 2025-11-23 08.38.12 because its status is 'Time Limit Exceeded'
2026-01-10 09:22:48,139 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:48,147 [INFO] __main__.py:245 - Writing concatenate-non-zero-digits-and-multiply-by-sum-i/2025-11-23 08.09.15 - Accepted - runtime 0ms - memory 9.5MB.cpp
2026-01-10 09:22:48,152 [INFO] __main__.py:188 - Skipping concatenate-non-zero-digits-and-multiply-by-sum-i 2025-11-23 08.06.54 because its status is 'Runtime Error'
2026-01-10 09:22:49,136 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:49,142 [INFO] __main__.py:245 - Writing total-waviness-of-numbers-in-range-ii/2025-11-22 21.00.53 - Accepted - runtime 39ms - memory 10.3MB.cpp
2026-01-10 09:22:51,149 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:22:51,151 [INFO] __main__.py:245 - Writing lexicographically-smallest-negated-permutation-that-sums-to-target/2025-11-22 20.36.38 - Accepted - runtime 14ms - memory 90.7MB.cpp
2026-01-10 09:22:56,156 [DEBUG] leetcode.py:150 - Exporting submissions from 60 to 80
2026-01-10 09:22:58,860 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=60&limit=20 HTTP/1.1" 200 None
2026-01-10 09:22:58,862 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1836841638,"question_id":4057,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763823302,"status":10,"status_display":"Accepted","runtime":"443 ms","url":"/submissions/detail/1836841638/","is_pending":"Not Pending","title":"Total Waviness of Numbers in Range I","memory":"118.9 MB","code":"class Solution {\\npublic:\\n    int totalWaviness(int num1, int num2) {\\n        int peak = 0,valley = 0, wavy = 0;\\n\\n        for(int i=num1; i<=num2; i++){\\n            wavy += find_peak_valley(i);\\n        }\\n        return wavy;\\n    }\\n    private:\\n    int find_peak_valley(int num){\\n        vector<int>peak_arr;\\n        int count_peak = 0,count_valley=0;\\n        while(num!=0){\\n            peak_arr.push_back(num%10);\\n            num/=10;\\n        }\\n\\n        for(int i=1;i<peak_arr.size()-1; i++){\\n            if(peak_arr[i] > peak_arr[i-1] && peak_arr[i] > peak_arr[i+1])count_peak++;\\n            else if(peak_arr[i] < peak_arr[i-1] && peak_arr[i] < peak_arr[i+1])count_valley++;\\n        }\\n        return count_peak + count_valley;\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"total-waviness-of-numbers-in-range-i","has_notes":false,"flag_type":1,"frontend_id":490},{"id":1836835160,"question_id":4057,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763823069,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1836835160/","is_pending":"Not Pending","title":"Total Waviness of Numbers in Range I","memory":"N/A","code":"class Solution {\\npublic:\\n    int totalWaviness(int num1, int num2) {\\n        int peak = 0,valley = 0, wavy = 0;\\n\\n        for(int i=num1; i<=num2; i++){\\n            wavy += find_peak_valley(i);\\n        }\\n        return wavy;\\n    }\\n    private:\\n    int find_peak_valley(int num){\\n        vector<int>peak_arr;\\n        int count_peak = 0,count_valley=0;\\n        while(num!=0){\\n            peak_arr.push_back(num%10);\\n            num/=10;\\n        }\\n\\n        for(int i=1;i<peak_arr.size()-1; i++){\\n            if(peak_arr[i] > peak_arr[i-1] && peak_arr[i+1])count_peak++;\\n            else if(peak_arr[i] < peak_arr[i-1] && peak_arr[i] < peak_arr[i+1])count_valley++;\\n        }\\n        return count_peak + count_valley;\\n        \\n    }\\n};","compare_result":"111111111000110111110000111111100110000111110011101110001110001110110011110100100101111001011000000010111110000111010010000111110001110100010010001011110010111000010001010000111110000001101001111011010011101001100000101000010001001010000001100001000000101110111010000111000000100011000010010001000100000010011001000010000000000000000011000000000100000001010000001001000100010000100000001000010000110000000010000000000001000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000110011010111111111111001111111111011111","title_slug":"total-waviness-of-numbers-in-range-i","has_notes":false,"flag_type":1,"frontend_id":489},{"id":1836814607,"question_id":4126,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763822409,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1836814607/","is_pending":"Not Pending","title":"Minimum Number of Flips to Reverse Binary String","memory":"9.7 MB","code":"class Solution {\\npublic:\\n    int minimumFlips(int n) {\\n        string reversed = \\"\\";\\n        while(n!=0){\\n            string rem = to_string(n%2);\\n            n/=2;\\n            reversed += rem;\\n        }\\n        string original = reversed;\\n        reverse(original.begin(),original.end());\\n        int ans = 0;\\n        for(int i = 0; i<reversed.size(); i++){\\n            if(reversed[i] != original[i])ans++;\\n        }\\n        return ans;\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-flips-to-reverse-binary-string","has_notes":false,"flag_type":1,"frontend_id":488},{"id":1836404926,"question_id":131,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 2\xc2\xa0weeks","timestamp":1763780114,"status":10,"status_display":"Accepted","runtime":"59 ms","url":"/submissions/detail/1836404926/","is_pending":"Not Pending","title":"Palindrome Partitioning","memory":"61.6 MB","code":"class Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>final_ans;\\n        vector<string>curr_string;\\n\\n        find_palindrome_partition(s,0,curr_string,final_ans);\\n\\n        return final_ans;\\n    }\\n    \\n    private:\\n    void find_palindrome_partition(string s,int index,vector<string>& curr_string,vector<vector<string>> &final_ans){\\n        if(index >= s.size()){\\n            final_ans.push_back(curr_string);\\n            return;\\n        }\\n\\n        for(int i=index; i<s.size(); i++){\\n            if(is_palindrome(s,index,i)){\\n                curr_string.push_back(s.substr(index,i-index+1));\\n                find_palindrome_partition(s,i+1,curr_string,final_ans);\\n                curr_string.pop_back();\\n            }\\n        }\\n    }\\n\\n    bool is_palindrome(string s,int start,int end){\\n        while(start < end){\\n            if(s[start] != s[end]){\\n                return false;\\n            }\\n            start++;end--;\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111","title_slug":"palindrome-partitioning","has_notes":false,"flag_type":1,"frontend_id":487},{"id":1830930530,"question_id":4110,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763264269,"status":10,"status_display":"Accepted","runtime":"272 ms","url":"/submissions/detail/1830930530/","is_pending":"Not Pending","title":"Count Stable Subarrays","memory":"269.5 MB","code":"class Solution {\\n    long long countSubarray(long long n){\\n        return n*(n+1)/2;\\n    }\\npublic:\\n    vector<long long> countStableSubarrays(vector<int>& nums,\\n                                           vector<vector<int>>& queries) {\\n        vector<long long> ans;\\n\\n        vector<int> last(nums.size());\\n\\n        last[nums.size() - 1] = nums.size() - 1;\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            if (nums[i] <= nums[i + 1])\\n                last[i] = last[i + 1];\\n            else\\n                last[i] = i;\\n        }\\n\\n        int b_size = (int)sqrt(nums.size()) + 1;\\n\\n        vector<int> hop(nums.size());\\n        vector<long long> sum(nums.size(), 0);\\n\\n        for (int i = nums.size() - 1; i >= 0; i--) {\\n            int next_bs = last[i] + 1;\\n\\n            if (next_bs < nums.size() && (i / b_size) == (next_bs / b_size)) {\\n                hop[i] = hop[next_bs];\\n                long long c_bl = last[i] - i + 1;\\n                sum[i] = countSubarray(c_bl) + sum[next_bs];\\n            } else {\\n                hop[i] = next_bs;\\n                long long c_bl = last[i] - i + 1;\\n                sum[i] = countSubarray(c_bl);\\n            }\\n        }\\n\\n        for (const auto& q : queries) {\\n            int l = q[0], r = q[1];\\n            long long tc = 0;\\n            int curr = l;\\n            while (curr <= r) {\\n                if ((curr / b_size) != (r / b_size) && hop[curr] <= r) {\\n                    tc += sum[curr];\\n                    curr = hop[curr];\\n                } else {\\n                    int be = last[curr];\\n                    int ie = min(be, r);\\n                    long long len = ie - curr + 1;\\n                    tc += countSubarray(len);\\n                    curr = ie + 1;\\n                }\\n            }\\n            ans.push_back(tc);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-stable-subarrays","has_notes":false,"flag_type":1,"frontend_id":486},{"id":1830907109,"question_id":4054,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763263179,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1830907109/","is_pending":"Not Pending","title":"Count Distinct Integers After Removing Zeros","memory":"9.3 MB","code":"class Solution {\\n    long long dp[17]; \\n\\n    long long get_ans(int k) {\\n        if (k == 0) return 1;\\n\\n        if (dp[k] != 0) return dp[k];\\n\\n        dp[k] = 9 * get_ans(k - 1);\\n\\n        return dp[k];\\n\\n    }\\n\\n    long long solve(string& s, int i, bool is_tight) {\\n        if (i == s.length()) {\\n            return 1;\\n        }\\n\\n        long long count = 0;\\n\\n        int limit = is_tight ? (s[i] - \'0\') : 9;\\n\\n\\n\\n        for (int d = 1; d <= 9; ++d) {\\n\\n            if (d > limit) {\\n\\n                break;\\n\\n            }\\n            if (d < limit) {\\n                count += get_ans(s.length() - i - 1);\\n            } else {\\n                count += solve(s, i + 1, is_tight);\\n            }\\n        }\\n        return count;\\n    }\\npublic:\\n    long long countDistinct(long long n) {\\n        string str = to_string(n);\\n        int length = str.length();\\n        long long tc = 0;\\n        for(int i=0; i<17; i++)dp[i]=0;\\n\\n        for(int i=1; i<length; i++){\\n            tc += get_ans(i);\\n        }\\n        tc+= solve(str,0,true);\\n        return tc;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-distinct-integers-after-removing-zeros","has_notes":false,"flag_type":1,"frontend_id":485},{"id":1830896508,"question_id":4054,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763262724,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1830896508/","is_pending":"Not Pending","title":"Count Distinct Integers After Removing Zeros","memory":"N/A","code":"class Solution {\\n    long long max_possible_n;\\n    long long current_count;\\n\\n    void calculate_count(long long num){\\n        if(num != 0)current_count++;\\n\\n        for(int i=1;i<=9; i++){\\n            long long next = num * 10 + i;\\n\\n            if(next < num)continue;\\n\\n            if(next <= max_possible_n)calculate_count(next);\\n        }\\n    }\\npublic:\\n    long long countDistinct(long long n) {\\n        max_possible_n = n;\\n        current_count=0;\\n\\n        calculate_count(0);\\n        return current_count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"count-distinct-integers-after-removing-zeros","has_notes":false,"flag_type":1,"frontend_id":484},{"id":1830867771,"question_id":4090,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763261560,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1830867771/","is_pending":"Not Pending","title":"Minimum String Length After Balanced Removals","memory":"15.4 MB","code":"class Solution {\\npublic:\\n    int minLengthAfterRemovals(string s) {\\n        stack<char> stack;\\n        int total_length = s.size(), count_a = 0,count_b=0;\\n        for (int i = 0; i < s.size(); i++) {\\n            if(s[i]==\'a\')count_a++;\\n            else count_b++;\\n        }\\n\\n        \\n\\n        return abs(count_a-count_b);\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-string-length-after-balanced-removals","has_notes":false,"flag_type":1,"frontend_id":483},{"id":1830848500,"question_id":4090,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763260854,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1830848500/","is_pending":"Not Pending","title":"Minimum String Length After Balanced Removals","memory":"N/A","code":"class Solution {\\npublic:\\n    int minLengthAfterRemovals(string s) {\\n        stack<char>stack;\\n            int total_length = s.size();\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \'a\'){\\n                stack.push(\'a\');\\n            }else{\\n                // Encounter \'b\'\\n                if(!stack.empty()){\\n                    stack.pop();\\n                    total_length -= 2;\\n                }\\n            }\\n        }\\n        return total_length;\\n    }\\n};","compare_result":"11111110110011111101011111100110010101110011111010111101011001010111000110001101111011100011110001111111100001011111110001011001110111010101010001101100111001111011011111011110111010010010101001000001110000101000111110100001110110011101100000001111110010101001001111010110000101101010101000010001101110100101110000000100010010011100101011100000001011100010111100100100010101001111111011001100011001010001010110000001010000010011001011010001101000010001100011010100101010000110000100011101010011101101100001000000001011010010010011100000011000010100001000010010110111010001001110010111001010101101011110011110010001010011100010011100001110001011001010100001000110110100100001111010","title_slug":"minimum-string-length-after-balanced-removals","has_notes":false,"flag_type":1,"frontend_id":482},{"id":1830832779,"question_id":4112,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763260405,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1830832779/","is_pending":"Not Pending","title":"Maximize Expression of Three Elements","memory":"31.2 MB","code":"class Solution {\\npublic:\\n    int maximizeExpressionOfThree(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int size = nums.size();\\n        int ans = (nums[size-1] + nums[size-2]) - nums[0];\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximize-expression-of-three-elements","has_notes":false,"flag_type":1,"frontend_id":481},{"id":1829641605,"question_id":17,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763129267,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1829641605/","is_pending":"Not Pending","title":"Letter Combinations of a Phone Number","memory":"9.7 MB","code":"class Solution {\\n    void all_combo(int curr_digit_index, string digits, string& curr_string,\\n                   vector<string>& ans,unordered_map<char,string>&num_alpha) {\\n        if (curr_digit_index >= digits.size()) {\\n            ans.push_back(curr_string);\\n            return;\\n        }\\n\\n        int curr_digit = stoi(to_string(digits[curr_digit_index]));\\n        for(int i=0; i<num_alpha[curr_digit].size(); i++){\\n            curr_string += num_alpha[curr_digit][i];\\n            all_combo(curr_digit_index+1, digits, curr_string, ans,num_alpha);\\n            curr_string.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        vector<string> ans;\\n        string curr_string = \\"\\";\\n        unordered_map<char, string> num_alpha = {\\n            {\'2\', \\"abc\\"},\\n            {\'3\', \\"def\\"},\\n            {\'4\', \\"ghi\\"},\\n            {\'5\', \\"jkl\\"},\\n            {\'6\', \\"mno\\"},\\n            {\'7\', \\"pqrs\\"},\\n            {\'8\', \\"tuv\\"},\\n            {\'9\', \\"wxyz\\"}\\n        };\\n\\n        all_combo(0, digits, curr_string, ans,num_alpha);\\n\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111","title_slug":"letter-combinations-of-a-phone-number","has_notes":false,"flag_type":1,"frontend_id":480},{"id":1829600874,"question_id":22,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763125499,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1829600874/","is_pending":"Not Pending","title":"Generate Parentheses","memory":"15.6 MB","code":"class Solution {\\n    void get_all_strings(int open_count, int close_count, string curr,\\n                         vector<string>& final_ans, int n) {\\n        if (open_count + close_count == 2 * n) {\\n            final_ans.push_back(curr);\\n            return;\\n        }\\n\\n        // Add open bracket\\n        if (open_count < n)\\n            get_all_strings(open_count + 1, close_count, curr + \\"(\\", final_ans,\\n                            n);\\n\\n        if (close_count < open_count) {\\n            get_all_strings(open_count, close_count + 1, curr + \\")\\", final_ans,\\n                            n);\\n        }\\n    }\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        int open_count = 0, close_count = 0;\\n        vector<string> final_ans;\\n        string curr = \\"\\";\\n        get_all_strings(open_count, close_count, curr, final_ans, n);\\n        return final_ans;\\n    }\\n};","compare_result":"11111111","title_slug":"generate-parentheses","has_notes":false,"flag_type":1,"frontend_id":479},{"id":1829571988,"question_id":51,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0month, 3\xc2\xa0weeks","timestamp":1763122261,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1829571988/","is_pending":"Not Pending","title":"N-Queens","memory":"12 MB","code":"class Solution {\\n\\n    void can_place(int row, int col, unordered_set<int>& left_right,\\n                   unordered_set<int>& right_left, unordered_set<int>& curr_col,\\n                   int n, int queens_placed, vector<vector<string>>& final_ans,\\n                   vector<string>& curr_board) {\\n\\n        if (queens_placed == n) {\\n            final_ans.push_back(curr_board);\\n            return;\\n        }\\n        if (row >= n || col >= n) {\\n            return;\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            bool already_queen = left_right.count(row - i) ||\\n                                 right_left.count(row + i) || curr_col.count(i);\\n            if (already_queen) {\\n                continue;\\n            }\\n            curr_col.insert(i);\\n            left_right.insert(row - i);\\n            right_left.insert(row + i);\\n            curr_board[row][i] = \'Q\';\\n            can_place(row + 1, i, left_right, right_left, curr_col, n,\\n                      queens_placed + 1, final_ans, curr_board);\\n            curr_board[row][i] = \'.\';\\n            curr_col.erase(i);\\n            left_right.erase(row - i);\\n            right_left.erase(row + i);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> solveNQueens(int n) {\\n        vector<vector<string>> final_ans;\\n        string initial = \\"\\";\\n        for (int i = 0; i < n; i++)\\n            initial += \\".\\";\\n        vector<string> curr_board(n, initial);\\n\\n        unordered_set<int> curr_col;\\n        unordered_set<int> left_right;\\n        unordered_set<int> right_left;\\n        can_place(0, 0, left_right, right_left, curr_col, n, 0, final_ans,\\n                  curr_board);\\n\\n        return final_ans;\\n    }\\n};","compare_result":"111111111","title_slug":"n-queens","has_notes":false,"flag_type":1,"frontend_id":478},{"id":1824697593,"question_id":3986,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762658787,"status":10,"status_display":"Accepted","runtime":"848 ms","url":"/submissions/detail/1824697593/","is_pending":"Not Pending","title":"Maximum Path Score in a Grid","memory":"499.3 MB","code":"class Solution {\\npublic:\\n    int maxPathScore(vector<vector<int>>& grid, int k) {\\n        int curr_row = grid.size();\\n        int curr_col = grid[0].size();\\n\\n        // dp[r][c][third] = max_score to reach cell (r, c) with exactly \'third\' cost\\n        vector<vector<vector<int>>> path_scores(\\n            curr_row, vector<vector<int>>(\\n                curr_col, vector<int>(k + 1, -1)\\n            )\\n        );\\n\\n        path_scores[0][0][0] = 0;\\n\\n        for (int r = 0; r < curr_row; ++r) {\\n            for (int c = 0; c < curr_col; ++c) {\\n                \\n                int cell_val = grid[r][c];\\n                int cell_score = 0;\\n                int cell_cost = 0;\\n\\n                if (cell_val == 1) {\\n                    cell_score = 1;\\n                    cell_cost = 1;\\n                } else if (cell_val == 2) {\\n                    cell_score = 2;\\n                    cell_cost = 1;\\n                }\\n\\n                for (int third = 0; third <= k; ++third) {\\n                    \\n\\n                    if (r == 0 && c == 0) {\\n\\n                        if (third > 0) path_scores[r][c][third] = -1;\\n                        continue;\\n                    }\\n\\n                    int cost_from_prev = third - cell_cost;\\n\\n                    if (cost_from_prev < 0) {\\n                        continue;\\n                    }\\n\\n                    int score_from_up = (r > 0) ? path_scores[r - 1][c][cost_from_prev] : -1;\\n                    \\n                    int score_from_left = (c > 0) ? path_scores[r][c - 1][cost_from_prev] : -1;\\n\\n                    if (score_from_up != -1 || score_from_left != -1) {\\n                        path_scores[r][c][third] = max(score_from_up, score_from_left) + cell_score;\\n                    }\\n                }\\n            }\\n        }\\n\\n        const auto& last_cell_costs = path_scores[curr_row - 1][curr_col - 1];\\n        \\n        int max_score_at_end = *max_element(last_cell_costs.begin(), last_cell_costs.end());\\n\\n        return max_score_at_end;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-path-score-in-a-grid","has_notes":false,"flag_type":1,"frontend_id":477},{"id":1824684755,"question_id":4119,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762658217,"status":10,"status_display":"Accepted","runtime":"353 ms","url":"/submissions/detail/1824684755/","is_pending":"Not Pending","title":"Minimum Distance Between Three Equal Elements II","memory":"343.5 MB","code":"class Solution {\\npublic:\\n    int minimumDistance(vector<int>& nums) {\\n        unordered_map<int, vector<int>> freq;\\n        for (int i = 0; i < nums.size(); i++) {\\n            freq[nums[i]].push_back(i);\\n        }\\n\\n        int min_distance = INT_MAX;\\n\\n        for (auto& pair : freq) {\\n            vector<int>& index = pair.second;\\n\\n\\n            if (index.size() < 3) {\\n                continue;\\n            }\\n\\n            for (int i = 0; i <= index.size() - 3; i++) {\\n\\n                int i_val = index[i];\\n                int k_val = index[i+2];\\n\\n                int dist = 2 * (k_val - i_val);\\n\\n                min_distance = min(min_distance, dist);\\n            }\\n        }\\n\\n        return min_distance == INT_MAX ? -1 : min_distance;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-distance-between-three-equal-elements-ii","has_notes":false,"flag_type":1,"frontend_id":476},{"id":1824650675,"question_id":4115,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762656798,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1824650675/","is_pending":"Not Pending","title":"Minimum Distance Between Three Equal Elements I","memory":"28.6 MB","code":"class Solution {\\npublic:\\n    int minimumDistance(vector<int>& nums) {\\n        // unordered_map<int, vector<int>> freq;\\n\\n        // for (int i = 0; i < nums.size(); i++) {\\n        //     freq[nums[i]].push_back(i);\\n        // }\\n\\n        int min_distance = INT_MAX;\\n        int curr_distance = INT_MAX;\\n\\n        // for (auto& element : freq) {\\n        //     if (element.second.size() >= 3) {\\n        //         vector<int> nums = element.second;\\n        //         int first = element.second[0];\\n        //         int second = element.second[1];\\n        //         int third = element.second[2];\\n        //     }\\n        // }\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = i + 1; j < nums.size(); j++) {\\n                for (int k = j + 1; k < nums.size(); k++) {\\n                    if ((nums[i] == nums[j]) && (nums[j] == nums[k])) {\\n                        curr_distance = abs(i-j) +\\n                                        abs(j-k) +\\n                                        abs(i-k);\\n\\n                        min_distance = min(min_distance, curr_distance);\\n                    }\\n                }\\n            }\\n        }\\n        return min_distance == INT_MAX ? -1 : min_distance;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-distance-between-three-equal-elements-i","has_notes":false,"flag_type":1,"frontend_id":475},{"id":1824626197,"question_id":4115,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762655887,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1824626197/","is_pending":"Not Pending","title":"Minimum Distance Between Three Equal Elements I","memory":"N/A","code":"class Solution {\\npublic:\\n    int minimumDistance(vector<int>& nums) {\\n        unordered_map<int,vector<int>>freq;\\n\\n        for(int i=0; i<nums.size();i++){\\n            freq[nums[i]].push_back(i);\\n        }\\n\\n        int min_distance = INT_MAX;\\n        int curr_distance = 0;\\n\\n        for(auto &element: freq){\\n            if(element.second.size() >= 3){\\n                int first = element.second[0];\\n                int second = element.second[1];\\n                int third = element.second[2];\\n                curr_distance = abs(first-second) + abs(second-third) + abs(first - third);\\n                min_distance = min(min_distance,curr_distance);\\n            }\\n            \\n        }\\n        return min_distance == INT_MAX ? -1 : min_distance;\\n    \\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111110111111110111110111111111111111111111111111111111111111111111111111111111110111110111111111011111111110011111110111111111111111111111111111111110011010100011101010111111011010111010111111111111111111111111111111111111111111111111100101111111101001001010110111011110111111111111111111111111111111111111011111111110111101001110001110111110001111011111111111011111111111111111111111101111111110010101111101101001010111111111111110001101110010110111111111111111111111110111111111111111111111111011111011111111100011111110001110110001111010001101101111010110110111001001010101110110100010111111111","title_slug":"minimum-distance-between-three-equal-elements-i","has_notes":false,"flag_type":1,"frontend_id":474},{"id":1824247292,"question_id":4098,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762616378,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1824247292/","is_pending":"Not Pending","title":"Longest Non-Decreasing Subarray After Replacing at Most One Element","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        if(nums.size() <= 1)return nums.size();\\n\\n        vector<int>dp0(nums.size(),1);\\n\\n        int dp1_curr = 1;\\n        int max_length = 1;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            int dp1_next = 1;\\n            if(nums[i] >= nums[i-1]){\\n                dp0[i] = dp0[i-1]+1;\\n            } else {\\n                dp0[i]=1;\\n            }\\n            int case1  = 1;\\n            if(nums[i] >= nums[i-1]){\\n                case1 = dp1_curr +1;\\n            }\\n            int case2 = dp0[i-1]+1;\\n\\n            int case3 = 1;\\n            if(i==1){\\n                case3 = 2;\\n            }else if(nums[i] >= nums[i-2]){\\n                case3 = dp0[i-2]+2;\\n            }\\n            max_length = max({max_length,case1,case2,case3});\\n        }\\n        return max_length;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111101111011111111111111111110101011111111001011111101101111110111111101011101101110101000111001010011101011010011111010111110111111011100101100010111111111101011011111000010111110011000011101111100111110111111101110001001011111111110100111111101000001010011000110101010100110111111100011100100110110100011110000011011110111111011010000110110010011101101111100111111000110010111001100001000001111100001010111000111110111001010111101001110000100010011001011110100100101101111110101101110101111111111111111","title_slug":"longest-non-decreasing-subarray-after-replacing-at-most-one-element","has_notes":false,"flag_type":1,"frontend_id":473},{"id":1824209999,"question_id":4075,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762614965,"status":10,"status_display":"Accepted","runtime":"75 ms","url":"/submissions/detail/1824209999/","is_pending":"Not Pending","title":"Count Subarrays With Majority Element II","memory":"121.1 MB","code":"class Solution {\\npublic:\\n    long long countMajoritySubarrays(vector<int>& nums, int target) {\\n        long long count = 0;\\n        long long balance = 0;\\n        long long valid_here = 0;\\n        unordered_map<long long,int>freq;\\n\\n        freq[0] = 1;\\n\\n        for(auto &element:nums){\\n            if(element == target){\\n                // here valid\\n                balance++;\\n                valid_here += freq[balance-1];\\n            }else{\\n                // not valid\\n                balance--;\\n                valid_here -= freq[balance];\\n            }\\n            count+=valid_here;\\n            freq[balance]++;\\n            \\n        }\\n        return count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-subarrays-with-majority-element-ii","has_notes":false,"flag_type":1,"frontend_id":472},{"id":1824153269,"question_id":4074,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762613140,"status":10,"status_display":"Accepted","runtime":"2532 ms","url":"/submissions/detail/1824153269/","is_pending":"Not Pending","title":"Count Subarrays With Majority Element I","memory":"494.2 MB","code":"class Solution {\\npublic:\\n    int countMajoritySubarrays(vector<int>& nums, int target) {\\n        int count = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            unordered_map<int,int>freq;\\n            for(int j=i; j<nums.size(); j++){\\n                freq[nums[j]]++;\\n                if(freq[target] > ((j-i+1)/2)){\\n                    count++;\\n                }\\n            }\\n            \\n            \\n        }\\n        return count;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-subarrays-with-majority-element-i","has_notes":false,"flag_type":1,"frontend_id":471}],"has_next":true,"last_key":""}'
2026-01-10 09:23:04,443 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:04,445 [INFO] __main__.py:245 - Writing total-waviness-of-numbers-in-range-i/2025-11-22 20.25.02 - Accepted - runtime 443ms - memory 118.9MB.cpp
2026-01-10 09:23:04,446 [INFO] __main__.py:188 - Skipping total-waviness-of-numbers-in-range-i 2025-11-22 20.21.09 because its status is 'Wrong Answer'
2026-01-10 09:23:06,193 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:06,196 [INFO] __main__.py:245 - Writing minimum-number-of-flips-to-reverse-binary-string/2025-11-22 20.10.09 - Accepted - runtime 3ms - memory 9.7MB.cpp
2026-01-10 09:23:06,566 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:06,568 [INFO] __main__.py:245 - Writing palindrome-partitioning/2025-11-22 08.25.14 - Accepted - runtime 59ms - memory 61.6MB.cpp
2026-01-10 09:23:07,579 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:07,581 [INFO] __main__.py:245 - Writing count-stable-subarrays/2025-11-16 09.07.49 - Accepted - runtime 272ms - memory 269.5MB.cpp
2026-01-10 09:23:08,714 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:08,715 [INFO] __main__.py:245 - Writing count-distinct-integers-after-removing-zeros/2025-11-16 08.49.39 - Accepted - runtime 0ms - memory 9.3MB.cpp
2026-01-10 09:23:08,716 [INFO] __main__.py:188 - Skipping count-distinct-integers-after-removing-zeros 2025-11-16 08.42.04 because its status is 'Time Limit Exceeded'
2026-01-10 09:23:09,998 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:10,000 [INFO] __main__.py:245 - Writing minimum-string-length-after-balanced-removals/2025-11-16 08.22.40 - Accepted - runtime 8ms - memory 15.4MB.cpp
2026-01-10 09:23:10,000 [INFO] __main__.py:188 - Skipping minimum-string-length-after-balanced-removals 2025-11-16 08.10.54 because its status is 'Wrong Answer'
2026-01-10 09:23:10,412 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:10,412 [INFO] __main__.py:245 - Writing maximize-expression-of-three-elements/2025-11-16 08.03.25 - Accepted - runtime 0ms - memory 31.2MB.cpp
2026-01-10 09:23:11,129 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:11,131 [INFO] __main__.py:245 - Writing letter-combinations-of-a-phone-number/2025-11-14 19.37.47 - Accepted - runtime 0ms - memory 9.7MB.cpp
2026-01-10 09:23:11,440 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:11,443 [INFO] __main__.py:245 - Writing generate-parentheses/2025-11-14 18.34.59 - Accepted - runtime 2ms - memory 15.6MB.cpp
2026-01-10 09:23:12,540 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:12,542 [INFO] __main__.py:245 - Writing n-queens/2025-11-14 17.41.01 - Accepted - runtime 11ms - memory 12MB.cpp
2026-01-10 09:23:13,076 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:13,077 [INFO] __main__.py:245 - Writing maximum-path-score-in-a-grid/2025-11-09 08.56.27 - Accepted - runtime 848ms - memory 499.3MB.cpp
2026-01-10 09:23:13,552 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:13,554 [INFO] __main__.py:245 - Writing minimum-distance-between-three-equal-elements-ii/2025-11-09 08.46.57 - Accepted - runtime 353ms - memory 343.5MB.cpp
2026-01-10 09:23:14,716 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:14,717 [INFO] __main__.py:245 - Writing minimum-distance-between-three-equal-elements-i/2025-11-09 08.23.18 - Accepted - runtime 6ms - memory 28.6MB.cpp
2026-01-10 09:23:14,717 [INFO] __main__.py:188 - Skipping minimum-distance-between-three-equal-elements-i 2025-11-09 08.08.07 because its status is 'Wrong Answer'
2026-01-10 09:23:14,718 [INFO] __main__.py:188 - Skipping longest-non-decreasing-subarray-after-replacing-at-most-one-element 2025-11-08 21.09.38 because its status is 'Wrong Answer'
2026-01-10 09:23:15,720 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:15,721 [INFO] __main__.py:245 - Writing count-subarrays-with-majority-element-ii/2025-11-08 20.46.05 - Accepted - runtime 75ms - memory 121.1MB.cpp
2026-01-10 09:23:16,720 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:16,721 [INFO] __main__.py:245 - Writing count-subarrays-with-majority-element-i/2025-11-08 20.15.40 - Accepted - runtime 2532ms - memory 494.2MB.cpp
2026-01-10 09:23:21,724 [DEBUG] leetcode.py:150 - Exporting submissions from 80 to 100
2026-01-10 09:23:23,624 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=80&limit=20 HTTP/1.1" 200 None
2026-01-10 09:23:23,626 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1824126136,"question_id":4116,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762612431,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1824126136/","is_pending":"Not Pending","title":"Minimum Moves to Equal Array Elements III","memory":"31.5 MB","code":"class Solution {\\npublic:\\n    int minMoves(vector<int>& nums) {\\n        if(nums.size()==1)return 0;\\n       int ans = 0;\\n        int maxi = *max_element(nums.begin(),nums.end());\\n\\n        for(auto& element:nums){\\n            ans += abs(element - maxi);\\n        }\\n\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-moves-to-equal-array-elements-iii","has_notes":false,"flag_type":1,"frontend_id":470},{"id":1823848434,"question_id":79,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762584910,"status":10,"status_display":"Accepted","runtime":"1070 ms","url":"/submissions/detail/1823848434/","is_pending":"Not Pending","title":"Word Search","memory":"11.8 MB","code":"class Solution {\\n    bool find_word(vector<vector<char>>& board, string word,\\n                   vector<vector<bool>>& visited, int row, int col, int index) {\\n\\n        if (index == word.size())\\n            return true;\\n        if (row < 0 || row >= board.size() || col < 0 ||\\n            col >= board[0].size()) {\\n            return false;\\n        }\\n        if (word[index] != board[row][col])\\n            return false;\\n        if (visited[row][col])\\n            return false;\\n\\n        visited[row][col] = true;\\n        bool left = find_word(board, word, visited, row - 1, col, index + 1);\\n        bool top = find_word(board, word, visited, row, col - 1, index + 1);\\n        bool right = find_word(board, word, visited, row + 1, col, index + 1);\\n        bool down = find_word(board, word, visited, row, col + 1, index + 1);\\n        visited[row][col] = false;\\n\\n        return left || top || right || down;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<bool>> visited(board.size(),\\n                                     vector<bool>(board[0].size(), 0));\\n        bool word_exists = false;\\n        // Anywhere from the grid\\n        for (int i = 0; i < board.size(); i++)\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if(board[i][j] != word[0] )continue;\\n                word_exists = find_word(board, word, visited, i, j, 0);\\n                if(word_exists)return true;\\n            }\\n        return word_exists;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"word-search","has_notes":false,"flag_type":1,"frontend_id":469},{"id":1823846895,"question_id":79,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762584769,"status":10,"status_display":"Accepted","runtime":"1047 ms","url":"/submissions/detail/1823846895/","is_pending":"Not Pending","title":"Word Search","memory":"11.7 MB","code":"class Solution {\\n    bool find_word(vector<vector<char>>& board, string word,\\n                   vector<vector<bool>>& visited, int row, int col, int index) {\\n\\n        if (index == word.size())\\n            return true;\\n        if (row < 0 || row >= board.size() || col < 0 ||\\n            col >= board[0].size()) {\\n            return false;\\n        }\\n        if (word[index] != board[row][col])\\n            return false;\\n        if (visited[row][col])\\n            return false;\\n\\n        visited[row][col] = true;\\n        bool left = find_word(board, word, visited, row - 1, col, index + 1);\\n        bool top = find_word(board, word, visited, row, col - 1, index + 1);\\n        bool right = find_word(board, word, visited, row + 1, col, index + 1);\\n        bool down = find_word(board, word, visited, row, col + 1, index + 1);\\n        visited[row][col] = false;\\n\\n        return left || top || right || down;\\n    }\\n\\npublic:\\n    bool exist(vector<vector<char>>& board, string word) {\\n        vector<vector<bool>> visited(board.size(),\\n                                     vector<bool>(board[0].size(), 0));\\n        bool word_exists = false;\\n        // Anywhere from the grid\\n        for (int i = 0; i < board.size(); i++)\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if(board[i][j] != word[0] )continue;\\n                word_exists = word_exists || find_word(board, word, visited, i, j, 0);\\n            }\\n        return word_exists;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"word-search","has_notes":false,"flag_type":1,"frontend_id":468},{"id":1823776199,"question_id":47,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762578121,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1823776199/","is_pending":"Not Pending","title":"Permutations II","memory":"11.4 MB","code":"class Solution {\\n    void solve_permutations(vector<int>& nums,\\n                            vector<vector<int>>& final_permutations,\\n                            vector<bool>& visited,\\n                            vector<int>& current_permutations) {\\n\\n        if (current_permutations.size() == nums.size()) {\\n            final_permutations.push_back(current_permutations);\\n            return;\\n        }\\n\\n        // Do For Each Slot\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) {\\n                // Duplicate Logic ==> Take the first element of duplicates\\n                // !visited[i-1] -> if earlier is not picked then this means\\n                // this is a duplicate path\\n                continue;\\n            }\\n            if (visited[i]) // Already Visited Slot\\n                continue;\\n            current_permutations.push_back(nums[i]);\\n            visited[i] = true;\\n            solve_permutations(nums, final_permutations, visited,\\n                               current_permutations);\\n            current_permutations.pop_back();\\n            visited[i] = false;\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\\n        vector<vector<int>> final_permutations;\\n        vector<bool> visited(nums.size(), 0);\\n        vector<int> current_permutations;\\n\\n        sort(nums.begin(), nums.end());\\n        solve_permutations(nums, final_permutations, visited,\\n                           current_permutations);\\n\\n        return final_permutations;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"permutations-ii","has_notes":null,"flag_type":1,"frontend_id":467},{"id":1823721976,"question_id":46,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762570339,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1823721976/","is_pending":"Not Pending","title":"Permutations","memory":"10.5 MB","code":"class Solution {\\n    void calculate_permutations(vector<int>&nums,vector<vector<int>>&final_permutations,vector<int>&current_permutations,vector<bool>&visited){\\n        if(current_permutations.size() == nums.size()){\\n            final_permutations.push_back(current_permutations);\\n            return;\\n        }\\n\\n        for(int i=0; i<nums.size(); i++){\\n            // Because Every slot must have all numbers at least once\\n            if(visited[i])continue; // which slots filled\\n            current_permutations.push_back(nums[i]);\\n            visited[i] = true;\\n            calculate_permutations(nums,final_permutations,current_permutations,visited);\\n            current_permutations.pop_back();\\n            visited[i] = false;\\n\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        vector<vector<int>>final_permutations;\\n        vector<int>current_permutations;\\n        vector<bool>visited(nums.size(),0);\\n\\n        calculate_permutations(nums,final_permutations,current_permutations,visited);\\n\\n        return final_permutations;\\n\\n\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"permutations","has_notes":null,"flag_type":1,"frontend_id":466},{"id":1822932744,"question_id":40,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762484634,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1822932744/","is_pending":"Not Pending","title":"Combination Sum II","memory":"14.2 MB","code":"class Solution {\\n    void find_combination_candidates(vector<int>&candidates,int target,int index,int current_sum,vector<int>&current_candidates,vector<vector<int>>&final_ans){\\n\\n        if(current_sum == target){\\n            final_ans.push_back(current_candidates);\\n            return;\\n        }else if(current_sum > target){\\n            return;\\n        }\\n        if(index >= candidates.size()){\\n            return;\\n        }\\n\\n        // pick\\n        current_candidates.push_back(candidates[index]);\\n        find_combination_candidates(candidates,target,index+1,current_sum + candidates[index],current_candidates,final_ans);\\n        current_candidates.pop_back();\\n\\n        // Skip Duplicates\\n        while(index < candidates.size()-1 && candidates[index] == candidates[index+1]){\\n            index++;\\n        }\\n\\n        // not pick\\n        find_combination_candidates(candidates,target,index+1,current_sum,current_candidates,final_ans);\\n\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>>final_ans;\\n        vector<int>current_candidates;\\n\\n        sort(candidates.begin(),candidates.end());\\n\\n        find_combination_candidates(candidates,target,0,0,current_candidates,final_ans);\\n\\n        return final_ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum-ii","has_notes":false,"flag_type":1,"frontend_id":465},{"id":1821288684,"question_id":39,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762330088,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1821288684/","is_pending":"Not Pending","title":"Combination Sum","memory":"14 MB","code":"class Solution {\\n    void find_target_sum(vector<int>& candidates, int index, int target,\\n                         int current_sum, vector<int>& current_sum_arr,\\n                         vector<vector<int>> &final_ans) {\\n        if (index >= candidates.size()) {\\n            return;\\n        }\\n        if (current_sum == target) {\\n            final_ans.push_back(current_sum_arr);\\n            return;\\n        } else if (current_sum > target) {\\n            return;\\n        }\\n\\n        // pick\\n        // Pass index for Re-Pick\\n        current_sum_arr.push_back(candidates[index]);\\n        find_target_sum(candidates, index, target,\\n                        current_sum + candidates[index], current_sum_arr,\\n                        final_ans);\\n        current_sum_arr.pop_back();\\n\\n        // not pick\\n        find_target_sum(candidates, index+1, target,\\n                        current_sum, current_sum_arr,\\n                        final_ans);\\n    }\\n\\npublic:\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> final_ans;\\n        vector<int> current_sum_arr;\\n        int current_sum = 0;\\n        find_target_sum(candidates, 0, target, current_sum, current_sum_arr,\\n                        final_ans);\\n\\n        return final_ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"combination-sum","has_notes":false,"flag_type":1,"frontend_id":464},{"id":1820402445,"question_id":90,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762250412,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1820402445/","is_pending":"Not Pending","title":"Subsets II","memory":"16.2 MB","code":"class Solution {\\n    void calculate_subsets(vector<int>nums,int index,vector<vector<int>>&final_ans, vector<int>&current_subset){\\n        if(index >= nums.size()){\\n            final_ans.push_back(current_subset);\\n            return;\\n        }\\n\\n        // pick\\n        current_subset.push_back(nums[index]);\\n        calculate_subsets(nums,index+1,final_ans,current_subset);\\n        current_subset.pop_back();\\n\\n        // skip duplicates\\n        while(index < nums.size()-1 && nums[index+1] == nums[index]){\\n            index++;\\n        }\\n        // not pick\\n        calculate_subsets(nums,index+1,final_ans,current_subset); \\n    }\\npublic:\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\\n        vector<vector<int>>final_ans;\\n        sort(nums.begin(),nums.end());\\n        vector<int>current_subset;\\n        calculate_subsets(nums,0,final_ans,current_subset);\\n        return final_ans;\\n    }\\n};","compare_result":"11111111111111111111","title_slug":"subsets-ii","has_notes":false,"flag_type":1,"frontend_id":463},{"id":1820375474,"question_id":78,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762247960,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1820375474/","is_pending":"Not Pending","title":"Subsets","memory":"12.8 MB","code":"class Solution {\\n    void calculate_subsets(int index, vector<int>& nums,\\n                           vector<vector<int>>& final_ans,\\n                           vector<int> &current_subset) {\\n        // Base Case\\n        if (index >= nums.size()) {\\n            final_ans.push_back(current_subset);\\n            return;\\n        }\\n\\n        // not pick\\n        calculate_subsets(index + 1,nums, final_ans, current_subset);\\n        // pick\\n        current_subset.push_back(nums[index]);\\n        calculate_subsets(index + 1,nums, final_ans,current_subset);\\n        current_subset.pop_back();\\n    }\\n\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> final_ans;\\n        vector<int> current_subset;\\n        calculate_subsets(0, nums, final_ans, current_subset);\\n\\n        return final_ans;\\n    }\\n};","compare_result":"1111111111","title_slug":"subsets","has_notes":false,"flag_type":1,"frontend_id":462},{"id":1820362166,"question_id":78,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762246684,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1820362166/","is_pending":"Not Pending","title":"Subsets","memory":"12.8 MB","code":"class Solution {\\n    void calculate_subsets(int index, vector<int>& nums,\\n                           vector<vector<int>>& final_ans,\\n                           vector<int> &current_subset) {\\n        // Base Case\\n        if (index >= nums.size()) {\\n            final_ans.push_back(current_subset);\\n            return;\\n        }\\n\\n        // not pick\\n        calculate_subsets(index + 1,nums, final_ans, current_subset);\\n        // pick\\n        current_subset.push_back(nums[index]);\\n        calculate_subsets(index + 1,nums, final_ans,current_subset);\\n        current_subset.pop_back();\\n    }\\n\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> final_ans;\\n        vector<int> current_subset;\\n        calculate_subsets(0, nums, final_ans, current_subset);\\n\\n        return final_ans;\\n    }\\n};","compare_result":"1111111111","title_slug":"subsets","has_notes":false,"flag_type":1,"frontend_id":461},{"id":1820241655,"question_id":735,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762235920,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1820241655/","is_pending":"Not Pending","title":"Asteroid Collision","memory":"22.1 MB","code":"class Solution {\\npublic:\\n    vector<int> asteroidCollision(vector<int>& asteroids) {\\n        stack<int> surviving_asteroids_stack;\\n\\n        for(int i=0; i<asteroids.size();i++){\\n            // Only condition because there is collision \\n            // if already present asteroid Left->right(+) and new_asteroid Left<-Right(-)\\n            bool asteroid_survives = true;\\n            while(!surviving_asteroids_stack.empty() && asteroids[i] < 0 && surviving_asteroids_stack.top() > 0){\\n                if(abs(asteroids[i]) == abs(surviving_asteroids_stack.top())){\\n                    // both explode\\n                    surviving_asteroids_stack.pop();\\n                    asteroid_survives = false;\\n                }else if(abs(asteroids[i]) < abs(surviving_asteroids_stack.top())){\\n                    // new asteroid explode\\n                    asteroid_survives = false;\\n                }else{\\n                    // old asteroid explode\\n                    surviving_asteroids_stack.pop();\\n                }\\n                if(!asteroid_survives)break;\\n            }\\n            if(asteroid_survives){\\n                surviving_asteroids_stack.push(asteroids[i]);\\n            }\\n        }\\n        vector<int>ans;\\n        while(!surviving_asteroids_stack.empty()){\\n            ans.push_back(surviving_asteroids_stack.top());\\n            surviving_asteroids_stack.pop();\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"asteroid-collision","has_notes":false,"flag_type":1,"frontend_id":460},{"id":1820203436,"question_id":224,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762232825,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1820203436/","is_pending":"Not Pending","title":"Basic Calculator","memory":"12.6 MB","code":"class Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<long long> result_sign_stack;\\n        long long current_result = 0, current_number = 0, current_sign = 1;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \' \')\\n                continue;\\n\\n            if (s[i] - \'0\' >= 0 && s[i] - \'0\' <= 9) {\\n                // Number or multi-digit number\\n                current_number = current_number * 10 + (s[i] - \'0\');\\n            } else if (s[i] == \'(\') {\\n                current_result += (current_sign * current_number);\\n                result_sign_stack.push(current_result);\\n                result_sign_stack.push(current_sign);\\n                current_result = 0, current_number = 0, current_sign = 1;\\n            } else if (s[i] == \')\') {\\n                current_result += current_sign * current_number;\\n                current_number = 0;\\n                int prev_sign = result_sign_stack.top();\\n                result_sign_stack.pop();\\n                long long prev_result = result_sign_stack.top();\\n                result_sign_stack.pop();\\n\\n                current_result = prev_result + (prev_sign * current_result);\\n            } else {\\n                // Sign\\n                current_result += (current_sign * current_number);\\n                current_number = 0;\\n                if (s[i] == \'+\') {\\n                    current_sign = 1;\\n                } else if (s[i] == \'-\') {\\n                    current_sign = -1;\\n                }\\n            }\\n        }\\n\\n        current_result = current_result + (current_sign * current_number);\\n\\n        return current_result;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111","title_slug":"basic-calculator","has_notes":false,"flag_type":1,"frontend_id":459},{"id":1820187755,"question_id":224,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762231488,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1820187755/","is_pending":"Not Pending","title":"Basic Calculator","memory":"N/A","code":"class Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<long long> result_sign_stack;\\n        long long current_result = 0, current_sign = 1;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \' \')\\n                continue;\\n\\n            if(i!=0 && s[i]-\'0\' >=0 && s[i] - \'0\' <=9 && s[i-1]-\'0\' >=0 && s[i-1] - \'0\' <=9){\\n                current_result = current_result * 10 + (current_sign * (s[i] - \'0\') );\\n                continue;\\n            }\\n\\n            if (s[i] - \'0\' >= 0 && s[i] - \'0\' <= 9) {\\n                // Number\\n                current_result += (current_sign * (s[i] - \'0\'));\\n            } else if (s[i] == \'(\') {\\n                result_sign_stack.push(current_result);\\n                result_sign_stack.push(current_sign);\\n                current_result = 0, current_sign = 1;\\n            } else if (s[i] == \')\') {\\n                int prev_sign = result_sign_stack.top();\\n                result_sign_stack.pop();\\n                long long prev_result = result_sign_stack.top();\\n                result_sign_stack.pop();\\n\\n                long long new_result = prev_result + (prev_sign * current_result);\\n                current_result = new_result;\\n            } else {\\n                // Sign\\n                if (s[i] == \'+\') {\\n                    current_sign = 1;\\n                } else if (s[i] == \'-\') {\\n                    current_sign = -1;\\n                }\\n            }\\n        }\\n        return current_result;\\n    }\\n};","compare_result":"111111111111111101111111111111110110000000000000","title_slug":"basic-calculator","has_notes":false,"flag_type":1,"frontend_id":458},{"id":1820183506,"question_id":224,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762231118,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1820183506/","is_pending":"Not Pending","title":"Basic Calculator","memory":"N/A","code":"class Solution {\\npublic:\\n    int calculate(string s) {\\n        stack<int> result_sign_stack;\\n        int current_result = 0, current_sign = 1;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \' \')\\n                continue;\\n\\n            if (s[i] - \'0\' >= 0 && s[i] - \'0\' <= 9) {\\n                // Number\\n                current_result += (current_sign * (s[i] - \'0\'));\\n            } else if (s[i] == \'(\') {\\n                result_sign_stack.push(current_result);\\n                result_sign_stack.push(current_sign);\\n                current_result = 0, current_sign = 1;\\n            } else if (s[i] == \')\') {\\n                int prev_sign = result_sign_stack.top();\\n                result_sign_stack.pop();\\n                int prev_result = result_sign_stack.top();\\n                result_sign_stack.pop();\\n\\n                int new_result = prev_result + (prev_sign * current_result);\\n                current_result = new_result;\\n            } else {\\n                // Sign\\n                if (s[i] == \'+\') {\\n                    current_sign = 1;\\n                } else if (s[i] == \'-\') {\\n                    current_sign = -1;\\n                }\\n            }\\n        }\\n        if (!result_sign_stack.empty()) {\\n            int prev_sign = result_sign_stack.top();\\n            result_sign_stack.pop();\\n            int prev_result = result_sign_stack.top();\\n            result_sign_stack.pop();\\n\\n            int new_result = prev_result + (prev_sign * current_result);\\n            current_result = new_result;\\n        }\\n        return current_result;\\n    }\\n};","compare_result":"111111001011111101111011111111110110000011110110","title_slug":"basic-calculator","has_notes":false,"flag_type":1,"frontend_id":457},{"id":1819536598,"question_id":394,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months","timestamp":1762173940,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1819536598/","is_pending":"Not Pending","title":"Decode String","memory":"9.5 MB","code":"class Solution {\\npublic:\\n    string decodeString(string s) {\\n        int current_number = 0;\\n        string current_string = \\"\\";\\n\\n        stack<int> count_stack;\\n        stack<string> string_stack;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] - \'0\' >= 0 && s[i] - \'0\' <= 9) {\\n                current_number = (current_number * 10 )+ (s[i]-\'0\');\\n                continue;\\n            }\\n            else if(s[i] == \'[\'){\\n                count_stack.push(current_number);\\n                string_stack.push(current_string);\\n                current_number=0;current_string=\\"\\";\\n            }\\n            else if(s[i]==\']\'){\\n                int repeat = count_stack.top();\\n                count_stack.pop();\\n                string prev_string = string_stack.top();\\n                string_stack.pop();\\n                string new_current_string = prev_string;\\n\\n                for(int i=0; i<repeat;i++){\\n                    new_current_string+=current_string;\\n                }   \\n                current_string = new_current_string;\\n            }else{\\n                current_string += s[i];\\n            }\\n        }\\n        return current_string;\\n    }\\n};","compare_result":"1111111111111111111111111111111111","title_slug":"decode-string","has_notes":false,"flag_type":1,"frontend_id":456},{"id":1818270428,"question_id":4048,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1762055422,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1818270428/","is_pending":"Not Pending","title":"Minimum Time to Complete All Deliveries","memory":"52.6 MB","code":"class Solution {\\n    long long gcd(long long a, long long b) {\\n    while (b) {\\n        a %= b;\\n        swap(a, b);\\n    }\\n    return a;\\n}\\n\\nlong long lcm(long long a, long long b) {\\n    if (a == 0 || b == 0) return 0;\\n    return (a / gcd(a, b)) * b;\\n}\\npublic:\\n    long long minimumTime(vector<int>& d, vector<int>& r) {\\n        vector<vector<int>> arr = {d, r};\\n\\n        long long d1 = arr[0][0];\\n        long long d2 = arr[0][1], r1 = arr[1][0], r2 = arr[1][1];\\n\\n        long long low = d1 + d2;\\n        long long high = 4000000000LL; \\n        long long ans = high;\\n\\n        while (low <= high) {\\n            long long total = low + (high - low) / 2;\\n            long long l = lcm(r1, r2);\\n\\n            long long d1_drone = (total / r2) - (total / l);\\n            long long d2_drone = (total / r1) - (total / l);\\n            long long both_drone = total - (total / r1) - (total / r2) + (total / l);\\n\\n            bool can_d1 = (d1 <= d1_drone + both_drone);\\n            bool can_d2 = (d2 <= d2_drone + both_drone);\\n            bool can_total = ((d1 + d2) <= (d1_drone + d2_drone + both_drone));\\n\\n            if (can_d1 && can_d2 && can_total) {\\n                ans = total;      \\n                high = total - 1; \\n            } else {\\n                low = total + 1;  \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-time-to-complete-all-deliveries","has_notes":false,"flag_type":1,"frontend_id":455},{"id":1818247934,"question_id":4048,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1762054283,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1818247934/","is_pending":"Not Pending","title":"Minimum Time to Complete All Deliveries","memory":"N/A","code":"class Solution {\\npublic:\\n    long long minimumTime(vector<int>& d, vector<int>& r) {\\n        long long d1 = d[0], d2 = d[1];\\n        long long r1 = r[0], r2 = r[1];\\n        long long current = 1;\\n        long long min_time = 0;\\n        while(d1 > 0 && d2 > 0 ){\\n            if(current%r1!=0  && current%r2!=0 ){\\n                d1--;\\n            }else if(current%r1==0  && current%r2!=0 ){\\n                d2--;\\n            }else if(current%r1!=0 && current%r2==0){\\n                d1--;\\n            }\\n            current++;\\n            min_time++;\\n        }\\n\\n        while(d1 > 0){\\n            if(current%r1!=0 ){\\n                d1--;\\n            }\\n            current++;\\n            min_time++;\\n        }\\n        while(d2 > 0){\\n            if(current%r2!=0 ){\\n                d2--;\\n            }\\n            current++;\\n            min_time++;\\n        }\\n        return min_time;\\n    }\\n};","compare_result":"111111110111101111011110111110111011110011100111001111011101011001110001100011101010100100101000110000110101010010010000010000011111111111101111011110111111110101110111000110001111101010010010100011000011110101001001000001000001111010100100100000100000111111111111111101011010111111111101011010101101001111111110100100000100100111111011010010000010010011011101001001000001000001111111111101111111111110111111111110011000110111011111101111001100011001101101110101100110000100000110111010110011000010000011111111111111111111111111111110111111111111110111111111010110111101011000111111101011001110001100011111110100100101000110000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"minimum-time-to-complete-all-deliveries","has_notes":false,"flag_type":1,"frontend_id":454},{"id":1818221740,"question_id":4101,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1762053023,"status":10,"status_display":"Accepted","runtime":"43 ms","url":"/submissions/detail/1818221740/","is_pending":"Not Pending","title":"Maximum Product of Three Elements After One Replacement","memory":"124.4 MB","code":"class Solution {\\npublic:\\n    long long maxProduct(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max1 = 0, max2 = 0, min = 0;\\n        // case 1\\n        int size = nums.size();\\n        long long product1 = (long long)nums[size-1] * nums[size-2];\\n        long long product2 = (long long)nums[0] * nums[1];\\n        long long max_product = (long long)INT_MIN;\\n        int index1=0,index2=0;\\n        if(abs(product1) > abs(product2)){\\n            max_product = product1;\\n            index1 = size-1;\\n            index2 = size-2;\\n        }else{\\n            max_product = product2;\\n            index1 = 0;\\n            index2 = 1;\\n        }\\n\\n        int i=0,j=size-1;\\n        while(i<j){\\n            if(abs((long long)nums[i] * nums[j]) > abs(max_product)){\\n                index1 = i;\\n                index2 = j;\\n                max_product = (long long)nums[i]*nums[j];\\n            }\\n            if(nums[i] < nums[j]){\\n                i++;\\n            }else{\\n                j--;\\n            }\\n        }\\n\\n        if(max_product < 0){\\n            return (long long)max_product * -1e5;\\n        }else{\\n            return (long long)max_product * 1e5;\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-of-three-elements-after-one-replacement","has_notes":false,"flag_type":1,"frontend_id":453},{"id":1818213685,"question_id":4101,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1762052641,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1818213685/","is_pending":"Not Pending","title":"Maximum Product of Three Elements After One Replacement","memory":"N/A","code":"class Solution {\\npublic:\\n    long long maxProduct(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max1 = 0, max2 = 0, min = 0;\\n        // case 1\\n        int size = nums.size();\\n        long long product1 = nums[size-1] * nums[size-2];\\n        long long product2 = nums[0] * nums[1];\\n        long long max_product = INT_MIN;\\n        int index1=0,index2=0;\\n        if(abs(product1) > abs(product2)){\\n            max_product = product1;\\n            index1 = size-1;\\n            index2 = size-2;\\n        }else{\\n            max_product = product2;\\n            index1 = 0;\\n            index2 = 1;\\n        }\\n\\n        int i=0,j=size-1;\\n        while(i<j){\\n            if(abs(nums[i] * nums[j]) > abs(max_product)){\\n                index1 = i;\\n                index2 = j;\\n                max_product = nums[i]*nums[j];\\n            }\\n            if(nums[i] < nums[j]){\\n                i++;\\n            }else{\\n                j--;\\n            }\\n        }\\n\\n        if(max_product < 0){\\n            return max_product * -1e5;\\n        }else{\\n            return max_product * 1e5;\\n        }\\n    }\\n};","compare_result":"11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"maximum-product-of-three-elements-after-one-replacement","has_notes":false,"flag_type":1,"frontend_id":452},{"id":1818175910,"question_id":4107,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1762051081,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1818175910/","is_pending":"Not Pending","title":"Find Missing Elements","memory":"32.3 MB","code":"class Solution {\\npublic:\\n    vector<int> findMissingElements(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int start = nums[0];\\n        int end = nums[nums.size()-1];\\n        int current = 1;\\n        vector<int>ans;\\n        for(int i=start+1;i<end;i++){\\n            auto found = find(nums.begin(),nums.end(),i);\\n            if(found == nums.end()){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-missing-elements","has_notes":false,"flag_type":1,"frontend_id":451}],"has_next":true,"last_key":""}'
2026-01-10 09:23:24,674 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:24,676 [INFO] __main__.py:245 - Writing minimum-moves-to-equal-array-elements-iii/2025-11-08 20.03.51 - Accepted - runtime 0ms - memory 31.5MB.cpp
2026-01-10 09:23:26,085 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:26,086 [INFO] __main__.py:245 - Writing word-search/2025-11-08 12.25.10 - Accepted - runtime 1070ms - memory 11.8MB.cpp
2026-01-10 09:23:26,086 [INFO] __main__.py:245 - Writing word-search/2025-11-08 12.22.49 - Accepted - runtime 1047ms - memory 11.7MB.cpp
2026-01-10 09:23:26,796 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:26,798 [INFO] __main__.py:245 - Writing permutations-ii/2025-11-08 10.32.01 - Accepted - runtime 0ms - memory 11.4MB.cpp
2026-01-10 09:23:28,853 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:28,854 [INFO] __main__.py:245 - Writing permutations/2025-11-08 08.22.19 - Accepted - runtime 0ms - memory 10.5MB.cpp
2026-01-10 09:23:30,208 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:30,208 [INFO] __main__.py:245 - Writing combination-sum-ii/2025-11-07 08.33.54 - Accepted - runtime 3ms - memory 14.2MB.cpp
2026-01-10 09:23:30,513 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:30,514 [INFO] __main__.py:245 - Writing combination-sum/2025-11-05 13.38.08 - Accepted - runtime 0ms - memory 14MB.cpp
2026-01-10 09:23:30,813 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:30,814 [INFO] __main__.py:245 - Writing subsets-ii/2025-11-04 15.30.12 - Accepted - runtime 0ms - memory 16.2MB.cpp
2026-01-10 09:23:31,560 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:31,561 [INFO] __main__.py:245 - Writing subsets/2025-11-04 14.49.20 - Accepted - runtime 1ms - memory 12.8MB.cpp
2026-01-10 09:23:31,561 [INFO] __main__.py:245 - Writing subsets/2025-11-04 14.28.04 - Accepted - runtime 0ms - memory 12.8MB.cpp
2026-01-10 09:23:31,859 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:31,859 [INFO] __main__.py:245 - Writing asteroid-collision/2025-11-04 11.28.40 - Accepted - runtime 0ms - memory 22.1MB.cpp
2026-01-10 09:23:32,576 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:32,579 [INFO] __main__.py:245 - Writing basic-calculator/2025-11-04 10.37.05 - Accepted - runtime 7ms - memory 12.6MB.cpp
2026-01-10 09:23:32,580 [INFO] __main__.py:188 - Skipping basic-calculator 2025-11-04 10.14.48 because its status is 'Wrong Answer'
2026-01-10 09:23:32,580 [INFO] __main__.py:188 - Skipping basic-calculator 2025-11-04 10.08.38 because its status is 'Wrong Answer'
2026-01-10 09:23:32,988 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:32,989 [INFO] __main__.py:245 - Writing decode-string/2025-11-03 18.15.40 - Accepted - runtime 0ms - memory 9.5MB.cpp
2026-01-10 09:23:33,988 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:33,989 [INFO] __main__.py:245 - Writing minimum-time-to-complete-all-deliveries/2025-11-02 09.20.22 - Accepted - runtime 0ms - memory 52.6MB.cpp
2026-01-10 09:23:33,989 [INFO] __main__.py:188 - Skipping minimum-time-to-complete-all-deliveries 2025-11-02 09.01.23 because its status is 'Wrong Answer'
2026-01-10 09:23:36,103 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:36,105 [INFO] __main__.py:245 - Writing maximum-product-of-three-elements-after-one-replacement/2025-11-02 08.40.23 - Accepted - runtime 43ms - memory 124.4MB.cpp
2026-01-10 09:23:36,105 [INFO] __main__.py:188 - Skipping maximum-product-of-three-elements-after-one-replacement 2025-11-02 08.34.01 because its status is 'Runtime Error'
2026-01-10 09:23:37,108 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:37,110 [INFO] __main__.py:245 - Writing find-missing-elements/2025-11-02 08.08.01 - Accepted - runtime 0ms - memory 32.3MB.cpp
2026-01-10 09:23:42,114 [DEBUG] leetcode.py:150 - Exporting submissions from 100 to 120
2026-01-10 09:23:42,543 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=100&limit=20 HTTP/1.1" 200 None
2026-01-10 09:23:42,552 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1817528859,"question_id":225,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761988534,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1817528859/","is_pending":"Not Pending","title":"Implement Stack using Queues","memory":"9.4 MB","code":"class MyStack {\\n    queue<int>queue;\\npublic:\\n    MyStack() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        int element_to_push = x;\\n        if(queue.empty()){\\n            queue.push(element_to_push);\\n            return;\\n        }\\n        int size = queue.size();\\n        queue.push(element_to_push);\\n        for(int i=0;i<size;i++){\\n            int front_element = queue.front();\\n            queue.pop();\\n            queue.push(front_element);\\n        }\\n    }\\n    \\n    int pop() {\\n        if(queue.empty())return -1;\\n        int popped_element = queue.front();\\n        queue.pop();\\n        return popped_element;\\n    }\\n    \\n    int top() {\\n        if(queue.empty())return -1;\\n        int front_element = queue.front();\\n        return front_element;\\n    }\\n    \\n    bool empty() {\\n        return queue.empty();\\n    }\\n};\\n\\n/**\\n * Your MyStack object will be instantiated and called as such:\\n * MyStack* obj = new MyStack();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->top();\\n * bool param_4 = obj->empty();\\n */","compare_result":"111111111111111111","title_slug":"implement-stack-using-queues","has_notes":false,"flag_type":1,"frontend_id":450},{"id":1817288445,"question_id":84,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761963894,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1817288445/","is_pending":"Not Pending","title":"Largest Rectangle in Histogram","memory":"81.3 MB","code":"class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        heights.push_back(0);// to calculate all remaining heights left in the stack\\n        stack<int>stack;\\n        int max_area = 0;\\n\\n        for(int i=0; i<heights.size(); i++){\\n            // current_height < actual_height_to_calculate\\n            while(!stack.empty() && heights[i] < heights[stack.top()]){\\n                int actual_height = heights[stack.top()];\\n                stack.pop();\\n                int right_boundary_index = i;\\n                int left_boundary_index = stack.empty() ? -1 : stack.top() ;\\n                // area = height * width\\n                int current_area = actual_height * (right_boundary_index - left_boundary_index - 1);\\n                max_area = max(max_area,current_area);\\n            }\\n            stack.push(i); // wait for current height to get its right boundary\\n        }\\n        return max_area;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-rectangle-in-histogram","has_notes":false,"flag_type":1,"frontend_id":449},{"id":1816438678,"question_id":883,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761876097,"status":10,"status_display":"Accepted","runtime":"59 ms","url":"/submissions/detail/1816438678/","is_pending":"Not Pending","title":"Car Fleet","memory":"115.6 MB","code":"class Solution {\\n    bool static custom_operator(const pair<int, int> pair1,\\n                         const pair<int, int> pair2) {\\n\\n            return pair1.first > pair2.first;\\n\\n    }\\n\\npublic:\\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\\n        vector<pair<int, int>> position_speed;\\n\\n        for (int i = 0; i < position.size(); i++) {\\n            position_speed.push_back({position[i], speed[i]});\\n        }\\n\\n        sort(position_speed.begin(), position_speed.end(), custom_operator);\\n\\n        vector<double>time;\\n        for(int i=0;i<position_speed.size();i++){\\n            double current_time = (double)(target - position_speed[i].first)/(double)position_speed[i].second;\\n            time.push_back(current_time);\\n        }\\n\\n        \\n        stack<double>fleets;\\n        for(int i=0; i<time.size();i++){\\n            if(fleets.empty()){\\n                fleets.push(time[i]);\\n                continue;\\n            }\\n            if(time[i] > fleets.top()){\\n                fleets.push(time[i]);\\n            }\\n        }\\n\\n        return fleets.size();\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"car-fleet","has_notes":false,"flag_type":1,"frontend_id":448},{"id":1816438362,"question_id":883,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761876058,"status":10,"status_display":"Accepted","runtime":"3020 ms","url":"/submissions/detail/1816438362/","is_pending":"Not Pending","title":"Car Fleet","memory":"115.8 MB","code":"class Solution {\\n    bool static custom_operator(const pair<int, int> pair1,\\n                         const pair<int, int> pair2) {\\n\\n            return pair1.first > pair2.first;\\n\\n    }\\n\\npublic:\\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\\n        vector<pair<int, int>> position_speed;\\n\\n        for (int i = 0; i < position.size(); i++) {\\n            position_speed.push_back({position[i], speed[i]});\\n        }\\n\\n        sort(position_speed.begin(), position_speed.end(), custom_operator);\\n\\n        vector<double>time;\\n        for(int i=0;i<position_speed.size();i++){\\n            double current_time = (double)(target - position_speed[i].first)/(double)position_speed[i].second;\\n            time.push_back(current_time);\\n        }\\n\\n        for(auto it:position_speed){\\n            cout<<\\"{\\"<<it.first<<\\",\\"<<it.second<<\\"}\\";\\n        }\\n\\n        for(auto &it:time){\\n            cout<<it<<\\" \\";\\n        }\\n\\n        stack<double>fleets;\\n        for(int i=0; i<time.size();i++){\\n            if(fleets.empty()){\\n                fleets.push(time[i]);\\n                continue;\\n            }\\n            if(time[i] > fleets.top()){\\n                fleets.push(time[i]);\\n            }\\n        }\\n\\n        return fleets.size();\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"car-fleet","has_notes":false,"flag_type":1,"frontend_id":447},{"id":1816394655,"question_id":22,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761869412,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1816394655/","is_pending":"Not Pending","title":"Generate Parentheses","memory":"15.7 MB","code":"class Solution {\\n    void solve_paranthesis(string current_string, int open_count,\\n                           int close_count, int n, vector<string>& final_ans) {\\n\\n        if (open_count + close_count == 2 * n) {\\n            final_ans.push_back(current_string);\\n            return;\\n        }\\n        if (open_count < n) {\\n            solve_paranthesis(current_string + \\"(\\", open_count + 1, close_count,\\n                              n, final_ans);\\n        }\\n        if (close_count < open_count) {\\n            solve_paranthesis(current_string + \\")\\", open_count, close_count + 1,\\n                              n, final_ans);\\n        }\\n    }\\n\\npublic:\\n    vector<string> generateParenthesis(int n) {\\n        vector<string> final_ans;\\n        // maintain current_string,open_count,close_count\\n        solve_paranthesis(\\"\\", 0, 0, n, final_ans);\\n        return final_ans;\\n    }\\n};","compare_result":"11111111","title_slug":"generate-parentheses","has_notes":false,"flag_type":1,"frontend_id":446},{"id":1815815096,"question_id":150,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761816785,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1815815096/","is_pending":"Not Pending","title":"Evaluate Reverse Polish Notation","memory":"19.2 MB","code":"class Solution {\\npublic:\\n    int evalRPN(vector<string>& tokens) {\\n        int final_ans = 0;\\n        stack<string> stack;\\n        stack.push(tokens[0]);\\n        for (int i = 1; i < tokens.size(); i++) {\\n            if (tokens[i] == \\"+\\" || tokens[i] == \\"-\\" || tokens[i] == \\"/\\" ||\\n                tokens[i] == \\"*\\") {\\n                int second_number = stoi(stack.top());\\n                stack.pop();\\n                int first_number = stoi(stack.top());\\n                stack.pop();\\n                if (tokens[i] == \\"+\\") {\\n                    stack.push(to_string(first_number + second_number));\\n                }\\n                else if (tokens[i] == \\"-\\") {\\n                    stack.push(to_string(first_number - second_number));\\n                }\\n                else if (tokens[i] == \\"*\\") {\\n                    stack.push(to_string(first_number * second_number));\\n                }\\n                else if (tokens[i] == \\"/\\") {\\n                    stack.push(to_string(first_number / second_number));\\n                }\\n            }else{\\n                stack.push(tokens[i]);\\n            }\\n        }\\n\\n        if(!stack.empty())final_ans = stoi(stack.top());\\n        return final_ans;\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"evaluate-reverse-polish-notation","has_notes":false,"flag_type":1,"frontend_id":445},{"id":1815771735,"question_id":232,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761812550,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1815771735/","is_pending":"Not Pending","title":"Implement Queue using Stacks","memory":"9.7 MB","code":"class MyQueue {\\n    stack<int>input_stack;\\n    stack<int>output_stack;\\npublic:\\n    MyQueue() {\\n        \\n    }\\n    \\n    void push(int x) {\\n        input_stack.push(x);\\n    }\\n    \\n    int pop() {\\n        if(output_stack.empty()){\\n            // Repeatidly pop from input and store in output to show FIFO\\n            while(!input_stack.empty()){\\n                int top_input_stack = input_stack.top();\\n                input_stack.pop();\\n                output_stack.push(top_input_stack);\\n            }\\n            int popped_element = output_stack.top();\\n            output_stack.pop();\\n            return popped_element;\\n        }else{  \\n            int top_output_stack = output_stack.top();\\n            output_stack.pop();\\n            return top_output_stack;\\n        }\\n    }\\n    \\n    int peek() {\\n        if(output_stack.empty()){\\n            // Repeatidly pop from input and store in output to show FIFO\\n            while(!input_stack.empty()){\\n                int top_input_stack = input_stack.top();\\n                input_stack.pop();\\n                output_stack.push(top_input_stack);\\n            }\\n            \\n            return output_stack.top();\\n        }else{  \\n            int top_output_stack = output_stack.top();\\n            return top_output_stack;\\n        }\\n    }\\n    \\n    bool empty() {\\n        if(output_stack.empty() && input_stack.empty())return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your MyQueue object will be instantiated and called as such:\\n * MyQueue* obj = new MyQueue();\\n * obj->push(x);\\n * int param_2 = obj->pop();\\n * int param_3 = obj->peek();\\n * bool param_4 = obj->empty();\\n */","compare_result":"1111111111111111111111","title_slug":"implement-queue-using-stacks","has_notes":false,"flag_type":1,"frontend_id":444},{"id":1814864877,"question_id":739,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761728937,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1814864877/","is_pending":"Not Pending","title":"Daily Temperatures","memory":"102.6 MB","code":"class Solution {\\npublic:\\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\\n        stack<int> stack; // colder_to_warmer\\n        vector<int> ans(temperatures.size(), 0);\\n\\n        for (int i = temperatures.size() - 1; i >= 0; i--) {\\n            if (stack.empty()) {\\n                stack.push(i);\\n                ans[i] = 0;\\n                continue;\\n            }\\n            while (!stack.empty() && temperatures[stack.top()] <= temperatures[i]) {\\n                // colder day at stack.top() will never be required anymore\\n                // because current is more warmer\\n                stack.pop();\\n            }\\n            if(!stack.empty())ans[i] = stack.top() - i;\\n            else ans[i]=0;\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111","title_slug":"daily-temperatures","has_notes":false,"flag_type":1,"frontend_id":443},{"id":1814861463,"question_id":739,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761728627,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1814861463/","is_pending":"Not Pending","title":"Daily Temperatures","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\\n        stack<int> stack; // colder_to_warmer\\n        vector<int> ans(temperatures.size(), 0);\\n\\n        for (int i = temperatures.size() - 1; i >= 0; i--) {\\n            if (stack.empty()) {\\n                stack.push(i);\\n                ans[i] = 0;\\n                continue;\\n            }\\n            while (!stack.empty() && temperatures[stack.top()] < temperatures[i]) {\\n                // colder day at stack.top() will never be required anymore\\n                // because current is more warmer\\n                stack.pop();\\n            }\\n            if(!stack.empty())ans[i] = stack.top() - i;\\n            else ans[i]=0;\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111010000110000000000000000000000000000000000000","title_slug":"daily-temperatures","has_notes":false,"flag_type":1,"frontend_id":442},{"id":1814841802,"question_id":155,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761726815,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1814841802/","is_pending":"Not Pending","title":"Min Stack","memory":"23.3 MB","code":"class MinStack {\\n    // current element, min_element_so_far\\n    stack<pair<int,int>>stack;\\npublic:\\n    MinStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        if(stack.empty()){\\n            stack.push({val,val});\\n            return;\\n        }\\n        int min_element_till_now = min(val,stack.top().second);\\n        stack.push({val,min_element_till_now});\\n    }\\n    \\n    void pop() {\\n        if(!stack.empty())stack.pop();\\n    }\\n    \\n    int top() {\\n        if(stack.empty())return -1;\\n        return stack.top().first;\\n    }\\n    \\n    int getMin() {\\n        if(stack.empty())return -1;\\n        return stack.top().second;\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */","compare_result":"11111111111111111111111111111111","title_slug":"min-stack","has_notes":false,"flag_type":1,"frontend_id":441},{"id":1814834369,"question_id":155,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761726084,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1814834369/","is_pending":"Not Pending","title":"Min Stack","memory":"23.6 MB","code":"class MinStack {\\n    stack<int> minStack;\\n    stack<int> mainStack;\\n\\npublic:\\n    MinStack() {}\\n\\n    void push(int val) {\\n        mainStack.push(val);\\n        if (minStack.empty() || val <= minStack.top()) {\\n            minStack.push(val);\\n        }\\n    }\\n\\n    void pop() {\\n        if (mainStack.empty())\\n            return;\\n        int poppedElement = mainStack.top();\\n        mainStack.pop();\\n        if (!minStack.empty() && minStack.top() == poppedElement) {\\n            minStack.pop();\\n        }\\n    }\\n\\n    int top() {\\n        if (mainStack.empty())\\n            return -1;\\n        return mainStack.top();\\n    }\\n\\n    int getMin() {\\n        if (minStack.empty())\\n            return -1;\\n        return minStack.top();\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */","compare_result":"11111111111111111111111111111111","title_slug":"min-stack","has_notes":false,"flag_type":1,"frontend_id":440},{"id":1814829765,"question_id":155,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761725611,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1814829765/","is_pending":"Not Pending","title":"Min Stack","memory":"N/A","code":"class MinStack {\\n    stack<int> minStack;\\n    stack<int> mainStack;\\npublic:\\n    MinStack() {\\n    }\\n    \\n    void push(int val) {\\n        if(mainStack.empty()){\\n            mainStack.push(val);\\n            minStack.push(val);\\n            return;\\n        }\\n        mainStack.push(val);\\n        if(!minStack.empty() && minStack.top() <= val )return;\\n        minStack.push(val);\\n    }\\n    \\n    void pop() {\\n        if(mainStack.empty())return;\\n        int poppedElement = mainStack.top();\\n        mainStack.pop();\\n        if(!minStack.empty() && minStack.top() == poppedElement){\\n            minStack.pop();\\n        }\\n    }\\n    \\n    int top() {\\n        if(mainStack.empty())return -1;\\n        return mainStack.top();\\n    }\\n    \\n    int getMin() {\\n        if(minStack.empty())return -1;\\n        return minStack.top();\\n    }\\n};\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack* obj = new MinStack();\\n * obj->push(val);\\n * obj->pop();\\n * int param_3 = obj->top();\\n * int param_4 = obj->getMin();\\n */","compare_result":"11110000110111111111001111101111","title_slug":"min-stack","has_notes":false,"flag_type":1,"frontend_id":439},{"id":1814808202,"question_id":20,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761723459,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1814808202/","is_pending":"Not Pending","title":"Valid Parentheses","memory":"8.9 MB","code":"class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>brackets;\\n        if(s.size()%2==1)return false;\\n\\n        for(int i=0; i<s.size();i++){\\n            char currentCh = s[i];\\n            if(currentCh == \'(\' ||currentCh == \'[\' ||currentCh == \'{\'){\\n                brackets.push(s[i]);\\n            }else{\\n                if(brackets.empty())return false;\\n                char topBracket = brackets.top();\\n                brackets.pop();\\n                if( currentCh == \')\' && topBracket != \'(\' ){\\n                    return false;\\n                }else if( currentCh == \'}\' &&  topBracket != \'{\'){\\n                    return false;\\n                }else if( currentCh == \']\' && topBracket != \'[\' ){\\n                    return false;\\n                }\\n            }\\n        }\\n        if(!brackets.empty())return false;\\n        return true;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-parentheses","has_notes":false,"flag_type":1,"frontend_id":438},{"id":1814807605,"question_id":20,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761723406,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1814807605/","is_pending":"Not Pending","title":"Valid Parentheses","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>brackets;\\n        if(s.size()%2==1)return false;\\n\\n        for(int i=0; i<s.size();i++){\\n            char currentCh = s[i];\\n            if(currentCh == \'(\' ||currentCh == \'[\' ||currentCh == \'{\'){\\n                brackets.push(s[i]);\\n            }else{\\n                char topBracket = brackets.top();\\n                brackets.pop();\\n                if( currentCh == \')\' && topBracket != \'(\' ){\\n                    return false;\\n                }else if( currentCh == \'}\' &&  topBracket != \'{\'){\\n                    return false;\\n                }else if( currentCh == \']\' && topBracket != \'[\' ){\\n                    return false;\\n                }\\n            }\\n        }\\n        if(!brackets.empty())return false;\\n        return true;\\n    }\\n};","compare_result":"111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"valid-parentheses","has_notes":false,"flag_type":1,"frontend_id":437},{"id":1814806384,"question_id":20,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761723289,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1814806384/","is_pending":"Not Pending","title":"Valid Parentheses","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>brackets;\\n        if(s.size()%2==1)return false;\\n\\n        for(int i=0; i<s.size();i++){\\n            char currentCh = s[i];\\n            if(currentCh == \'(\' ||currentCh == \'[\' ||currentCh == \'{\'){\\n                brackets.push(s[i]);\\n            }else{\\n                char topBracket = brackets.top();\\n                brackets.pop();\\n                if( currentCh == \')\' && topBracket != \'(\' ){\\n                    return false;\\n                }else if( currentCh == \'}\' &&  topBracket != \'{\'){\\n                    return false;\\n                }else if( currentCh == \']\' && topBracket != \'[\' ){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"valid-parentheses","has_notes":false,"flag_type":1,"frontend_id":436},{"id":1814805839,"question_id":20,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761723238,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1814805839/","is_pending":"Not Pending","title":"Valid Parentheses","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>brackets;\\n\\n        for(int i=0; i<s.size();i++){\\n            char currentCh = s[i];\\n            if(currentCh == \'(\' ||currentCh == \'[\' ||currentCh == \'{\'){\\n                brackets.push(s[i]);\\n            }else{\\n                char topBracket = brackets.top();\\n                brackets.pop();\\n                if( currentCh == \')\' && topBracket != \'(\' ){\\n                    return false;\\n                }else if( currentCh == \'}\' &&  topBracket != \'{\'){\\n                    return false;\\n                }else if( currentCh == \']\' && topBracket != \'[\' ){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"valid-parentheses","has_notes":false,"flag_type":1,"frontend_id":435},{"id":1814771358,"question_id":25,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 1\xc2\xa0week","timestamp":1761720407,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1814771358/","is_pending":"Not Pending","title":"Reverse Nodes in k-Group","memory":"16.5 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverseKNodes(ListNode* head){\\n        if(!head || !head->next)return head;\\n\\n        ListNode* prev = nullptr;\\n        ListNode* curr =  head;\\n        ListNode* nextNode = head->next;\\n\\n        while(curr){\\n            curr->next = prev;\\n            prev = curr;\\n            curr = nextNode;\\n            if(nextNode)nextNode = nextNode->next; \\n        }\\n        return prev;\\n    }\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        ListNode* dummy = new ListNode(-1);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n\\n        while(curr->next){\\n            ListNode* prev = curr;\\n            ListNode* kGroupEnd = curr->next;\\n            int i=0;\\n            while(i<k && curr){\\n                curr = curr->next;\\n                i++;\\n            }\\n            if(!curr)break;\\n\\n            ListNode* kGroupStart = curr;\\n            prev->next = kGroupStart;\\n            ListNode* nextGroup = curr->next;\\n            curr->next = nullptr;\\n            ListNode* lastNodeGroup = kGroupEnd;\\n            kGroupEnd = reverseKNodes(kGroupEnd);\\n            lastNodeGroup->next = nextGroup;\\n            curr = lastNodeGroup;\\n        }\\n\\n        return dummy->next;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-nodes-in-k-group","has_notes":false,"flag_type":1,"frontend_id":434},{"id":1811310564,"question_id":4073,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761404895,"status":10,"status_display":"Accepted","runtime":"151 ms","url":"/submissions/detail/1811310564/","is_pending":"Not Pending","title":"Lexicographically Smallest String After Reverse","memory":"173.1 MB","code":"class Solution {\\npublic:\\n    string lexSmallest(string s) {\\n       string ans = s; \\n        int n = s.size();\\n\\n        for (int k = 1; k <= n; k++) {\\n            string temp = s; \\n            reverse(temp.begin(), temp.begin() + k); \\n            ans = min(ans, temp); \\n        }\\n\\n        for (int k = 1; k <= n; k++) {\\n            string temp = s; \\n            reverse(temp.end() - k, temp.end()); \\n            ans = min(ans, temp); \\n        }\\n\\n        return ans; \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"lexicographically-smallest-string-after-reverse","has_notes":false,"flag_type":1,"frontend_id":433},{"id":1810932672,"question_id":160,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761373124,"status":10,"status_display":"Accepted","runtime":"35 ms","url":"/submissions/detail/1810932672/","is_pending":"Not Pending","title":"Intersection of Two Linked Lists","memory":"18.5 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\n    int calculateLengthLL(ListNode* head){\\n        ListNode* curr = head;\\n        if(!head)return 0;\\n        if(!head->next)return 1;\\n        int lengthLL = 0;\\n        while(curr!=nullptr){\\n            lengthLL++;\\n            curr = curr->next;\\n        }\\n        return lengthLL;\\n    }\\npublic:\\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\\n        int length1 = 0, length2 = 0;\\n        length1 = calculateLengthLL(headA);\\n        length2 = calculateLengthLL(headB);\\n\\n        int difference = abs(length1 - length2);\\n\\n        ListNode* curr1 = headA;\\n        ListNode* curr2 = headB;\\n\\n        while (length1 > length2) {\\n            curr1 = curr1->next;\\n            length1--;\\n        }\\n        while (length1 < length2) {\\n            curr2 = curr2->next;\\n            length2--;\\n        }\\n\\n        while (curr1 != nullptr && curr2 != nullptr) {\\n            if (curr1 == curr2)\\n                return curr1;\\n            curr1 = curr1->next;\\n            curr2 = curr2->next;\\n        }\\n        return nullptr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111","title_slug":"intersection-of-two-linked-lists","has_notes":false,"flag_type":1,"frontend_id":432},{"id":1810897862,"question_id":234,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761369948,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1810897862/","is_pending":"Not Pending","title":"Palindrome Linked List","memory":"117.9 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverseLL(ListNode* head) {\\n        if (!head || !head->next)\\n            return head;\\n        ListNode* currNode = head;\\n        ListNode* prevNode = nullptr;\\n        ListNode* nextNode = head->next;\\n\\n        while (currNode != nullptr) {\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if (nextNode)\\n                nextNode = nextNode->next;\\n        }\\n        return prevNode;\\n    }\\n\\n    void printLL(ListNode* head){\\n        ListNode* curr = head;\\n        while(curr){\\n            cout<<curr->val<<\\" -> \\";curr=curr->next;\\n        }\\n        cout<<\\"\\\\n\\";\\n    }\\n\\npublic:\\n    bool isPalindrome(ListNode* head) {\\n        if (!head)\\n            return false;\\n        if (!head->next)\\n            return true;\\n        ListNode* fast = head;\\n        ListNode* slow = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            fast = fast->next->next;\\n            slow = slow->next;\\n        }\\n        ListNode* middle = slow;\\n        ListNode* reversedMidHead = reverseLL(slow);\\n\\n        ListNode* first = head;\\n        ListNode* second = reversedMidHead;\\n        while (first != slow && second != nullptr) {\\n            if (first->val != second->val) {\\n                return false;\\n            }\\n            first = first->next;\\n            second = second->next;\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-linked-list","has_notes":false,"flag_type":1,"frontend_id":431}],"has_next":true,"last_key":""}'
2026-01-10 09:23:43,606 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:43,609 [INFO] __main__.py:245 - Writing implement-stack-using-queues/2025-11-01 14.45.34 - Accepted - runtime 0ms - memory 9.4MB.cpp
2026-01-10 09:23:43,962 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:43,964 [INFO] __main__.py:245 - Writing largest-rectangle-in-histogram/2025-11-01 07.54.54 - Accepted - runtime 20ms - memory 81.3MB.cpp
2026-01-10 09:23:45,895 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:45,897 [INFO] __main__.py:245 - Writing car-fleet/2025-10-31 07.31.37 - Accepted - runtime 59ms - memory 115.6MB.cpp
2026-01-10 09:23:45,898 [INFO] __main__.py:245 - Writing car-fleet/2025-10-31 07.30.58 - Accepted - runtime 3020ms - memory 115.8MB.cpp
2026-01-10 09:23:45,899 [INFO] __main__.py:245 - Writing generate-parentheses/2025-10-31 05.40.12 - Accepted - runtime 3ms - memory 15.7MB.cpp
2026-01-10 09:23:46,621 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:46,622 [INFO] __main__.py:245 - Writing evaluate-reverse-polish-notation/2025-10-30 15.03.05 - Accepted - runtime 5ms - memory 19.2MB.cpp
2026-01-10 09:23:46,967 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:46,968 [INFO] __main__.py:245 - Writing implement-queue-using-stacks/2025-10-30 13.52.30 - Accepted - runtime 0ms - memory 9.7MB.cpp
2026-01-10 09:23:48,007 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:48,008 [INFO] __main__.py:245 - Writing daily-temperatures/2025-10-29 14.38.57 - Accepted - runtime 12ms - memory 102.6MB.cpp
2026-01-10 09:23:48,008 [INFO] __main__.py:188 - Skipping daily-temperatures 2025-10-29 14.33.47 because its status is 'Wrong Answer'
2026-01-10 09:23:48,316 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:48,318 [INFO] __main__.py:245 - Writing min-stack/2025-10-29 14.03.35 - Accepted - runtime 1ms - memory 23.3MB.cpp
2026-01-10 09:23:48,319 [INFO] __main__.py:245 - Writing min-stack/2025-10-29 13.51.24 - Accepted - runtime 3ms - memory 23.6MB.cpp
2026-01-10 09:23:48,320 [INFO] __main__.py:188 - Skipping min-stack 2025-10-29 13.43.31 because its status is 'Wrong Answer'
2026-01-10 09:23:48,969 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:48,971 [INFO] __main__.py:245 - Writing valid-parentheses/2025-10-29 13.07.39 - Accepted - runtime 0ms - memory 8.9MB.cpp
2026-01-10 09:23:48,971 [INFO] __main__.py:188 - Skipping valid-parentheses 2025-10-29 13.06.46 because its status is 'Runtime Error'
2026-01-10 09:23:48,971 [INFO] __main__.py:188 - Skipping valid-parentheses 2025-10-29 13.04.49 because its status is 'Wrong Answer'
2026-01-10 09:23:48,971 [INFO] __main__.py:188 - Skipping valid-parentheses 2025-10-29 13.03.58 because its status is 'Wrong Answer'
2026-01-10 09:23:49,877 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:49,879 [INFO] __main__.py:245 - Writing reverse-nodes-in-k-group/2025-10-29 12.16.47 - Accepted - runtime 0ms - memory 16.5MB.cpp
2026-01-10 09:23:50,495 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:50,497 [INFO] __main__.py:245 - Writing lexicographically-smallest-string-after-reverse/2025-10-25 20.38.15 - Accepted - runtime 151ms - memory 173.1MB.cpp
2026-01-10 09:23:51,497 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:51,498 [INFO] __main__.py:245 - Writing intersection-of-two-linked-lists/2025-10-25 11.48.44 - Accepted - runtime 35ms - memory 18.5MB.cpp
2026-01-10 09:23:53,612 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:23:53,615 [INFO] __main__.py:245 - Writing palindrome-linked-list/2025-10-25 10.55.48 - Accepted - runtime 0ms - memory 117.9MB.cpp
2026-01-10 09:23:58,617 [DEBUG] leetcode.py:150 - Exporting submissions from 120 to 140
2026-01-10 09:23:59,745 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=120&limit=20 HTTP/1.1" 200 None
2026-01-10 09:23:59,746 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1809938869,"question_id":24,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761272973,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1809938869/","is_pending":"Not Pending","title":"Swap Nodes in Pairs","memory":"11.2 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n\\n        ListNode* dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        ListNode* curr = dummyHead;\\n\\n        while(curr){\\n            if(!curr->next || !curr->next->next){\\n                break;\\n            }\\n            ListNode* firstNode = curr->next;\\n            ListNode* secondNode = curr->next->next;\\n            ListNode* remainingLL = curr->next->next->next;\\n\\n            secondNode->next = firstNode;\\n            firstNode->next = remainingLL;\\n            curr->next = secondNode;\\n            curr = firstNode;\\n        }\\n\\n        ListNode* finalHead  = dummyHead->next;\\n        delete dummyHead;\\n        return finalHead;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111","title_slug":"swap-nodes-in-pairs","has_notes":null,"flag_type":1,"frontend_id":430},{"id":1809418431,"question_id":287,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761223325,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1809418431/","is_pending":"Not Pending","title":"Find the Duplicate Number","memory":"65.1 MB","code":"class Solution {\\npublic:\\n    int findDuplicate(vector<int>& nums) {\\n        int slow = nums[0];\\n        int fast = nums[0];\\n\\n        while(fast < nums.size()){\\n            slow = nums[slow];\\n            fast = nums[nums[fast]];\\n            if(slow == fast){\\n                slow = nums[0];\\n                while(slow != fast){\\n                    slow = nums[slow];\\n                    fast = nums[fast];\\n                }\\n                break;\\n            }\\n        }\\n        return slow;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-duplicate-number","has_notes":false,"flag_type":1,"frontend_id":429},{"id":1809133796,"question_id":2,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761196994,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1809133796/","is_pending":"Not Pending","title":"Add Two Numbers","memory":"77.2 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n\\n    ListNode* reverseLL(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n\\n        ListNode* prevNode = nullptr;\\n        ListNode* currNode = head;\\n        ListNode* nextNode = head->next;\\n\\n        while (currNode != nullptr) {\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if (nextNode->next)\\n                nextNode = nextNode->next;\\n        }\\n        return prevNode;\\n    }\\n\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        int carry = 0;\\n        ListNode* curr1 = l1;\\n        ListNode* curr2 = l2;\\n        ListNode* newHead = new ListNode(-1); // Dummy Head\\n        ListNode* currAns = newHead;\\n        while (curr1 != nullptr || curr2 != nullptr || carry == 1) {\\n            int currentDigitInteger = carry, sum = 0;\\n            if (curr1 && curr2) {\\n                sum = curr1->val + curr2->val;\\n                currentDigitInteger = (sum+ carry) % 10;\\n            } else if (curr1 && !curr2) {\\n                sum = curr1->val;\\n                currentDigitInteger = (sum+ carry) % 10;\\n            } else if (!curr1 && curr2) {\\n                sum = curr2->val;\\n                currentDigitInteger = (sum+ carry) % 10;\\n            }\\n            ListNode* currDigit = new ListNode(currentDigitInteger);\\n            currAns->next = currDigit;\\n            currAns = currAns->next;\\n            if (curr1)\\n                curr1 = curr1->next;\\n            if (curr2)\\n                curr2 = curr2->next;\\n\\n            if (sum + carry > 9 )\\n                carry = 1;\\n            else\\n                carry = 0;\\n        }\\n\\n        return newHead->next;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"add-two-numbers","has_notes":false,"flag_type":1,"frontend_id":428},{"id":1809102836,"question_id":23,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761194364,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1809102836/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"18.3 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    class customComparator {\\n    public:\\n        bool operator()(ListNode* a, ListNode* b) {\\n            return a->val > b->val; // 3,5\\n        }\\n    };\\n\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*, vector<ListNode*>, customComparator> minHeap;\\n\\n        for (int i = 0; i < lists.size(); i++) {\\n            if (lists[i] != nullptr) {\\n                minHeap.push(lists[i]);\\n            }\\n        }\\n\\n        ListNode* ans = new ListNode(-1); // Dummy Head\\n        ListNode* curr = ans;\\n\\n        while (!minHeap.empty()) {\\n            ListNode* minNode = minHeap.top();\\n            minHeap.pop();\\n            ListNode* minNodeNext = minNode->next;\\n            curr->next = minNode;\\n            curr = curr->next;\\n            if(minNodeNext != nullptr)minHeap.push(minNodeNext);\\n        }\\n\\n        return ans->next;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-k-sorted-lists","has_notes":false,"flag_type":1,"frontend_id":427},{"id":1809020240,"question_id":23,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761185387,"status":10,"status_display":"Accepted","runtime":"111 ms","url":"/submissions/detail/1809020240/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"18.5 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* merge2Lists(ListNode* head1, ListNode* head2) {\\n        ListNode* newHead = new ListNode(-1);\\n        ListNode* curr1 = head1;\\n        ListNode* curr2 = head2;\\n        ListNode* ans = newHead;\\n        while (curr1 && curr2) {\\n            if (curr1->val < curr2->val) {\\n                ans->next = curr1;\\n                curr1 = curr1->next;\\n            } else {\\n                ans->next = curr2;\\n                curr2 = curr2->next;\\n            }\\n            ans = ans->next;\\n        }\\n\\n        if (curr1) {\\n            ans->next = curr1;\\n        } else if (curr2) {\\n            ans->next = curr2;\\n        }\\n\\n        return newHead->next;\\n    }\\n\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ansHead = new ListNode(-1);\\n        ListNode* curr = ansHead;\\n        for (int i = 0; i < lists.size(); i++) {\\n            if (ansHead == curr && lists[i]) {\\n                ansHead->next = lists[i];\\n                curr = nullptr;\\n                continue;\\n            }\\n            ansHead->next = merge2Lists(ansHead->next, lists[i]);\\n        }\\n        return ansHead->next;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-k-sorted-lists","has_notes":false,"flag_type":1,"frontend_id":426},{"id":1809000628,"question_id":138,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761182597,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1809000628/","is_pending":"Not Pending","title":"Copy List with Random Pointer","memory":"15.1 MB","code":"/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n\\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* originalNode = head;\\n        while (originalNode != nullptr) {\\n            Node* originalNodeNext = originalNode->next;\\n            originalNode->next = new Node(originalNode->val);\\n            originalNode = originalNode->next;\\n            originalNode->next = originalNodeNext;\\n            originalNode = originalNode->next;\\n        }\\n\\n        originalNode = head;\\n        while (originalNode != nullptr) {\\n            if (originalNode->random != nullptr) {\\n                originalNode->next->random = originalNode->random->next;\\n            }\\n            originalNode = originalNode->next->next;\\n        }\\n\\n        Node* newHead = new Node(-1);\\n        originalNode = head;\\n        Node* newCurr = newHead;\\n\\n        while (originalNode != nullptr) {\\n            Node* originalNodeNext = originalNode->next;\\n            originalNode->next = originalNode->next->next;\\n            newCurr->next = originalNodeNext;\\n            newCurr = newCurr->next;\\n            originalNode = originalNode->next;\\n        }\\n\\n        // Node* curr = newHead;\\n        // while(curr!=nullptr){\\n        //     cout<<curr->val<<\\" \\";\\n        //     curr = curr->next;\\n        // }\\n\\n        return newHead->next;\\n    }\\n};","compare_result":"1111111111111111111","title_slug":"copy-list-with-random-pointer","has_notes":false,"flag_type":1,"frontend_id":425},{"id":1808517591,"question_id":138,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761138338,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1808517591/","is_pending":"Not Pending","title":"Copy List with Random Pointer","memory":"15.2 MB","code":"/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==nullptr)return head;\\n        Node* currNode = head;\\n        unordered_map<Node*,Node*> originalNewMap;\\n\\n        while(currNode != nullptr){\\n            originalNewMap[currNode] = new Node(currNode->val);\\n            currNode = currNode->next;\\n        }\\n\\n        currNode = head;\\n        Node* newHead = new Node(-1);\\n        Node* currNew = newHead;\\n        while(currNode != nullptr){\\n            currNew->next = originalNewMap[currNode];\\n            currNew = currNew->next;\\n            currNew -> val = currNode->val;\\n            if(currNode->random == nullptr)currNew->random = nullptr;\\n            else currNew -> random = originalNewMap[currNode->random];\\n            currNode = currNode->next;\\n        }\\n\\n        return newHead->next;\\n    }\\n};","compare_result":"1111111111111111111","title_slug":"copy-list-with-random-pointer","has_notes":false,"flag_type":1,"frontend_id":424},{"id":1808483275,"question_id":143,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761135392,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1808483275/","is_pending":"Not Pending","title":"Reorder List","memory":"22.8 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverseLL(ListNode*& node) {\\n        if (node == nullptr || node->next == nullptr) {\\n            return node;\\n        }\\n        ListNode* currNode = node;\\n        ListNode* prevNode = nullptr;\\n        ListNode* nextNode = node->next;\\n\\n        while (currNode != nullptr) {\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if (nextNode != nullptr)\\n                nextNode = nextNode->next;\\n        }\\n\\n        return prevNode;\\n    }\\n\\npublic:\\n    void reorderList(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr ||\\n            head->next->next == nullptr) {\\n            return;\\n        }\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* firstListEnd = nullptr;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            firstListEnd = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if (firstListEnd != nullptr)\\n            firstListEnd->next = nullptr;\\n\\n        ListNode* firstHead = head;\\n        ListNode* secondHead = reverseLL(slow);\\n        while (secondHead != nullptr) {\\n\\n            ListNode* firstHeadNext = firstHead->next;\\n            ListNode* secondHeadNext = secondHead->next;\\n            firstHead->next = secondHead;\\n            if (firstHeadNext == nullptr)\\n                break;\\n            secondHead->next = firstHeadNext;\\n            secondHead = secondHeadNext;\\n            firstHead = firstHeadNext;\\n        }\\n    }\\n};","compare_result":"111111111111","title_slug":"reorder-list","has_notes":false,"flag_type":1,"frontend_id":423},{"id":1808482305,"question_id":143,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761135298,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1808482305/","is_pending":"Not Pending","title":"Reorder List","memory":"N/A","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverseLL(ListNode *node){\\n        if(node == nullptr || node->next == nullptr ){\\n            return node;\\n        }\\n        ListNode* currNode = node;\\n        ListNode* prevNode = nullptr;\\n        ListNode* nextNode = node->next;\\n\\n        while(currNode != nullptr){\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if(nextNode != nullptr)nextNode = nextNode->next;\\n        }\\n\\n        return prevNode;\\n    }\\npublic:\\n    void reorderList(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* firstListEnd=nullptr;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            firstListEnd = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(firstListEnd != nullptr)firstListEnd->next = nullptr;\\n\\n        ListNode* firstHead = head;\\n        ListNode* secondHead = reverseLL(slow);\\n        while (secondHead != nullptr) {\\n            \\n            \\n            ListNode* firstHeadNext = firstHead->next;\\n            ListNode* secondHeadNext = secondHead->next;\\n            firstHead->next = secondHead;\\n            if(firstHeadNext == nullptr)break;\\n            secondHead->next = firstHeadNext;\\n            secondHead = secondHeadNext;\\n            firstHead = firstHeadNext; \\n        }\\n    }\\n};","compare_result":"110000000000","title_slug":"reorder-list","has_notes":false,"flag_type":1,"frontend_id":422},{"id":1808480800,"question_id":143,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761135157,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1808480800/","is_pending":"Not Pending","title":"Reorder List","memory":"N/A","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* reverseLL(ListNode *&node){\\n        if(node == nullptr || node->next == nullptr ){\\n            return node;\\n        }\\n        ListNode* currNode = node;\\n        ListNode* prevNode = nullptr;\\n        ListNode* nextNode = node->next;\\n\\n        while(currNode != nullptr){\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if(nextNode != nullptr)nextNode = nextNode->next;\\n        }\\n\\n        return prevNode;\\n    }\\npublic:\\n    void reorderList(ListNode* head) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        ListNode* firstListEnd;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            firstListEnd = slow;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n\\n        if(firstListEnd != nullptr)firstListEnd->next = nullptr;\\n\\n        ListNode* firstHead = head;\\n        ListNode* secondHead = reverseLL(slow);\\n        while (secondHead != nullptr) {\\n            \\n            \\n            ListNode* firstHeadNext = firstHead->next;\\n            ListNode* secondHeadNext = secondHead->next;\\n            firstHead->next = secondHead;\\n            if(firstHead == nullptr)break;\\n            secondHead->next = firstHeadNext;\\n            secondHead = secondHeadNext;\\n            firstHead = firstHeadNext; \\n        }\\n    }\\n};","compare_result":"100000000000","title_slug":"reorder-list","has_notes":false,"flag_type":1,"frontend_id":421},{"id":1808105010,"question_id":19,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761101442,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1808105010/","is_pending":"Not Pending","title":"Remove Nth Node From End of List","memory":"15 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        int count = 1;\\n\\n        ListNode* slow = dummyHead;\\n        ListNode* fast = head;\\n\\n        while(fast != nullptr && fast->next != nullptr && count < n){\\n            count++;\\n            fast = fast->next;\\n        }\\n\\n        while(fast != nullptr && fast->next != nullptr){\\n            fast = fast->next;\\n            slow = slow->next;\\n        }\\n\\n        ListNode* nodeToRemove = slow->next;\\n        slow->next = slow->next->next;\\n        delete nodeToRemove;\\n\\n        return dummyHead->next;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-nth-node-from-end-of-list","has_notes":false,"flag_type":1,"frontend_id":420},{"id":1807623349,"question_id":19,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761055165,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1807623349/","is_pending":"Not Pending","title":"Remove Nth Node From End of List","memory":"14.8 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        int count = 1;\\n\\n        while(fast != nullptr && count <= n){\\n            fast = fast->next;\\n            count++;\\n        }\\n\\n        while(fast != nullptr && fast->next != nullptr){\\n            slow = slow->next;\\n            fast = fast->next;\\n        }\\n\\n        if(fast == nullptr){\\n            ListNode* newHead = head->next;\\n            delete head;\\n\\n            return newHead;;\\n        }\\n\\n        ListNode* temp = slow->next;\\n        slow->next = slow->next->next;\\n        delete temp;\\n\\n        return head;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-nth-node-from-end-of-list","has_notes":false,"flag_type":1,"frontend_id":419},{"id":1807591832,"question_id":146,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761052922,"status":10,"status_display":"Accepted","runtime":"76 ms","url":"/submissions/detail/1807591832/","is_pending":"Not Pending","title":"LRU Cache","memory":"173.1 MB","code":"struct DLL{\\n    int storedKey;\\n    int storedVal;\\n    DLL *next;\\n    DLL* prev;\\n    DLL(int key,int val){\\n        this->storedKey = key;\\n        this->storedVal = val;\\n        this->next = nullptr;\\n        this->prev = nullptr;\\n    }\\n};\\nclass LRUCache {\\n    unordered_map<int,DLL*>keyMap;\\n    int currentCapacity;\\n    int maxCapacity;\\n    DLL* head;\\n    DLL* tail;\\n\\n    void updateTail(DLL *&tail,DLL *&currNode){\\n        tail->prev->next = currNode;\\n        currNode->prev = tail->prev;\\n        currNode->next = tail;\\n        tail->prev = currNode;\\n    }\\n\\n    void removeNode(DLL * &tail,DLL* &nodeToDelete){\\n        nodeToDelete->prev->next = nodeToDelete->next;\\n        nodeToDelete->next->prev = nodeToDelete->prev;\\n    }\\npublic:\\n    LRUCache(int capacity) {\\n        head = new DLL(-1,-1);\\n        tail = new DLL(-1,-1);\\n        head->next = tail;\\n        tail->prev = head;\\n        this->maxCapacity = capacity;\\n        currentCapacity = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!keyMap.count(key)){\\n            return -1;\\n        } \\n        DLL* currNode = keyMap[key];\\n        removeNode(tail,currNode);\\n        updateTail(tail,currNode);\\n        return currNode->storedVal;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!keyMap.count(key)){\\n            // Not Found\\n            if(currentCapacity < maxCapacity){\\n                // Valid cache size\\n                DLL* newNode = new DLL(key,value);\\n                currentCapacity++;\\n                keyMap[key] = newNode;\\n                updateTail(tail,newNode);\\n            }else{\\n                // Invalid cache Size\\n                DLL* leastRecentlyUsedNode = head->next;\\n                removeNode(tail,leastRecentlyUsedNode);\\n                keyMap.erase(leastRecentlyUsedNode->storedKey); // HERE Delete Stored key not new Key\\n                delete leastRecentlyUsedNode;\\n\\n                DLL* newNode = new DLL(key,value);\\n                keyMap[key] = newNode;\\n                updateTail(tail,newNode);\\n            }\\n        }else{\\n            // Found\\n            DLL* currNode = keyMap[key];\\n            currNode->storedVal = value;\\n            removeNode(tail,currNode);\\n            updateTail(tail,currNode);\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */","compare_result":"111111111111111111111111","title_slug":"lru-cache","has_notes":false,"flag_type":1,"frontend_id":418},{"id":1807591248,"question_id":146,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761052879,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1807591248/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"struct DLL{\\n    int storedKey;\\n    int storedVal;\\n    DLL *next;\\n    DLL* prev;\\n    DLL(int key,int val){\\n        this->storedKey = key;\\n        this->storedVal = val;\\n        this->next = nullptr;\\n        this->prev = nullptr;\\n    }\\n};\\nclass LRUCache {\\n    unordered_map<int,DLL*>keyMap;\\n    int currentCapacity;\\n    int maxCapacity;\\n    DLL* head;\\n    DLL* tail;\\n\\n    void updateTail(DLL *&tail,DLL *&currNode){\\n        tail->prev->next = currNode;\\n        currNode->prev = tail->prev;\\n        currNode->next = tail;\\n        tail->prev = currNode;\\n    }\\n\\n    void removeNode(DLL * &tail,DLL* &nodeToDelete){\\n        nodeToDelete->prev->next = nodeToDelete->next;\\n        nodeToDelete->next->prev = nodeToDelete->prev;\\n    }\\npublic:\\n    LRUCache(int capacity) {\\n        head = new DLL(-1,-1);\\n        tail = new DLL(-1,-1);\\n        head->next = tail;\\n        tail->prev = head;\\n        this->maxCapacity = capacity;\\n        currentCapacity = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!keyMap.count(key)){\\n            return -1;\\n        } \\n        DLL* currNode = keyMap[key];\\n        removeNode(tail,currNode);\\n        updateTail(tail,currNode);\\n        return currNode->storedVal;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!keyMap.count(key)){\\n            // Not Found\\n            if(currentCapacity < maxCapacity){\\n                // Valid cache size\\n                DLL* newNode = new DLL(key,value);\\n                currentCapacity++;\\n                keyMap[key] = newNode;\\n                updateTail(tail,newNode);\\n            }else{\\n                // Invalid cache Size\\n                DLL* leastRecentlyUsedNode = head->next;\\n                removeNode(tail,leastRecentlyUsedNode);\\n                keyMap.erase(leastRecentlyUsedNode->storedKey); // HERE Delete Stored key not new Key\\n                delete leastRecentlyUsedNode;\\n\\n                DLL* newNode = new DLL(key,value);\\n                keyMap[key] = newNode;\\n                updateTail(tail,newNode);\\n            }\\n        }else{\\n            // Found\\n            DLL* currNode = keyMap[key];\\n            currNode->storedVal = value;\\n            removeNode(tail,currNode);\\n            updateTail(tail,currNode);\\n            currentCapacity++;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */","compare_result":"111111111111111100000001","title_slug":"lru-cache","has_notes":false,"flag_type":1,"frontend_id":417},{"id":1807573827,"question_id":146,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1761051544,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1807573827/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"struct DLL{\\n    int storedKey;\\n    int storedVal;\\n    DLL *next;\\n    DLL* prev;\\n    DLL(int key,int val){\\n        this->storedKey = key;\\n        this->storedVal = val;\\n        this->next = nullptr;\\n        this->prev = nullptr;\\n    }\\n};\\nclass LRUCache {\\n    unordered_map<int,DLL*>keyMap;\\n    int currentCapacity;\\n    int maxCapacity;\\n    DLL* head;\\n    DLL* tail;\\n\\n    void updateTail(DLL *&tail,DLL *&currNode){\\n        \\n        currNode->prev->next = currNode->next;\\n        if(currNode->next)currNode->next->prev = currNode->prev;\\n        currNode->prev = tail;\\n        tail->next = currNode;\\n        currNode->next = nullptr;\\n        tail = tail->next; \\n    }\\npublic:\\n    LRUCache(int capacity) {\\n        head = new DLL(-1,-1);\\n        tail = head;\\n        this->maxCapacity = capacity;\\n        currentCapacity = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(!keyMap.count(key)){\\n            return -1;\\n        } \\n        DLL* currNode = keyMap[key];\\n        updateTail(tail,currNode);\\n        return currNode->storedVal;\\n    }\\n    \\n    void put(int key, int value) {\\n        if(!keyMap.count(key)){\\n            // Not Found\\n            if(currentCapacity < maxCapacity){\\n                // Valid cache size\\n                DLL* newNode = new DLL(key,value);\\n                currentCapacity++;\\n                keyMap[key] = newNode;\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }else{\\n                // Invalid cache Size\\n                DLL* leastRecentlyUsedNode = head->next;\\n                head->next = head->next->next;\\n                head->next->prev = head;\\n                keyMap.erase(leastRecentlyUsedNode->storedKey); // HERE Delete Stored key not new Key\\n                delete leastRecentlyUsedNode;\\n\\n                DLL* newNode = new DLL(key,value);\\n                keyMap[key] = newNode;\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }\\n        }else{\\n            // Found\\n            DLL* currNode = keyMap[key];\\n            currNode->storedVal = value;\\n            updateTail(tail,currNode);\\n            currentCapacity++;\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */","compare_result":"111111000000000000000000","title_slug":"lru-cache","has_notes":false,"flag_type":1,"frontend_id":416},{"id":1805495547,"question_id":4045,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760842648,"status":10,"status_display":"Accepted","runtime":"1912 ms","url":"/submissions/detail/1805495547/","is_pending":"Not Pending","title":"Longest Balanced Subarray I","memory":"530.5 MB","code":"class Solution {\\npublic:\\n    int longestBalanced(vector<int>& nums) {\\n        int maxLength = 0;\\n\\n        for(int i=0; i<nums.size();i++){\\n            unordered_set<int>odd;\\n            unordered_set<int>even;\\n\\n            for(int j=i;j<nums.size();j++){\\n                int currNumber = nums[j];\\n\\n                if(currNumber % 2 == 0){\\n                    even.insert(currNumber);\\n                }else{\\n                    odd.insert(currNumber);\\n                }\\n\\n                if(even.size() == odd.size()){\\n                    int currSize = j-i+1;\\n                    maxLength = max(maxLength,currSize);\\n                }\\n            }\\n            \\n        }\\n        return maxLength;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-balanced-subarray-i","has_notes":false,"flag_type":1,"frontend_id":415},{"id":1805458920,"question_id":4080,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760841336,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1805458920/","is_pending":"Not Pending","title":"Smallest Missing Multiple of K","memory":"25.1 MB","code":"class Solution {\\npublic:\\n    int missingMultiple(vector<int>& nums, int k) {\\n        unordered_set<int>set(nums.begin(),nums.end());\\n\\n        for(int i=k; i<=nums.size()*k + k; i+=k){\\n            if(!set.count(i)){\\n                return i;\\n            }\\n        }\\n        return k;\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-missing-multiple-of-k","has_notes":false,"flag_type":1,"frontend_id":414},{"id":1805443906,"question_id":146,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760840120,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1805443906/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"class LRUCache {\\n    class DLL{\\n        public:\\n        int data;\\n        DLL* next;\\n        DLL* prev;\\n        DLL(int data){\\n            this->data = data;\\n            this->prev = nullptr;\\n            this->next = nullptr;\\n        }\\n    };\\n    DLL * head;\\n    DLL * tail;\\n    int capacity;\\n    int currentCapacity;\\n    unordered_map<int,DLL*>keyMap;\\n\\n    void updateNodeToTail(DLL* &head,DLL* &tail,DLL *&node){\\n            node->prev->next = node->next;\\n            if(node->next != nullptr)node->next->prev = node->prev;\\n            node->prev = tail;\\n            tail->next = node;\\n            node->next = nullptr;\\n            tail = tail->next;\\n    }\\npublic:\\n    LRUCache(int capacity) {\\n        head = new DLL(-1);\\n        tail = head;\\n        this->capacity = capacity;\\n        this->currentCapacity = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyMap.count(key)){\\n            // Found\\n            DLL* ans = keyMap[key];\\n            // Move Ans To LRU\\n            int ansValue = ans->data;\\n            updateNodeToTail(head,tail,ans);\\n            return ansValue;\\n        }else{\\n            return -1;\\n        }\\n    }\\n    \\n    void put(int key, int value) {\\n        if(keyMap.count(key)){\\n            // Found\\n            DLL* ansNode = keyMap[key];\\n            ansNode->data = value;\\n            updateNodeToTail(head,tail,ansNode);\\n        }else{\\n            // Not Found\\n            if(currentCapacity < capacity){\\n                // Can Bear Addition\\n                DLL* newNode = new DLL(value);\\n                keyMap[key] = newNode;\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                newNode->next = nullptr;\\n                tail = tail->next;\\n                currentCapacity++;\\n            }else{\\n                // Remove LRU and update currentCapacity and update MRU\\n                if(currentCapacity >= 1){\\n                    DLL* tempHead = head->next;\\n                    head->next = head->next->next;\\n                    head->next->prev = head;\\n                    keyMap.erase(tempHead->data);\\n                    delete tempHead;\\n                }\\n                DLL* newNode = new DLL(value);\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                newNode->next = nullptr;\\n                tail = tail->next;\\n                keyMap[key] = newNode;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */","compare_result":"111100000000000000000000","title_slug":"lru-cache","has_notes":false,"flag_type":1,"frontend_id":413},{"id":1805442249,"question_id":146,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760839859,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1805442249/","is_pending":"Not Pending","title":"LRU Cache","memory":"N/A","code":"class LRUCache {\\n    class DLL{\\n        public:\\n        int data;\\n        DLL* next;\\n        DLL* prev;\\n        DLL(int data){\\n            this->data = data;\\n            this->prev = nullptr;\\n            this->next = nullptr;\\n        }\\n    };\\n    DLL * head;\\n    DLL * tail;\\n    int capacity;\\n    int currentCapacity;\\n    unordered_map<int,DLL*>keyMap;\\n\\n    void updateNodeToTail(DLL* &head,DLL* &tail,DLL *&node){\\n            node->prev->next = node->next;\\n            node->next->prev = node->prev;\\n            node->prev = tail;\\n            tail->next = node;\\n            node->next = nullptr;\\n            tail = tail->next;\\n    }\\npublic:\\n    LRUCache(int capacity) {\\n        head = new DLL(-1);\\n        tail = head;\\n        this->capacity = capacity;\\n        this->currentCapacity = 0;\\n    }\\n    \\n    int get(int key) {\\n        if(keyMap.count(key)){\\n            // Found\\n            DLL* ans = keyMap[key];\\n            // Move Ans To LRU\\n            int ansValue = ans->data;\\n            updateNodeToTail(head,tail,ans);\\n            return ansValue;\\n        }else{\\n            return -1;\\n        }\\n    }\\n    \\n    void put(int key, int value) {\\n        if(keyMap.count(key)){\\n            // Found\\n            DLL* ansNode = keyMap[key];\\n            ansNode->data = value;\\n            updateNodeToTail(head,tail,ansNode);\\n        }else{\\n            // Not Found\\n            if(currentCapacity < capacity){\\n                // Can Bear Addition\\n                DLL* newNode = new DLL(value);\\n                keyMap[key] = newNode;\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                newNode->next = nullptr;\\n                tail = tail->next;\\n                currentCapacity++;\\n            }else{\\n                // Remove LRU and update currentCapacity and update MRU\\n                DLL* tempHead = head->next;\\n                head->next = head->next->next;\\n                head->next->prev = head;\\n                keyMap.erase(tempHead->data);\\n                delete tempHead;\\n\\n                DLL* newNode = new DLL(value);\\n                newNode->prev = tail;\\n                tail->next = newNode;\\n                newNode->next = nullptr;\\n                tail = tail->next;\\n                keyMap[key] = newNode;\\n            }\\n        }\\n    }\\n};\\n\\n/**\\n * Your LRUCache object will be instantiated and called as such:\\n * LRUCache* obj = new LRUCache(capacity);\\n * int param_1 = obj->get(key);\\n * obj->put(key,value);\\n */","compare_result":"111000000000000000000000","title_slug":"lru-cache","has_notes":false,"flag_type":1,"frontend_id":412},{"id":1804781205,"question_id":21,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760769733,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1804781205/","is_pending":"Not Pending","title":"Merge Two Sorted Lists","memory":"19.5 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        ListNode* list3 = new ListNode(-1); // Dummy Node\\n        ListNode* newList = list3;\\n        while(list1 != nullptr && list2 != nullptr){\\n            if(list1->val < list2 -> val){\\n                newList->next = list1;\\n                newList = newList->next;\\n                list1 = list1->next;\\n            }else{\\n                newList->next = list2;\\n                newList = newList->next;\\n                list2 = list2->next;\\n            }\\n        }\\n\\n        if(list1 != nullptr){\\n            newList -> next = list1;\\n        }\\n        if(list2 != nullptr){\\n            newList->next = list2;\\n        }\\n\\n        return list3->next;\\n\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-two-sorted-lists","has_notes":false,"flag_type":1,"frontend_id":411}],"has_next":true,"last_key":""}'
2026-01-10 09:24:01,626 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:01,629 [INFO] __main__.py:245 - Writing swap-nodes-in-pairs/2025-10-24 07.59.33 - Accepted - runtime 0ms - memory 11.2MB.cpp
2026-01-10 09:24:03,927 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:03,929 [INFO] __main__.py:245 - Writing find-the-duplicate-number/2025-10-23 18.12.05 - Accepted - runtime 1ms - memory 65.1MB.cpp
2026-01-10 09:24:05,991 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:05,992 [INFO] __main__.py:245 - Writing add-two-numbers/2025-10-23 10.53.14 - Accepted - runtime 2ms - memory 77.2MB.cpp
2026-01-10 09:24:06,284 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:06,285 [INFO] __main__.py:245 - Writing merge-k-sorted-lists/2025-10-23 10.09.24 - Accepted - runtime 0ms - memory 18.3MB.cpp
2026-01-10 09:24:06,286 [INFO] __main__.py:245 - Writing merge-k-sorted-lists/2025-10-23 07.39.47 - Accepted - runtime 111ms - memory 18.5MB.cpp
2026-01-10 09:24:06,678 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:06,679 [INFO] __main__.py:245 - Writing copy-list-with-random-pointer/2025-10-23 06.53.17 - Accepted - runtime 7ms - memory 15.1MB.cpp
2026-01-10 09:24:06,680 [INFO] __main__.py:245 - Writing copy-list-with-random-pointer/2025-10-22 18.35.38 - Accepted - runtime 4ms - memory 15.2MB.cpp
2026-01-10 09:24:08,862 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:08,864 [INFO] __main__.py:245 - Writing reorder-list/2025-10-22 17.46.32 - Accepted - runtime 0ms - memory 22.8MB.cpp
2026-01-10 09:24:08,865 [INFO] __main__.py:188 - Skipping reorder-list 2025-10-22 17.44.58 because its status is 'Runtime Error'
2026-01-10 09:24:08,865 [INFO] __main__.py:188 - Skipping reorder-list 2025-10-22 17.42.37 because its status is 'Runtime Error'
2026-01-10 09:24:09,872 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:09,873 [INFO] __main__.py:245 - Writing remove-nth-node-from-end-of-list/2025-10-22 08.20.42 - Accepted - runtime 0ms - memory 15MB.cpp
2026-01-10 09:24:09,873 [INFO] __main__.py:245 - Writing remove-nth-node-from-end-of-list/2025-10-21 19.29.25 - Accepted - runtime 0ms - memory 14.8MB.cpp
2026-01-10 09:24:11,995 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:11,997 [INFO] __main__.py:245 - Writing lru-cache/2025-10-21 18.52.02 - Accepted - runtime 76ms - memory 173.1MB.cpp
2026-01-10 09:24:11,998 [INFO] __main__.py:188 - Skipping lru-cache 2025-10-21 18.51.19 because its status is 'Wrong Answer'
2026-01-10 09:24:11,998 [INFO] __main__.py:188 - Skipping lru-cache 2025-10-21 18.29.04 because its status is 'Runtime Error'
2026-01-10 09:24:12,687 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:12,688 [INFO] __main__.py:245 - Writing longest-balanced-subarray-i/2025-10-19 08.27.28 - Accepted - runtime 1912ms - memory 530.5MB.cpp
2026-01-10 09:24:14,808 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:14,811 [INFO] __main__.py:245 - Writing smallest-missing-multiple-of-k/2025-10-19 08.05.36 - Accepted - runtime 7ms - memory 25.1MB.cpp
2026-01-10 09:24:14,811 [INFO] __main__.py:188 - Skipping lru-cache 2025-10-19 07.45.20 because its status is 'Runtime Error'
2026-01-10 09:24:14,812 [INFO] __main__.py:188 - Skipping lru-cache 2025-10-19 07.40.59 because its status is 'Runtime Error'
2026-01-10 09:24:15,628 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:15,630 [INFO] __main__.py:245 - Writing merge-two-sorted-lists/2025-10-18 12.12.13 - Accepted - runtime 0ms - memory 19.5MB.cpp
2026-01-10 09:24:20,636 [DEBUG] leetcode.py:150 - Exporting submissions from 140 to 160
2026-01-10 09:24:25,465 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=140&limit=20 HTTP/1.1" 200 None
2026-01-10 09:24:25,466 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1804745203,"question_id":141,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760766416,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1804745203/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"11.7 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr)\\n            return false;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while (fast != nullptr && fast->next != nullptr) {\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if (slow == fast) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":410},{"id":1804742163,"question_id":141,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760766122,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1804742163/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"11.9 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==nullptr || head->next == nullptr)return false;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        bool firstMeeting = true;\\n\\n        while(fast != nullptr && fast -> next != nullptr){\\n            if(slow == fast){\\n                if(firstMeeting){\\n                    firstMeeting = false;\\n                }else{\\n                    return true;\\n                }\\n            }\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return false;\\n\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":409},{"id":1804741115,"question_id":141,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760766013,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1804741115/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"N/A","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head==nullptr || head->next == nullptr)return false;\\n\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n\\n        while(fast != nullptr && fast -> next != nullptr){\\n            if(slow == fast)return true;\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return false;\\n\\n    }\\n};","compare_result":"11111101110111011001000000000","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":408},{"id":1803967617,"question_id":206,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760679517,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1803967617/","is_pending":"Not Pending","title":"Reverse Linked List","memory":"13.3 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == nullptr || head->next == nullptr){\\n            return head;\\n        }\\n        ListNode* prevNode = nullptr;\\n        ListNode* currNode = head;\\n        ListNode* nextNode = head->next;\\n\\n        while(currNode != nullptr){\\n            currNode->next = prevNode;\\n            prevNode = currNode;\\n            currNode = nextNode;\\n            if(nextNode != nullptr)nextNode = nextNode->next;\\n        }\\n        return prevNode;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"reverse-linked-list","has_notes":false,"flag_type":1,"frontend_id":407},{"id":1803966448,"question_id":206,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760679409,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1803966448/","is_pending":"Not Pending","title":"Reverse Linked List","memory":"N/A","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        if(head == nullptr || head->next == nullptr){\\n            return head;\\n        }\\n        ListNode* prevNode = nullptr;\\n        ListNode* prevNode = nullptr;\\n    }\\n};","compare_result":null,"title_slug":"reverse-linked-list","has_notes":false,"flag_type":1,"frontend_id":406},{"id":1803941901,"question_id":57,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760677149,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1803941901/","is_pending":"Not Pending","title":"Insert Interval","memory":"21.6 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals,\\n                               vector<int>& newInterval) {\\n        vector<vector<int>> mergedIntervals;\\n        int i = 0;\\n        while (i < intervals.size() && intervals[i][1] < newInterval[0]) {\\n            mergedIntervals.push_back(intervals[i]);\\n            i++;\\n        }\\n\\n        // EDGE CASE\\n        while (i < intervals.size() && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n\\n        mergedIntervals.push_back(newInterval);\\n\\n        while (i < intervals.size()) {\\n            mergedIntervals.push_back(intervals[i]);\\n            i++;\\n        }\\n\\n        return mergedIntervals;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"insert-interval","has_notes":false,"flag_type":1,"frontend_id":405},{"id":1803941672,"question_id":57,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760677129,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1803941672/","is_pending":"Not Pending","title":"Insert Interval","memory":"21.6 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals,\\n                               vector<int>& newInterval) {\\n        vector<vector<int>> mergedIntervals;\\n        int i = 0;\\n        while (i < intervals.size() && intervals[i][1] < newInterval[0]) {\\n            mergedIntervals.push_back(intervals[i]);\\n            i++;\\n        }\\n\\n        cout << \\"BEFORE: \\";\\n        for (auto& interval : mergedIntervals) {\\n            cout << interval[0] << \\",\\" << interval[1] << \\"\\\\n\\";\\n        }\\n        // EDGE CASE\\n        while (i < intervals.size() && intervals[i][0] <= newInterval[1]) {\\n            newInterval[0] = min(newInterval[0], intervals[i][0]);\\n            newInterval[1] = max(newInterval[1], intervals[i][1]);\\n            i++;\\n        }\\n\\n        mergedIntervals.push_back(newInterval);\\n\\n        cout << \\"After: \\";\\n        for (auto& interval : mergedIntervals) {\\n            cout << interval[0] << \\",\\" << interval[1] << \\"\\\\n\\";\\n        }\\n\\n        while (i < intervals.size()) {\\n            mergedIntervals.push_back(intervals[i]);\\n            i++;\\n        }\\n\\n        return mergedIntervals;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"insert-interval","has_notes":false,"flag_type":1,"frontend_id":404},{"id":1803914077,"question_id":57,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760674647,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1803914077/","is_pending":"Not Pending","title":"Insert Interval","memory":"21.8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals,\\n                               vector<int>& newInterval) {\\n        vector<vector<int>> mergedIntervals;\\n        int i = 0;\\n        while (i < intervals.size()) {\\n            if (intervals[i][0] < newInterval[0]) {\\n                mergedIntervals.push_back(intervals[i]);\\n            } else {\\n                break;\\n            }\\n            i++;\\n        }\\n        if (mergedIntervals.size() > 0 && (mergedIntervals.back()[1] >= newInterval[0] ||\\n            mergedIntervals.back()[0] >= newInterval[0])) {\\n            mergedIntervals.back()[0] =\\n                min(mergedIntervals.back()[0], newInterval[0]);\\n            mergedIntervals.back()[1] =\\n                max(mergedIntervals.back()[1], newInterval[1]);\\n        } else {\\n            mergedIntervals.push_back(newInterval);\\n        }\\n        while (i < intervals.size()) {\\n            if (mergedIntervals.back()[1] >= intervals[i][0] ||\\n                mergedIntervals.back()[0] >= intervals[i][0]) {\\n                mergedIntervals.back()[0] =\\n                    min(mergedIntervals.back()[0], intervals[i][0]);\\n                mergedIntervals.back()[1] =\\n                    max(mergedIntervals.back()[1], intervals[i][1]);\\n            } else {\\n                mergedIntervals.push_back(intervals[i]);\\n            }\\n            i++;\\n        }\\n\\n        return mergedIntervals;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"insert-interval","has_notes":false,"flag_type":1,"frontend_id":403},{"id":1803912460,"question_id":57,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760674487,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1803912460/","is_pending":"Not Pending","title":"Insert Interval","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> insert(vector<vector<int>>& intervals,\\n                               vector<int>& newInterval) {\\n        vector<vector<int>> mergedIntervals;\\n        int i = 0;\\n        while (i < intervals.size()) {\\n            if (intervals[i][0] < newInterval[0]) {\\n                mergedIntervals.push_back(intervals[i]);\\n            } else {\\n                if (mergedIntervals.back()[1] >= newInterval[0] ||\\n                    mergedIntervals.back()[0] >= newInterval[0]) {\\n                    mergedIntervals.back()[0] =\\n                        min(mergedIntervals.back()[0], newInterval[0]);\\n                    mergedIntervals.back()[1] =\\n                        max(mergedIntervals.back()[1], newInterval[1]);\\n                } else {\\n                    mergedIntervals.push_back(newInterval);\\n                }\\n                break;\\n            }\\n            i++;\\n        }\\n        while(i<intervals.size()) {\\n            if (mergedIntervals.back()[1] >= intervals[i][0] ||\\n                mergedIntervals.back()[0] >= intervals[i][0]) {\\n                mergedIntervals.back()[0] =\\n                    min(mergedIntervals.back()[0], intervals[i][0]);\\n                mergedIntervals.back()[1] =\\n                    max(mergedIntervals.back()[1], intervals[i][1]);\\n            } else {\\n                mergedIntervals.push_back(intervals[i]);\\n            }\\n            i++;\\n        }\\n\\n        return mergedIntervals;\\n    }\\n};","compare_result":"11010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"insert-interval","has_notes":false,"flag_type":1,"frontend_id":402},{"id":1803875607,"question_id":121,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760670333,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1803875607/","is_pending":"Not Pending","title":"Best Time to Buy and Sell Stock","memory":"97.3 MB","code":"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int maxProfit = 0,minPrice = INT_MAX;    \\n        for(int i=0;i<prices.size();i++){\\n            minPrice = min(minPrice,prices[i]);\\n            maxProfit = max(maxProfit,prices[i] - minPrice);\\n        }\\n        return maxProfit;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"best-time-to-buy-and-sell-stock","has_notes":false,"flag_type":1,"frontend_id":401},{"id":1803409595,"question_id":5,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760623619,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1803409595/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"12 MB","code":"class Solution {\\n    pair<int,int> getMaxSubstr(string &s,int left,int right){\\n        while(left >=0 && right < s.size() && s[left] == s[right]){\\n            left--;\\n            right++;\\n        }\\n        return {left+1, (right-1) - (left+1) + 1};\\n    }\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxLength = 0;\\n        string longestStr = \\"\\";\\n\\n        for(int currentCharIndex=0;currentCharIndex<s.size();currentCharIndex++){\\n            // <startIdx,lengthSubstr>\\n            pair<int,int> evenLength = getMaxSubstr(s,currentCharIndex,currentCharIndex);\\n            pair<int,int> oddLength = getMaxSubstr(s,currentCharIndex,currentCharIndex+1);\\n            int currentLength = max(evenLength.second,oddLength.second);\\n            if(maxLength < currentLength){\\n                maxLength = currentLength;\\n                if(evenLength.second == maxLength){\\n                    longestStr = s.substr(evenLength.first,evenLength.second);\\n                }else{\\n                    longestStr = s.substr(oddLength.first,oddLength.second);\\n                }\\n            }\\n        }\\n\\n        return longestStr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1,"frontend_id":400},{"id":1803337214,"question_id":125,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760617607,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1803337214/","is_pending":"Not Pending","title":"Valid Palindrome","memory":"9.9 MB","code":"class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int left = 0,right = s.size()-1;\\n        for(int i=0; i<s.size();i++){\\n            if(s[i] >= \'A\' && s[i] <= \'Z\'){\\n                s[i] = (char)((int)(s[i] - \'A\') + \'a\');\\n            }\\n        }\\n\\n        while(left < right){\\n            while(left < right && !isalnum(s[left]))left++;\\n            while(right > left && !isalnum(s[right]))right--;\\n\\n            if(s[left] != s[right])return false;\\n\\n            left++;right--;\\n        }\\n\\n        return true;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-palindrome","has_notes":false,"flag_type":1,"frontend_id":399},{"id":1803336885,"question_id":125,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760617575,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1803336885/","is_pending":"Not Pending","title":"Valid Palindrome","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(string s) {\\n        int left = 0,right = s.size()-1;\\n        for(int i=0; i<s.size();i++){\\n            if(s[i] >= \'A\' && s[i] <= \'Z\'){\\n                s[i] = (char)((int)(s[i] - \'A\') + \'a\');\\n            }\\n        }\\n\\n        while(left < right){\\n            while(!isalnum(s[left]))left++;\\n            while(!isalnum(s[right]))right--;\\n\\n            if(s[left] != s[right])return false;\\n\\n            left++;right--;\\n        }\\n\\n        return true;\\n    }\\n};","compare_result":"1111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"valid-palindrome","has_notes":false,"flag_type":1,"frontend_id":398},{"id":1803012611,"question_id":424,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760588844,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1803012611/","is_pending":"Not Pending","title":"Longest Repeating Character Replacement","memory":"11 MB","code":"class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int maxFreqChar = 0,maxLengthSubstr = 0,currWindowSize = 0,left=0;\\n        unordered_map<char,int>freqMap; // WORST CASE -> 26 size O(1)\\n\\n        for(int right = 0;right < s.size();right++){\\n            freqMap[s[right]]++;\\n            currWindowSize++;\\n            \\n            maxFreqChar = max(maxFreqChar,freqMap[s[right]]);\\n            \\n            while(currWindowSize - maxFreqChar > k){\\n                // INVALID WINDOW\\n                currWindowSize--;\\n                freqMap[s[left]]--;\\n                left++;\\n            }\\n\\n            if(currWindowSize - maxFreqChar <= k){\\n                maxLengthSubstr = max(maxLengthSubstr,currWindowSize);\\n            }\\n\\n        }\\n        return maxLengthSubstr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"longest-repeating-character-replacement","has_notes":false,"flag_type":1,"frontend_id":397},{"id":1803006472,"question_id":424,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760588314,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/1803006472/","is_pending":"Not Pending","title":"Longest Repeating Character Replacement","memory":"10.9 MB","code":"class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int maxFreqChar = 0,maxLengthSubstr = 0,currWindowSize = 0,left=0;\\n        unordered_map<char,int>freqMap; // WORST CASE -> 26 size O(1)\\n\\n        for(int right = 0;right < s.size();right++){\\n            freqMap[s[right]]++;\\n            currWindowSize++;\\n            \\n            maxFreqChar = max(maxFreqChar,freqMap[s[right]]);\\n            \\n            while(currWindowSize - maxFreqChar > k){\\n                // INVALID WINDOW\\n                currWindowSize--;\\n                freqMap[s[left]]--;\\n                left++;\\n            }\\n\\n            if(currWindowSize - maxFreqChar <= k){\\n                maxLengthSubstr = max(maxLengthSubstr,currWindowSize);\\n            }\\n\\n        }\\n        return maxLengthSubstr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"longest-repeating-character-replacement","has_notes":false,"flag_type":1,"frontend_id":396},{"id":1802997615,"question_id":424,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760587503,"status":10,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/1802997615/","is_pending":"Not Pending","title":"Longest Repeating Character Replacement","memory":"11.1 MB","code":"class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        int maxFreqChar = 0,maxLengthSubstr = 0,currWindowSize = 0,left=0;\\n        unordered_map<char,int>freqMap; // WORST CASE -> 26 size O(1)\\n\\n        for(int right = 0;right < s.size();right++){\\n            freqMap[s[right]]++;\\n            currWindowSize++;\\n            for(auto & iterator:freqMap){\\n                maxFreqChar = max(maxFreqChar,iterator.second);\\n            }\\n            while(currWindowSize - maxFreqChar > k){\\n                // INVALID WINDOW\\n                currWindowSize--;\\n                freqMap[s[left]]--;\\n                left++;\\n            }\\n            for(auto & iterator:freqMap){\\n                maxFreqChar = max(maxFreqChar,iterator.second);\\n            }\\n\\n            if(currWindowSize - maxFreqChar <= k){\\n                maxLengthSubstr = max(maxLengthSubstr,currWindowSize);\\n            }\\n\\n        }\\n        return maxLengthSubstr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"longest-repeating-character-replacement","has_notes":false,"flag_type":1,"frontend_id":395},{"id":1802977890,"question_id":424,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760585557,"status":10,"status_display":"Accepted","runtime":"31 ms","url":"/submissions/detail/1802977890/","is_pending":"Not Pending","title":"Longest Repeating Character Replacement","memory":"20.1 MB","code":"class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_map<char, int> freq;\\n        priority_queue<pair<int,char>>maxHeap;\\n        int left = 0, maxFreq = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            freq[s[i]]++;\\n            maxHeap.push({freq[s[i]],s[i]});\\n            while(left <= i && (i - left + 1) - maxHeap.top().first > k){\\n                freq[s[left]]--;\\n                left++;\\n            }\\n            // Valid Window ==>  (windowSize - currentCharFreq) AKA (other\\n            // characters except current) <= k\\n            if ((i - left + 1) - maxHeap.top().first <= k) {\\n                maxFreq = max(maxFreq, i - left + 1);\\n            }\\n        }\\n\\n        return maxFreq;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"longest-repeating-character-replacement","has_notes":false,"flag_type":1,"frontend_id":394},{"id":1802383743,"question_id":424,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760531740,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1802383743/","is_pending":"Not Pending","title":"Longest Repeating Character Replacement","memory":"N/A","code":"class Solution {\\npublic:\\n    int characterReplacement(string s, int k) {\\n        unordered_map<char, int> freq;\\n        int left = 0, maxFreq = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            freq[s[i]]++;\\n            while((i - left + 1) - freq[s[i]] > k){\\n                freq[s[left]]--;\\n                left++;\\n            }\\n            // Valid Window ==>  (windowSize - currentCharFreq) AKA (other\\n            // characters except current) <= k\\n            if ((i - left + 1) - freq[s[i]] <= k) {\\n                maxFreq = max(maxFreq, i - left + 1);\\n            }\\n        }\\n\\n        return maxFreq;\\n    }\\n};","compare_result":"1111111111101101001001000000000010011001110011000","title_slug":"longest-repeating-character-replacement","has_notes":false,"flag_type":1,"frontend_id":393},{"id":1802178300,"question_id":49,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760512383,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1802178300/","is_pending":"Not Pending","title":"Group Anagrams","memory":"24.9 MB","code":"class Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,vector<string>>anagramList;\\n\\n        for(int i=0; i<strs.size();i++){\\n            string currentString = strs[i];\\n            sort(strs[i].begin(),strs[i].end());\\n            anagramList[strs[i]].push_back(currentString);\\n        }\\n        vector<vector<string>>ans;\\n        for(auto &iterator:anagramList){\\n            ans.push_back(iterator.second);\\n        }\\n        return ans;\\n\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"group-anagrams","has_notes":false,"flag_type":1,"frontend_id":392},{"id":1801765547,"question_id":33,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760469857,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1801765547/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"15 MB","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // 4 5 6 7 0 1 2\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n\\n            if(nums[mid]==target)return mid;\\n            else if(nums[mid] <= nums[end]){\\n                if(nums[mid] <= target && target <= nums[end]){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n            }else{\\n                if(nums[start] <= target && target <= nums[mid]){\\n                    end = mid-1;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":391}],"has_next":true,"last_key":""}'
2026-01-10 09:24:29,173 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:29,176 [INFO] __main__.py:245 - Writing linked-list-cycle/2025-10-18 11.16.56 - Accepted - runtime 4ms - memory 11.7MB.cpp
2026-01-10 09:24:29,177 [INFO] __main__.py:245 - Writing linked-list-cycle/2025-10-18 11.12.02 - Accepted - runtime 8ms - memory 11.9MB.cpp
2026-01-10 09:24:29,178 [INFO] __main__.py:188 - Skipping linked-list-cycle 2025-10-18 11.10.13 because its status is 'Wrong Answer'
2026-01-10 09:24:29,470 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:29,472 [INFO] __main__.py:245 - Writing reverse-linked-list/2025-10-17 11.08.37 - Accepted - runtime 0ms - memory 13.3MB.cpp
2026-01-10 09:24:29,474 [INFO] __main__.py:188 - Skipping reverse-linked-list 2025-10-17 11.06.49 because its status is 'Compile Error'
2026-01-10 09:24:32,067 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:32,070 [INFO] __main__.py:245 - Writing insert-interval/2025-10-17 10.29.09 - Accepted - runtime 3ms - memory 21.6MB.cpp
2026-01-10 09:24:32,070 [INFO] __main__.py:245 - Writing insert-interval/2025-10-17 10.28.49 - Accepted - runtime 6ms - memory 21.6MB.cpp
2026-01-10 09:24:32,071 [INFO] __main__.py:245 - Writing insert-interval/2025-10-17 09.47.27 - Accepted - runtime 0ms - memory 21.8MB.cpp
2026-01-10 09:24:32,071 [INFO] __main__.py:188 - Skipping insert-interval 2025-10-17 09.44.47 because its status is 'Wrong Answer'
2026-01-10 09:24:32,383 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:32,386 [INFO] __main__.py:245 - Writing best-time-to-buy-and-sell-stock/2025-10-17 08.35.33 - Accepted - runtime 0ms - memory 97.3MB.cpp
2026-01-10 09:24:33,939 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:33,942 [INFO] __main__.py:245 - Writing longest-palindromic-substring/2025-10-16 19.36.59 - Accepted - runtime 7ms - memory 12MB.cpp
2026-01-10 09:24:34,292 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:34,294 [INFO] __main__.py:245 - Writing valid-palindrome/2025-10-16 17.56.47 - Accepted - runtime 0ms - memory 9.9MB.cpp
2026-01-10 09:24:34,295 [INFO] __main__.py:188 - Skipping valid-palindrome 2025-10-16 17.56.15 because its status is 'Runtime Error'
2026-01-10 09:24:35,074 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:35,076 [INFO] __main__.py:245 - Writing longest-repeating-character-replacement/2025-10-16 09.57.24 - Accepted - runtime 4ms - memory 11MB.cpp
2026-01-10 09:24:35,077 [INFO] __main__.py:245 - Writing longest-repeating-character-replacement/2025-10-16 09.48.34 - Accepted - runtime 10ms - memory 10.9MB.cpp
2026-01-10 09:24:35,077 [INFO] __main__.py:245 - Writing longest-repeating-character-replacement/2025-10-16 09.35.03 - Accepted - runtime 14ms - memory 11.1MB.cpp
2026-01-10 09:24:35,078 [INFO] __main__.py:245 - Writing longest-repeating-character-replacement/2025-10-16 09.02.37 - Accepted - runtime 31ms - memory 20.1MB.cpp
2026-01-10 09:24:35,078 [INFO] __main__.py:188 - Skipping longest-repeating-character-replacement 2025-10-15 18.05.40 because its status is 'Wrong Answer'
2026-01-10 09:24:36,498 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:36,500 [INFO] __main__.py:245 - Writing group-anagrams/2025-10-15 12.43.03 - Accepted - runtime 15ms - memory 24.9MB.cpp
2026-01-10 09:24:36,808 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:36,811 [INFO] __main__.py:245 - Writing search-in-rotated-sorted-array/2025-10-15 00.54.17 - Accepted - runtime 0ms - memory 15MB.cpp
2026-01-10 09:24:41,815 [DEBUG] leetcode.py:150 - Exporting submissions from 160 to 180
2026-01-10 09:24:47,999 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=160&limit=20 HTTP/1.1" 200 None
2026-01-10 09:24:48,000 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1801764926,"question_id":33,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760469811,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1801764926/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // 4 5 6 7 0 1 2\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n\\n            if(nums[mid]==target)return mid;\\n            else if(nums[mid] <= nums[end]){\\n                if(nums[mid] <= target && target <= nums[end]){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n            }else{\\n                if(nums[mid] <= target && target <= nums[end]){\\n                    end = mid-1;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};","compare_result":"1111111111111111111111111011111111111100011111111010111100110111100111111111111101111110101111111111011111111111111110111111111101111101111111111111110111111101111111001011010110100101110111111111","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":390},{"id":1801760182,"question_id":33,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760469435,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1801760182/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // 4 5 6 7 0 1 2\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n\\n            if(nums[mid]==target)return mid;\\n            else if(nums[mid] < nums[end]){\\n                if(nums[mid]>=target && nums[end] <= target){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n            }else{\\n                if(nums[mid]<=target && nums[start] >= target){\\n                    end = mid-1;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};","compare_result":"1111111101111111111101111011111101111000011110001000110000010111000010100001011001110110101001111101011101111110011000111011101101010101110101100010110001111101111110001010000110100101110111101110","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":389},{"id":1801754060,"question_id":33,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760468978,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1801754060/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // 4 5 6 7 0 1 2\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] < nums[end]){\\n                if(nums[mid]>target && nums[end] <= target){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n            }else{\\n                if(nums[mid]<target && nums[start] >= target){\\n                    end = mid-1;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n        }\\n        if(end>=0 && end < nums.size() && nums[end]==target)return end;\\n\\n        return -1;\\n    }\\n};","compare_result":"1111110101111011110101111010110101110000001000000000100000010011000010100000000001000100000001111101010101111110010000111011101101010101110101000010110001111101110110001010000110100101110111101110","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":388},{"id":1801753201,"question_id":33,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760468913,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1801753201/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        // 4 5 6 7 0 1 2\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] < nums[end]){\\n                if(nums[mid]>target && nums[end] <= target){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n            }else{\\n                if(nums[mid]<target && nums[start] >= target){\\n                    end = mid-1;\\n                }else{\\n                    start = mid+1;\\n                }\\n            }\\n        }\\n        if(nums[end]==target)return end;\\n\\n        return -1;\\n    }\\n};","compare_result":"1111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":387},{"id":1801717361,"question_id":153,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760466529,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1801717361/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"14 MB","code":"class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < nums[end]){\\n                end = mid;\\n            }else if(nums[mid] >= nums[end]){\\n                start = mid+1;\\n            }\\n        }\\n        return nums[end];\\n        // 3 4 5 1 2\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":386},{"id":1801710231,"question_id":153,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760466142,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1801710231/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"14.1 MB","code":"class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < nums[end]){\\n                end = mid;\\n            }else if(nums[mid] >= nums[end]){\\n                start = mid+1;\\n            }\\n        }\\n        return nums[end];\\n        // 3 4 5 1 2\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":385},{"id":1801709878,"question_id":153,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760466122,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1801709878/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < nums[end]){\\n                end = mid-1;\\n            }else if(nums[mid] >= nums[end]){\\n                start = mid+1;\\n            }\\n        }\\n        return nums[start];\\n        // 3 4 5 1 2\\n    }\\n};","compare_result":"111111101110111010101111000011000111111110110111111101011111010111010110011110110111110001111001010111111011011011100000100111110001100011101111011110","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":384},{"id":1801709389,"question_id":153,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760466095,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1801709389/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"14.3 MB","code":"class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start < end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid] < nums[end]){\\n                end = mid;\\n            }else if(nums[mid] >= nums[end]){\\n                start = mid+1;\\n            }\\n        }\\n        return nums[end];\\n        // 3 4 5 1 2\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":383},{"id":1801682872,"question_id":54,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1760464676,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1801682872/","is_pending":"Not Pending","title":"Spiral Matrix","memory":"9.4 MB","code":"class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int startRow = 0, endRow = matrix.size() - 1, startCol = 0,\\n            endCol = matrix[0].size() - 1;\\n        vector<int> ans;\\n        while (startRow <= endRow && startCol <= endCol) {\\n            for (int i = startCol; i <= endCol; i++) {\\n                ans.push_back(matrix[startRow][i]);\\n            }\\n            startRow++;\\n            if(startRow <= endRow && startCol <= endCol){\\n            for (int i = startRow; i <= endRow; i++) {\\n                ans.push_back(matrix[i][endCol]);\\n            }\\n            endCol--;}\\n            if(startRow <= endRow && startCol <= endCol){\\n            for (int i = endCol; i >= startCol; i--) {\\n                ans.push_back(matrix[endRow][i]);\\n            }}\\n            endRow--;\\n            if(startRow <= endRow && startCol <= endCol){\\n            for (int i = endRow; i >= startRow; i--) {\\n                ans.push_back(matrix[i][startCol]);\\n            }}\\n            startCol++;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"spiral-matrix","has_notes":false,"flag_type":1,"frontend_id":382},{"id":1799637103,"question_id":209,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760294006,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1799637103/","is_pending":"Not Pending","title":"Minimum Size Subarray Sum","memory":"32.1 MB","code":"class Solution {\\npublic:\\n    int minSubArrayLen(int target, vector<int>& nums) {\\n        int left = 0,right = 0,currentSum = 0,minLength = INT_MAX;\\n\\n        while(right < nums.size()){\\n            currentSum += nums[right];\\n            if(currentSum < target){\\n                right++;continue;\\n            }\\n            while(left <= right && currentSum >= target){\\n                minLength = min(minLength,right-left+1);\\n                currentSum -= nums[left];\\n                left++;\\n            }\\n            right++;            \\n        }\\n\\n        if(minLength == INT_MAX)return 0;\\n        return minLength;\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"minimum-size-subarray-sum","has_notes":false,"flag_type":1,"frontend_id":381},{"id":1799590549,"question_id":73,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760291124,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1799590549/","is_pending":"Not Pending","title":"Set Matrix Zeroes","memory":"18.6 MB","code":"class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool row0 = false, col0 = false;\\n        for (int col = 0; col < matrix[0].size(); col++) {\\n            if (matrix[0][col] == 0){\\n                row0 = true;\\n                break;\\n            }\\n        }\\n        for (int row = 0; row < matrix.size(); row++) {\\n            if (matrix[row][0] == 0){\\n                col0 = true;\\n                break;\\n            }\\n        }\\n\\n        for(int row = 1; row<matrix.size();row++){\\n            for(int col = 1; col<matrix[0].size();col++){\\n                if(matrix[row][col] == 0){\\n                    matrix[0][col] = 0;\\n                    matrix[row][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1; j<matrix[0].size();j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(row0){\\n            for(int i=0;i<matrix[0].size();i++){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if(col0){\\n            for(int i=0;i<matrix.size();i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"set-matrix-zeroes","has_notes":false,"flag_type":1,"frontend_id":380},{"id":1799557978,"question_id":56,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760289165,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1799557978/","is_pending":"Not Pending","title":"Merge Intervals","memory":"24 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int currentInterval = 0, finalMax = 0;\\n        sort(intervals.begin(), intervals.end());\\n        \\n        while (currentInterval < intervals.size()) {\\n            if (ans.empty()) {\\n                ans.push_back(intervals[0]);\\n                currentInterval++;\\n                continue;\\n            }\\n            if (ans.back()[1] >= intervals[currentInterval][0]) {\\n                while (currentInterval < intervals.size() &&\\n                       ans.back()[1] >= intervals[currentInterval][0]) {\\n\\n                    ans.back()[1] = max(ans.back()[1], intervals[currentInterval][1]);\\n                    currentInterval++;\\n                }\\n            } else {\\n                ans.push_back(intervals[currentInterval]);\\n                currentInterval++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":379},{"id":1799557701,"question_id":56,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760289148,"status":10,"status_display":"Accepted","runtime":"140 ms","url":"/submissions/detail/1799557701/","is_pending":"Not Pending","title":"Merge Intervals","memory":"23.8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int currentInterval = 0, finalMax = 0;\\n        sort(intervals.begin(), intervals.end());\\n        for (auto& it : intervals) {\\n            cout << \\"[\\";\\n            for (auto element : it) {\\n                cout << element << \\",\\";\\n            }\\n            cout << \\"],\\";\\n        }\\n        while (currentInterval < intervals.size()) {\\n            if (ans.empty()) {\\n                ans.push_back(intervals[0]);\\n                currentInterval++;\\n                continue;\\n            }\\n            if (ans.back()[1] >= intervals[currentInterval][0]) {\\n                while (currentInterval < intervals.size() &&\\n                       ans.back()[1] >= intervals[currentInterval][0]) {\\n\\n                    ans.back()[1] = max(ans.back()[1], intervals[currentInterval][1]);\\n                    currentInterval++;\\n                }\\n            } else {\\n                ans.push_back(intervals[currentInterval]);\\n                currentInterval++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":378},{"id":1799548566,"question_id":56,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760288591,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1799548566/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> ans;\\n        int currentInterval = 0, finalMax = 0;\\n        sort(intervals.begin(),intervals.end());\\n        while (currentInterval < intervals.size()) {\\n            if (ans.empty()) {\\n                ans.push_back(intervals[0]);\\n                currentInterval++;\\n                continue;\\n            }\\n            if (ans.back()[1] >= intervals[currentInterval][0]) {\\n                finalMax = ans.back()[1];\\n                while (currentInterval < intervals.size() &&\\n                       ans.back()[1] >= intervals[currentInterval][0]) {\\n                    finalMax =\\n                        max(ans.back()[1], intervals[currentInterval][1]);\\n                    currentInterval++;\\n                }\\n                ans.back()[1] = max(ans.back()[1], finalMax);\\n            } else {\\n                ans.push_back(intervals[currentInterval]);\\n                currentInterval++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111101111111111111111111101111111111111111111111111111111111101111111111111111110111111111111111111111101101111111001010011011111110000000000000000000011111","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":377},{"id":1798893782,"question_id":4055,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760237737,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1798893782/","is_pending":"Not Pending","title":"Longest Balanced Substring I","memory":"N/A","code":"class Solution {\\n    bool is_balanced(string& s, int left, int right) {\\n        unordered_map<char, int> freq;\\n        for (int i = left; i <= right; i++) {\\n            freq[s[i]]++;\\n        }\\n        int prev = -1;\\n        for (auto& it : freq) {\\n            if (prev == -1) {\\n                prev = it.second;\\n                continue;\\n            }\\n            if (prev != it.second) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int longestBalanced(string s) {\\n\\n        if(s.size()==1){\\n            return 1;\\n        }\\n\\n        int left = 0, right = 0, longest = 0;\\n        for (int i = 0; i < s.size(); i++) {\\n            for (int j = i+1; j < s.size(); j++) {\\n                if (is_balanced(s, i, j)) {\\n                    longest = max(longest, j - i + 1);\\n                }\\n            }\\n        }\\n\\n        return longest;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"longest-balanced-substring-i","has_notes":false,"flag_type":1,"frontend_id":376},{"id":1798862549,"question_id":4068,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760236486,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1798862549/","is_pending":"Not Pending","title":"Sum of Elements With Frequency Divisible by K","memory":"26.3 MB","code":"class Solution {\\npublic:\\n    int sumDivisibleByK(vector<int>& nums, int k) {\\n        unordered_map<int,int>freq;\\n\\n        for(int i=0; i<nums.size();i++){\\n            freq[nums[i]]++;\\n        }\\n\\n        int totalSum=0;\\n        for(auto &it:freq){\\n            if(it.second % k == 0){\\n                totalSum += (it.first * it.second);\\n            }\\n        }\\n        return totalSum;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"sum-of-elements-with-frequency-divisible-by-k","has_notes":false,"flag_type":1,"frontend_id":375},{"id":1798390836,"question_id":4059,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760194933,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1798390836/","is_pending":"Not Pending","title":"Design Exam Scores Tracker","memory":"N/A","code":"class ExamTracker {\\n    unordered_map<int,int>timeScore;\\n    // {time,score}\\npublic:\\n    ExamTracker() {\\n        \\n    }\\n    \\n    void record(int time, int score) {\\n        timeScore[time]=score;\\n    }\\n    \\n    long long totalScore(int startTime, int endTime) {\\n        long long ans=0;\\n        for(int i=startTime; i<=endTime;i++){\\n            if(timeScore.count(i)){\\n                ans+=timeScore[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your ExamTracker object will be instantiated and called as such:\\n * ExamTracker* obj = new ExamTracker();\\n * obj->record(time,score);\\n * long long param_2 = obj->totalScore(startTime,endTime);\\n */","compare_result":"100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"design-exam-scores-tracker","has_notes":false,"flag_type":1,"frontend_id":374},{"id":1798364670,"question_id":4003,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760194222,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1798364670/","is_pending":"Not Pending","title":"Longest Fibonacci Subarray","memory":"102.8 MB","code":"class Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        if(nums.size()<=2)return nums.size();\\n        int maxCount = 0,count=2;\\n\\n        for(int i=2;i<nums.size();i++){\\n            if(nums[i-1]+nums[i-2] == nums[i])count++;\\n            else{\\n                count=2;\\n            }\\n            maxCount = max(maxCount,count);\\n        }\\n        return maxCount;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-fibonacci-subarray","has_notes":false,"flag_type":1,"frontend_id":373},{"id":1798350532,"question_id":4052,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760193876,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1798350532/","is_pending":"Not Pending","title":"Equal Score Substrings","memory":"10.1 MB","code":"class Solution {\\npublic:\\n    bool scoreBalance(string s) {\\n        vector<int>prefix(s.size());\\n        vector<int>suffix(s.size());\\n\\n        for(int i=0;i<s.size();i++){\\n            if(i==0){\\n                prefix[i]=(s[i]-\'a\')+1;continue;\\n            }\\n            prefix[i]=((s[i]-\'a\')+1)+prefix[i-1];\\n        }\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(i==s.size()-1){\\n                suffix[i]=(s[i]-\'a\')+1;\\n                continue;\\n            }\\n            suffix[i]=((s[i]-\'a\')+1)+suffix[i+1];\\n        }\\n\\n        for(int i=0; i<s.size();i++){\\n            if(i==0){\\n                if(prefix[i]==suffix[i+1])return true;\\n                continue;\\n            }\\n            if(i==s.size()-1){\\n                if(prefix[i]==0){return true;}\\n                continue;\\n            }\\n            if(prefix[i]==suffix[i+1])return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"equal-score-substrings","has_notes":false,"flag_type":1,"frontend_id":372},{"id":1797964425,"question_id":48,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760163818,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1797964425/","is_pending":"Not Pending","title":"Rotate Image","memory":"10 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int row=0;row<matrix.size();row++){\\n            for(int col = row; col <matrix[0].size(); col++){\\n                swap(matrix[row][col],matrix[col][row]);\\n            }\\n        }\\n        for(int row = 0; row<matrix.size();row++){\\n            reverse(matrix[row].begin(),matrix[row].end());\\n        }\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"rotate-image","has_notes":false,"flag_type":1,"frontend_id":371}],"has_next":true,"last_key":""}'
2026-01-10 09:24:48,002 [INFO] __main__.py:188 - Skipping search-in-rotated-sorted-array 2025-10-15 00.53.31 because its status is 'Wrong Answer'
2026-01-10 09:24:48,005 [INFO] __main__.py:188 - Skipping search-in-rotated-sorted-array 2025-10-15 00.47.15 because its status is 'Wrong Answer'
2026-01-10 09:24:48,008 [INFO] __main__.py:188 - Skipping search-in-rotated-sorted-array 2025-10-15 00.39.38 because its status is 'Wrong Answer'
2026-01-10 09:24:48,010 [INFO] __main__.py:188 - Skipping search-in-rotated-sorted-array 2025-10-15 00.38.33 because its status is 'Runtime Error'
2026-01-10 09:24:48,309 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:48,311 [INFO] __main__.py:245 - Writing find-minimum-in-rotated-sorted-array/2025-10-14 23.58.49 - Accepted - runtime 0ms - memory 14MB.cpp
2026-01-10 09:24:48,312 [INFO] __main__.py:245 - Writing find-minimum-in-rotated-sorted-array/2025-10-14 23.52.22 - Accepted - runtime 0ms - memory 14.1MB.cpp
2026-01-10 09:24:48,312 [INFO] __main__.py:188 - Skipping find-minimum-in-rotated-sorted-array 2025-10-14 23.52.02 because its status is 'Wrong Answer'
2026-01-10 09:24:48,313 [INFO] __main__.py:245 - Writing find-minimum-in-rotated-sorted-array/2025-10-14 23.51.35 - Accepted - runtime 0ms - memory 14.3MB.cpp
2026-01-10 09:24:48,625 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:48,627 [INFO] __main__.py:245 - Writing spiral-matrix/2025-10-14 23.27.56 - Accepted - runtime 0ms - memory 9.4MB.cpp
2026-01-10 09:24:48,977 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:48,979 [INFO] __main__.py:245 - Writing minimum-size-subarray-sum/2025-10-13 00.03.26 - Accepted - runtime 0ms - memory 32.1MB.cpp
2026-01-10 09:24:49,291 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:49,294 [INFO] __main__.py:245 - Writing set-matrix-zeroes/2025-10-12 23.15.24 - Accepted - runtime 0ms - memory 18.6MB.cpp
2026-01-10 09:24:50,810 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:50,812 [INFO] __main__.py:245 - Writing merge-intervals/2025-10-12 22.42.45 - Accepted - runtime 7ms - memory 24MB.cpp
2026-01-10 09:24:50,813 [INFO] __main__.py:245 - Writing merge-intervals/2025-10-12 22.42.28 - Accepted - runtime 140ms - memory 23.8MB.cpp
2026-01-10 09:24:50,813 [INFO] __main__.py:188 - Skipping merge-intervals 2025-10-12 22.33.11 because its status is 'Wrong Answer'
2026-01-10 09:24:50,813 [INFO] __main__.py:188 - Skipping longest-balanced-substring-i 2025-10-12 08.25.37 because its status is 'Time Limit Exceeded'
2026-01-10 09:24:51,240 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:51,243 [INFO] __main__.py:245 - Writing sum-of-elements-with-frequency-divisible-by-k/2025-10-12 08.04.46 - Accepted - runtime 0ms - memory 26.3MB.cpp
2026-01-10 09:24:51,244 [INFO] __main__.py:188 - Skipping design-exam-scores-tracker 2025-10-11 20.32.13 because its status is 'Time Limit Exceeded'
2026-01-10 09:24:51,763 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:51,766 [INFO] __main__.py:245 - Writing longest-fibonacci-subarray/2025-10-11 20.20.22 - Accepted - runtime 4ms - memory 102.8MB.cpp
2026-01-10 09:24:52,099 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:52,101 [INFO] __main__.py:245 - Writing equal-score-substrings/2025-10-11 20.14.36 - Accepted - runtime 0ms - memory 10.1MB.cpp
2026-01-10 09:24:52,427 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:52,428 [INFO] __main__.py:245 - Writing rotate-image/2025-10-11 11.53.38 - Accepted - runtime 0ms - memory 10MB.cpp
2026-01-10 09:24:57,430 [DEBUG] leetcode.py:150 - Exporting submissions from 180 to 200
2026-01-10 09:24:58,293 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=180&limit=20 HTTP/1.1" 200 None
2026-01-10 09:24:58,305 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1797933499,"question_id":560,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760161577,"status":10,"status_display":"Accepted","runtime":"35 ms","url":"/submissions/detail/1797933499/","is_pending":"Not Pending","title":"Subarray Sum Equals K","memory":"45.2 MB","code":"class Solution {\\npublic:\\n    int subarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>prefixSum;\\n        prefixSum[0]++;\\n        int count=0;\\n        int currentSum = 0;\\n        for(int i=0; i<nums.size();i++){\\n            currentSum += nums[i];\\n            if(prefixSum.count(currentSum - k)){\\n                count += prefixSum[currentSum - k];\\n            }\\n            prefixSum[currentSum]++;\\n        }\\n        return count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subarray-sum-equals-k","has_notes":false,"flag_type":1,"frontend_id":370},{"id":1797886206,"question_id":238,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760157460,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1797886206/","is_pending":"Not Pending","title":"Product of Array Except Self","memory":"40.1 MB","code":"class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int size = nums.size();\\n        vector<int>ans(size);\\n\\n        // Store Prefix in ans\\n        for(int i=0;i<size;i++){\\n            if(i==0){\\n                ans[i] = nums[i];\\n                continue;\\n            }\\n            ans[i] = ans[i-1]*nums[i];\\n        }\\n\\n        int suffix = 1;\\n        for(int i=size-1;i>=0;i--){\\n            if(i==size-1){\\n                ans[i] = ans[i-1];\\n                suffix = nums[i];\\n                continue;\\n            }\\n            if(i==0){\\n                ans[i]=suffix;\\n                break;\\n            }\\n            ans[i] = ans[i-1]*suffix;\\n            suffix = suffix * nums[i];\\n        }\\n        return ans;\\n\\n\\n    }\\n};","compare_result":"111111111111111111111111","title_slug":"product-of-array-except-self","has_notes":false,"flag_type":1,"frontend_id":369},{"id":1797873808,"question_id":238,"lang":"cpp","lang_name":"C++","time":"2\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1760156196,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1797873808/","is_pending":"Not Pending","title":"Product of Array Except Self","memory":"42.3 MB","code":"class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefix(nums.size());\\n        vector<int>suffix(nums.size());\\n        for(int i=0; i<nums.size();i++){\\n            if(i==0){\\n                prefix[0] = nums[0];\\n                continue;\\n            }\\n            prefix[i] = prefix[i-1] * nums[i];\\n        }\\n        for(int i=nums.size()-1; i>=0;i--){\\n            if(i==nums.size()-1){\\n                suffix[nums.size()-1] = nums[nums.size()-1];\\n                continue;\\n            }\\n            suffix[i] = suffix[i+1] * nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            if(i-1 < 0){\\n                ans[i]=suffix[i+1];\\n                continue;\\n            }\\n            if(i+1 >= nums.size()){\\n                ans[i]=prefix[i-1];\\n                continue;\\n            }\\n            ans[i] = prefix[i-1] * suffix[i+1];\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111","title_slug":"product-of-array-except-self","has_notes":false,"flag_type":1,"frontend_id":368},{"id":1795921751,"question_id":3,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759978811,"status":10,"status_display":"Accepted","runtime":"23 ms","url":"/submissions/detail/1795921751/","is_pending":"Not Pending","title":"Longest Substring Without Repeating Characters","memory":"14.3 MB","code":"class Solution {\\npublic:\\n    int lengthOfLongestSubstring(string s) {\\n        if(s.size()<=1)return s.size();\\n        int left = 0,right=0;\\n        unordered_set<int>set;\\n        int maxLength=-1;\\n\\n        while(right < s.size()){\\n            while(set.find(s[right]) != set.end()){\\n                // FOUND IN SET\\n                set.erase(s[left]);\\n                left++;  \\n            }\\n            set.insert(s[right]);\\n            maxLength = max(maxLength,right-left+1);\\n            right++;\\n        }\\n        return maxLength;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-substring-without-repeating-characters","has_notes":false,"flag_type":1,"frontend_id":367},{"id":1795901587,"question_id":11,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759976346,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1795901587/","is_pending":"Not Pending","title":"Container With Most Water","memory":"63 MB","code":"class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        // Formula: minHeight * (rightIndex - leftIndex)\\n        int maxArea = -1;\\n        int start = 0 ,end = height.size()-1;\\n\\n        while(start < end){\\n            int currentArea = min(height[start],height[end]) * (end - start);\\n            maxArea = max(maxArea,currentArea);\\n            if(height[start] < height[end] ){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111","title_slug":"container-with-most-water","has_notes":false,"flag_type":1,"frontend_id":366},{"id":1795899462,"question_id":11,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759976089,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1795899462/","is_pending":"Not Pending","title":"Container With Most Water","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxArea(vector<int>& height) {\\n        // Formula: minHeight * (rightIndex - leftIndex)\\n        int maxArea = -1;\\n        int start = 0 ,end = height.size()-1;\\n\\n        while(start < end){\\n            int currentArea = min(height[start],height[end]) * (end - start);\\n            maxArea = max(maxArea,currentArea);\\n            if(height[start+1] > height[end-1] ){\\n                start++;\\n            }else{\\n                end--;\\n            }\\n        }\\n        return maxArea;\\n    }\\n};","compare_result":"11111111010101000100100001011110100000010001000000000000000000111","title_slug":"container-with-most-water","has_notes":false,"flag_type":1,"frontend_id":365},{"id":1795886376,"question_id":1,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759974377,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1795886376/","is_pending":"Not Pending","title":"Two Sum","memory":"14.8 MB","code":"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        unordered_map<int,int>map;\\n        map[nums[0]]=0;\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            if(map.find(target - nums[i]) != map.end()){\\n                return {map[target-nums[i]],i};\\n            }\\n            map[nums[i]] = i;\\n        }\\n        return {-1,-1};\\n\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"two-sum","has_notes":false,"flag_type":1,"frontend_id":364},{"id":1791673991,"question_id":4033,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759633445,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1791673991/","is_pending":"Not Pending","title":"Longest Subsequence With Non-Zero Bitwise XOR","memory":"171.3 MB","code":"class Solution {\\npublic:\\n    int longestSubsequence(vector<int>& nums) {\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        int totalXOR = 0,totalOR=0;\\n        for(int i=0; i<nums.size();i++){\\n            totalXOR ^= nums[i];\\n            totalOR |= nums[i];\\n        }\\n        if(totalXOR != 0){\\n            return nums.size();\\n        }\\n        if(totalOR == 0)return 0;\\n        return nums.size()-1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-subsequence-with-non-zero-bitwise-xor","has_notes":false,"flag_type":1,"frontend_id":363},{"id":1791670653,"question_id":4033,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759633328,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1791670653/","is_pending":"Not Pending","title":"Longest Subsequence With Non-Zero Bitwise XOR","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestSubsequence(vector<int>& nums) {\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        if(nums.size() == 1){\\n            return 1;\\n        }\\n        int totalXOR = 0,totalOR=0;\\n        for(int i=0; i<nums.size();i++){\\n            totalXOR ^= nums[i];\\n            totalOR |= nums[i];\\n        }\\n        if(totalXOR != 0){\\n            return nums.size();\\n        }\\n        if(totalOR == 0)return 0;\\n        return nums.size()-1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111","title_slug":"longest-subsequence-with-non-zero-bitwise-xor","has_notes":false,"flag_type":1,"frontend_id":362},{"id":1791662777,"question_id":4033,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759633044,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1791662777/","is_pending":"Not Pending","title":"Longest Subsequence With Non-Zero Bitwise XOR","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestSubsequence(vector<int>& nums) {\\n        if(nums.size() < 1){\\n            return 0;\\n        }\\n        if(nums.size() == 1){\\n            return 1;\\n        }\\n        int totalXOR = 0;\\n        for(int i=0; i<nums.size();i++){\\n            totalXOR ^= nums[i];\\n        }\\n        if(totalXOR != 0){\\n            return nums.size();\\n        }\\n        return nums.size()-1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111010111111111","title_slug":"longest-subsequence-with-non-zero-bitwise-xor","has_notes":false,"flag_type":1,"frontend_id":361},{"id":1791615925,"question_id":4058,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months","timestamp":1759631538,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1791615925/","is_pending":"Not Pending","title":"Compute Alternating Sum","memory":"32.7 MB","code":"class Solution {\\npublic:\\n    int alternatingSum(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return nums[0];\\n        }\\n\\n        int sum = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            if(i%2 == 0){\\n                sum+= nums[i];\\n            }else{\\n                sum -= nums[i];\\n            }\\n        }\\n        return sum;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"compute-alternating-sum","has_notes":false,"flag_type":1,"frontend_id":360},{"id":1784856495,"question_id":4015,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 1\xc2\xa0week","timestamp":1759029967,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1784856495/","is_pending":"Not Pending","title":"Split Array With Minimum Difference","memory":"N/A","code":"class Solution {\\npublic:\\n    long long splitArray(vector<int>& nums) {\\n        unordered_map<int,int>prefixSum;\\n        long long sum = 0;\\n        for(int i=0; i<nums.size();i++){\\n            sum += nums[i];\\n            prefixSum[i]+= sum;\\n        }\\n        int breakPoint = nums.size()-1;\\n        if(nums[0] > nums[1]){\\n             breakPoint = 0; \\n        }\\n        for(int i=0; i < nums.size()-1;i++){\\n            if(nums[i] > nums[i+1]){\\n                breakPoint = i;\\n                break;\\n            }else if(nums[i] == nums[i+1]){\\n                return -1;\\n            }\\n        }\\n\\n        for(int i=breakPoint; i<nums.size()-1;i++){\\n            if(nums[i] < nums[i+1]){\\n                return -1;\\n            }else if(nums[i]==nums[i+1]){\\n                return -1;\\n            }\\n        }\\n        long long maxAns = -1;\\n        long long breakPointIncreasing = abs(prefixSum[breakPoint]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint]));\\n\\n        \\n        maxAns = abs(breakPointIncreasing - breakpointDecreasing);\\n\\n        if(breakPoint != 0){\\n            long long breakPointIncreasing = abs(prefixSum[breakPoint-1]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint-1]));\\n        maxAns = min(maxAns,abs(breakPointIncreasing - breakpointDecreasing));\\n        }\\n        return maxAns;\\n        \\n        \\n    }\\n};","compare_result":"11110111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000","title_slug":"split-array-with-minimum-difference","has_notes":false,"flag_type":1,"frontend_id":359},{"id":1784853501,"question_id":4015,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 1\xc2\xa0week","timestamp":1759029850,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1784853501/","is_pending":"Not Pending","title":"Split Array With Minimum Difference","memory":"N/A","code":"class Solution {\\npublic:\\n    long long splitArray(vector<int>& nums) {\\n        unordered_map<int,int>prefixSum;\\n        long long sum = 0;\\n        for(int i=0; i<nums.size();i++){\\n            sum += nums[i];\\n            prefixSum[i]+= sum;\\n        }\\n        int breakPoint = nums.size()-1;\\n        if(nums[0] > nums[1]){\\n             breakPoint = 0; \\n        }\\n        for(int i=0; i < nums.size()-1;i++){\\n            if(nums[i] > nums[i+1]){\\n                breakPoint = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=breakPoint; i<nums.size()-1;i++){\\n            if(nums[i] < nums[i+1]){\\n                return -1;\\n            }\\n        }\\n        long long maxAns = -1;\\n        long long breakPointIncreasing = abs(prefixSum[breakPoint]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint]));\\n\\n        \\n        maxAns = abs(breakPointIncreasing - breakpointDecreasing);\\n\\n        if(breakPoint != 0){\\n            long long breakPointIncreasing = abs(prefixSum[breakPoint-1]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint-1]));\\n        maxAns = min(maxAns,abs(breakPointIncreasing - breakpointDecreasing));\\n        }\\n        return maxAns;\\n        \\n        \\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000","title_slug":"split-array-with-minimum-difference","has_notes":false,"flag_type":1,"frontend_id":358},{"id":1784852797,"question_id":4015,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 1\xc2\xa0week","timestamp":1759029822,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1784852797/","is_pending":"Not Pending","title":"Split Array With Minimum Difference","memory":"N/A","code":"class Solution {\\npublic:\\n    long long splitArray(vector<int>& nums) {\\n        unordered_map<int,int>prefixSum;\\n        long long sum = 0;\\n        for(int i=0; i<nums.size();i++){\\n            sum += nums[i];\\n            prefixSum[i]+= sum;\\n        }\\n        int breakPoint = nums.size()-1;\\n        if(nums[0] > nums[1]){\\n             breakPoint = 0; \\n        }\\n        for(int i=0; i < nums.size()-1;i++){\\n            if(nums[i] > nums[i+1]){\\n                breakPoint = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i=breakPoint; i<nums.size()-1;i++){\\n            if(nums[i] < nums[i+1]){\\n                return -1;\\n            }\\n        }\\n        long long maxAns = -1;\\n        long long breakPointIncreasing = abs(prefixSum[breakPoint]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint]));\\n        if(breakPoint == 0){\\n            breakPointIncreasing = 0;\\n            breakpointDecreasing = prefixSum[nums.size()-1];\\n        }\\n        \\n        maxAns = abs(breakPointIncreasing - breakpointDecreasing);\\n\\n        if(breakPoint != 0){\\n            long long breakPointIncreasing = abs(prefixSum[breakPoint-1]); \\n        long long breakpointDecreasing = abs(prefixSum[nums.size()-1] - (prefixSum[breakPoint-1]));\\n        maxAns = min(maxAns,abs(breakPointIncreasing - breakpointDecreasing));\\n        }\\n        return maxAns;\\n        \\n        \\n    }\\n};","compare_result":"11101110000001000100100001000111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000","title_slug":"split-array-with-minimum-difference","has_notes":false,"flag_type":1,"frontend_id":357},{"id":1784784082,"question_id":4039,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 1\xc2\xa0week","timestamp":1759027359,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1784784082/","is_pending":"Not Pending","title":"Compute Decimal Representation","memory":"9.7 MB","code":"class Solution {\\npublic:\\n    vector<int> decimalRepresentation(int n) {\\n        if(n>=1 && n<=9)return {n};\\n        int power = 0;\\n        vector<int>ans;\\n        while(n!=0){\\n            int remainder = n%10;\\n            if(remainder != 0){\\n                if(power == 0){\\n                    ans.push_back(remainder);\\n                }else{\\n                    int pushArr = remainder * (pow(10,power));\\n                    ans.push_back(pushArr);\\n                }\\n            }\\n            power++;\\n            n/=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"compute-decimal-representation","has_notes":false,"flag_type":1,"frontend_id":356},{"id":1784324176,"question_id":4053,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 1\xc2\xa0week","timestamp":1758985826,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1784324176/","is_pending":"Not Pending","title":"Majority Frequency Characters","memory":"9.2 MB","code":"class Solution {\\npublic:\\n    string majorityFrequencyGroup(string s) {\\n        if(s.size() == 1)return s;\\n        int freq[26] = {0};\\n        for(int i=0; i<s.size(); i++){\\n            freq[s[i] - \'a\']++;\\n        }\\n        string ans = \\"\\";\\n        map<int,string>map;\\n        for(int i=0; i<26; i++){\\n            if(freq[i] == 0)continue;\\n            map[freq[i]]+= (char)(i+\'a\');\\n        }\\n        unsigned maxLen = 0;\\n        for(auto &it: map){\\n            if(it.second.size() >= maxLen ){\\n                maxLen = it.second.size();\\n                ans = it.second;\\n            }\\n        }\\n\\n        \\n        return ans;\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"majority-frequency-characters","has_notes":false,"flag_type":1,"frontend_id":355},{"id":1783172243,"question_id":141,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758880716,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1783172243/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"11.8 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        if(head == nullptr || head->next == nullptr){\\n            return false;\\n        }\\n        ListNode* slow = head;\\n        ListNode* fast = head->next;\\n        while(fast != nullptr && fast->next != nullptr ){\\n            if(slow == fast){\\n                return true;\\n            }\\n            slow = slow->next;\\n            fast = fast -> next ->next;\\n        }\\n        return false;\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":354},{"id":1783114222,"question_id":141,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758875835,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1783114222/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"14.5 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        unordered_set<ListNode*>set;\\n        ListNode* curr = head;\\n        while(curr!=nullptr){\\n            if(set.find(curr) != set.end()){\\n                return 1;\\n            }\\n            set.insert(curr);\\n            curr = curr->next;\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":353},{"id":1781950806,"question_id":908,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758777684,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1781950806/","is_pending":"Not Pending","title":"Middle of the Linked List","memory":"10 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* middleNode(ListNode* head) {\\n        if(head->next == nullptr){\\n            return head;\\n        }\\n        ListNode* slow = head;\\n        ListNode* fast = head;\\n        while(fast != nullptr && fast->next != nullptr){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n        }\\n        return slow;\\n    }\\n};","compare_result":"111111111111111111111111111111111111","title_slug":"middle-of-the-linked-list","has_notes":false,"flag_type":1,"frontend_id":352},{"id":1777658668,"question_id":237,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758426238,"status":10,"status_display":"Accepted","runtime":"10 ms","url":"/submissions/detail/1777658668/","is_pending":"Not Pending","title":"Delete Node in a Linked List","memory":"12.4 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteNode(ListNode* node) {\\n        ListNode* nextElement = node->next;\\n        node->val = nextElement->val;\\n        node->next = nextElement->next;\\n        delete nextElement;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111","title_slug":"delete-node-in-a-linked-list","has_notes":false,"flag_type":1,"frontend_id":351}],"has_next":true,"last_key":""}'
2026-01-10 09:24:59,082 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:59,084 [INFO] __main__.py:245 - Writing subarray-sum-equals-k/2025-10-11 11.16.17 - Accepted - runtime 35ms - memory 45.2MB.cpp
2026-01-10 09:24:59,411 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:59,414 [INFO] __main__.py:245 - Writing product-of-array-except-self/2025-10-11 10.07.40 - Accepted - runtime 0ms - memory 40.1MB.cpp
2026-01-10 09:24:59,415 [INFO] __main__.py:245 - Writing product-of-array-except-self/2025-10-11 09.46.36 - Accepted - runtime 4ms - memory 42.3MB.cpp
2026-01-10 09:24:59,750 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:24:59,752 [INFO] __main__.py:245 - Writing longest-substring-without-repeating-characters/2025-10-09 08.30.11 - Accepted - runtime 23ms - memory 14.3MB.cpp
2026-01-10 09:25:00,227 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:00,229 [INFO] __main__.py:245 - Writing container-with-most-water/2025-10-09 07.49.06 - Accepted - runtime 0ms - memory 63MB.cpp
2026-01-10 09:25:00,230 [INFO] __main__.py:188 - Skipping container-with-most-water 2025-10-09 07.44.49 because its status is 'Wrong Answer'
2026-01-10 09:25:00,630 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:00,632 [INFO] __main__.py:245 - Writing two-sum/2025-10-09 07.16.17 - Accepted - runtime 0ms - memory 14.8MB.cpp
2026-01-10 09:25:01,037 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:01,039 [INFO] __main__.py:245 - Writing longest-subsequence-with-non-zero-bitwise-xor/2025-10-05 08.34.05 - Accepted - runtime 0ms - memory 171.3MB.cpp
2026-01-10 09:25:01,040 [INFO] __main__.py:188 - Skipping longest-subsequence-with-non-zero-bitwise-xor 2025-10-05 08.32.08 because its status is 'Wrong Answer'
2026-01-10 09:25:01,041 [INFO] __main__.py:188 - Skipping longest-subsequence-with-non-zero-bitwise-xor 2025-10-05 08.27.24 because its status is 'Wrong Answer'
2026-01-10 09:25:02,406 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:02,408 [INFO] __main__.py:245 - Writing compute-alternating-sum/2025-10-05 08.02.18 - Accepted - runtime 0ms - memory 32.7MB.cpp
2026-01-10 09:25:02,409 [INFO] __main__.py:188 - Skipping split-array-with-minimum-difference 2025-09-28 08.56.07 because its status is 'Wrong Answer'
2026-01-10 09:25:02,409 [INFO] __main__.py:188 - Skipping split-array-with-minimum-difference 2025-09-28 08.54.10 because its status is 'Wrong Answer'
2026-01-10 09:25:02,410 [INFO] __main__.py:188 - Skipping split-array-with-minimum-difference 2025-09-28 08.53.42 because its status is 'Wrong Answer'
2026-01-10 09:25:03,143 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:03,147 [INFO] __main__.py:245 - Writing compute-decimal-representation/2025-09-28 08.12.39 - Accepted - runtime 3ms - memory 9.7MB.cpp
2026-01-10 09:25:03,543 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:03,550 [INFO] __main__.py:245 - Writing majority-frequency-characters/2025-09-27 20.40.26 - Accepted - runtime 0ms - memory 9.2MB.cpp
2026-01-10 09:25:03,551 [INFO] __main__.py:245 - Writing linked-list-cycle/2025-09-26 15.28.36 - Accepted - runtime 3ms - memory 11.8MB.cpp
2026-01-10 09:25:03,551 [INFO] __main__.py:245 - Writing linked-list-cycle/2025-09-26 14.07.15 - Accepted - runtime 15ms - memory 14.5MB.cpp
2026-01-10 09:25:05,717 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:05,720 [INFO] __main__.py:245 - Writing middle-of-the-linked-list/2025-09-25 10.51.24 - Accepted - runtime 0ms - memory 10MB.cpp
2026-01-10 09:25:06,362 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:06,364 [INFO] __main__.py:245 - Writing delete-node-in-a-linked-list/2025-09-21 09.13.58 - Accepted - runtime 10ms - memory 12.4MB.cpp
2026-01-10 09:25:11,369 [DEBUG] leetcode.py:150 - Exporting submissions from 200 to 220
2026-01-10 09:25:12,462 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=200&limit=20 HTTP/1.1" 200 None
2026-01-10 09:25:12,464 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1777569968,"question_id":4005,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758422670,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1777569968/","is_pending":"Not Pending","title":"Maximum Total Subarray Value I","memory":"103.6 MB","code":"class Solution {\\npublic:\\n    long long maxTotalValue(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        if(nums.size() == 1){return 0;}\\n\\n        long long maxi = *max_element(nums.begin(),nums.end());\\n        long long mini = *min_element(nums.begin(),nums.end());\\n\\n        sum = (maxi - mini) * k;\\n\\n        return sum;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-total-subarray-value-i","has_notes":false,"flag_type":1,"frontend_id":350},{"id":1777547846,"question_id":4009,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1758422029,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1777547846/","is_pending":"Not Pending","title":"Bitwise OR of Even Numbers in an Array","memory":"24.5 MB","code":"class Solution {\\npublic:\\n    int evenNumberBitwiseORs(vector<int>& nums) {\\n        int orn = 0;\\n        for(auto &el:nums){\\n            if(el%2==0){\\n                orn = orn | el;\\n            }\\n        }\\n        return orn;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"bitwise-or-of-even-numbers-in-an-array","has_notes":false,"flag_type":1,"frontend_id":349},{"id":1773456208,"question_id":1890,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1758083599,"status":10,"status_display":"Accepted","runtime":"642 ms","url":"/submissions/detail/1773456208/","is_pending":"Not Pending","title":"Sum of Beauty of All Substrings","memory":"410.9 MB","code":"class Solution {\\n  int getCurrentBeauty(int freq[])\\n  {\\n    int maxFreq = INT_MIN, minFreq = INT_MAX;\\n    for (int i = 0; i < 26; i++)\\n    {\\n      if (freq[i] == 0)\\n        continue;\\n      maxFreq = max(maxFreq, freq[i]);\\n      minFreq = min(minFreq, freq[i]);\\n    }\\n    return maxFreq - minFreq;\\n  }\\n\\npublic:\\n    int beautySum(string s) {\\n        int beautyAll = 0;\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            int freq[26] = {0};\\n            for (int j = i; j < s.size(); j++) {\\n                freq[s[j] - \'a\']++;\\n                string curr = s.substr(i, j - i + 1);\\n                int currentBeauty = getCurrentBeauty(freq);\\n                if (currentBeauty > 0) {\\n                    beautyAll += currentBeauty;\\n                }\\n            }\\n        }\\n        return beautyAll;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111","title_slug":"sum-of-beauty-of-all-substrings","has_notes":false,"flag_type":1,"frontend_id":348},{"id":1773396013,"question_id":5,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1758078684,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1773396013/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"11.9 MB","code":"class Solution {\\n    pair<int, int> getMaxPalindromeLength(string& s, int left, int right) {\\n        while (left >= 0 && right < s.size() && s[left] == s[right]) {\\n            left--;\\n            right++;\\n        }\\n        return {left + 1, (right - 1) - (left + 1) + 1};\\n    }\\n\\npublic:\\n    string longestPalindrome(string s) {\\n        int maxLength = INT_MIN;\\n        string ans = \\"\\";\\n        for (int i = 0; i < s.size(); i++) {\\n            // pair<start,length>\\n            pair<int, int> len1 =\\n                getMaxPalindromeLength(s, i, i); // ODD LENGTH\\n            pair<int, int> len2 =\\n                getMaxPalindromeLength(s, i, i + 1); // EVEN LENGTH\\n\\n            int currentMaxLength = max({len1.second, len2.second});\\n\\n            if (currentMaxLength > maxLength) {\\n                maxLength = currentMaxLength;\\n                if (len1.second == currentMaxLength) {\\n                    ans = s.substr(len1.first, len1.second);\\n                } else {\\n                    ans = s.substr(len2.first, len2.second);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1,"frontend_id":347},{"id":1772231446,"question_id":5,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757992132,"status":10,"status_display":"Accepted","runtime":"862 ms","url":"/submissions/detail/1772231446/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"13.5 MB","code":"class Solution {\\n    bool isPalindrome(string &s, int startIdx, int endIdx)\\n  {\\n    while (startIdx < endIdx)\\n    {\\n      if (s[startIdx] != s[endIdx])\\n      {\\n        return false;\\n      }\\n      startIdx++;\\n      endIdx--;\\n    }\\n    return true;\\n  }\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==1)return s;\\n    int maxSize = INT_MIN;\\n    string ans = \\"\\";\\n    isPalindrome(s, 0, s.size() - 1);\\n    for (int i = 0; i < s.size() - 1; i++)\\n    {\\n      for (int j = i ; j < s.size(); j++)\\n      {\\n        if (isPalindrome(s, i, j) == true)\\n        {\\n          if (maxSize < j - i + 1)\\n          {\\n            maxSize = j-i+1;\\n            ans = s.substr(i, j - i + 1);\\n          }\\n        }\\n      }\\n    }\\n    return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1,"frontend_id":346},{"id":1772231086,"question_id":5,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757992094,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1772231086/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"N/A","code":"class Solution {\\n    bool isPalindrome(string &s, int startIdx, int endIdx)\\n  {\\n    while (startIdx < endIdx)\\n    {\\n      if (s[startIdx] != s[endIdx])\\n      {\\n        return false;\\n      }\\n      startIdx++;\\n      endIdx--;\\n    }\\n    return true;\\n  }\\npublic:\\n    string longestPalindrome(string s) {\\n        if(s.size()==1)return s;\\n    int maxSize = INT_MIN;\\n    string ans = \\"\\";\\n    isPalindrome(s, 0, s.size() - 1);\\n    for (int i = 0; i < s.size() - 1; i++)\\n    {\\n      for (int j = i + 1; j < s.size(); j++)\\n      {\\n        if (isPalindrome(s, i, j) == true)\\n        {\\n          if (maxSize < j - i + 1)\\n          {\\n            maxSize = j-i+1;\\n            ans = s.substr(i, j - i + 1);\\n          }\\n        }\\n      }\\n    }\\n    return ans;\\n    }\\n};","compare_result":"1110111111111111111111011111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1,"frontend_id":345},{"id":1772230656,"question_id":5,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757992046,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1772230656/","is_pending":"Not Pending","title":"Longest Palindromic Substring","memory":"N/A","code":"class Solution {\\n    bool isPalindrome(string &s, int startIdx, int endIdx)\\n  {\\n    while (startIdx < endIdx)\\n    {\\n      if (s[startIdx] != s[endIdx])\\n      {\\n        return false;\\n      }\\n      startIdx++;\\n      endIdx--;\\n    }\\n    return true;\\n  }\\npublic:\\n    string longestPalindrome(string s) {\\n    int maxSize = INT_MIN;\\n    string ans = \\"\\";\\n    isPalindrome(s, 0, s.size() - 1);\\n    for (int i = 0; i < s.size() - 1; i++)\\n    {\\n      for (int j = i + 1; j < s.size(); j++)\\n      {\\n        if (isPalindrome(s, i, j) == true)\\n        {\\n          if (maxSize < j - i + 1)\\n          {\\n            maxSize = j-i+1;\\n            ans = s.substr(i, j - i + 1);\\n          }\\n        }\\n      }\\n    }\\n    return ans;\\n    }\\n};","compare_result":"1100111111111111111111011111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100011","title_slug":"longest-palindromic-substring","has_notes":false,"flag_type":1,"frontend_id":344},{"id":1770815172,"question_id":8,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757873973,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1770815172/","is_pending":"Not Pending","title":"String to Integer (atoi)","memory":"9.1 MB","code":"class Solution {\\npublic:\\n    int myAtoi(string s) {\\n        int idx = 0;\\n        long long ans = 0;\\n\\n        for (auto& ch : s) {\\n            if (ch != \' \') {\\n                break;\\n            }\\n            idx++;\\n        }\\n\\n        bool isPositive = true;\\n        if (s[idx] == \'-\') {\\n            isPositive = false;\\n            idx++;\\n        } else if (s[idx] == \'+\') {\\n            idx++;\\n        }\\n        int sign = isPositive ? +1 : -1;\\n\\n        while (idx < s.size()) {\\n            if (s[idx] - \'0\' >= 0 && s[idx] - \'0\' <= 9) {\\n                ans = (ans * 10) + (s[idx] - \'0\') * sign ;\\n                if(ans > INT_MAX)ans = INT_MAX;\\n                if(ans < INT_MIN)ans = INT_MIN;\\n                idx++;\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-to-integer-atoi","has_notes":false,"flag_type":1,"frontend_id":343},{"id":1770800289,"question_id":8,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757873140,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1770800289/","is_pending":"Not Pending","title":"String to Integer (atoi)","memory":"N/A","code":"class Solution {\\npublic:\\n    int myAtoi(string s) {\\n        int idx = 0;\\n        int ans = 0;\\n\\n        for (auto& ch : s) {\\n            if (ch != \' \') {\\n                break;\\n            }\\n            idx++;\\n        }\\n\\n        bool isPositive = true;\\n        if (s[idx] == \'-\') {\\n            isPositive = false;\\n            idx++;\\n        } else if (s[idx] == \'+\') {\\n            idx++;\\n        }\\n\\n        while (idx < s.size()) {\\n            if (s[idx] - \'0\' >= 0 && s[idx] - \'0\' <= 9) {\\n                ans = (ans * 10) + (s[idx] - \'0\');\\n                idx++;\\n            }else{\\n                break;\\n            }\\n        }\\n        if(!isPositive)return -1 * ans;\\n        return ans;\\n\\n    }\\n};","compare_result":"111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"string-to-integer-atoi","has_notes":false,"flag_type":1,"frontend_id":342},{"id":1770218398,"question_id":12,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757832186,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1770218398/","is_pending":"Not Pending","title":"Integer to Roman","memory":"12.7 MB","code":"class Solution {\\npublic:\\n    string intToRoman(int num) {\\n        vector<pair<int, string>> mapArr = {\\n            {1, \\"I\\"},\\n            {4, \\"IV\\"},\\n            {5, \\"V\\"},\\n            {9, \\"IX\\"},\\n            {10, \\"X\\"},\\n            {40, \\"XL\\"},\\n            {50, \\"L\\"},\\n            {90, \\"XC\\"},\\n            {100, \\"C\\"},\\n            {400, \\"CD\\"},\\n            {500, \\"D\\"},\\n            {900, \\"CM\\"},\\n            {1000, \\"M\\"},\\n        };\\n        int justSmallerNumberIndex = mapArr.size()-1;\\n        string ans = \\"\\";\\n        while(num > 0 && justSmallerNumberIndex >= 0){\\n            if(num >= mapArr[justSmallerNumberIndex].first){\\n                ans += mapArr[justSmallerNumberIndex].second;\\n                num -= mapArr[justSmallerNumberIndex].first;\\n            }else{\\n                // Move to lesser roman number\\n                justSmallerNumberIndex--;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"integer-to-roman","has_notes":false,"flag_type":1,"frontend_id":341},{"id":1770113647,"question_id":13,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757824993,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1770113647/","is_pending":"Not Pending","title":"Roman to Integer","memory":"13.5 MB","code":"class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        int romanToInt = 0;\\n    unordered_map<char, int> map = {{\'I\', 1},\\n                                    {\'V\', 5},\\n                                    {\'X\', 10},\\n                                    {\'L\', 50},\\n                                    {\'C\', 100},\\n                                    {\'D\', 500},\\n                                    {\'M\', 1000}};\\n    for (int i = 0; i < s.size(); i++)\\n    {\\n      if (i + 1 < s.size() && map[s[i]] < map[s[i + 1]])\\n      {\\n        // Subtract\\n        romanToInt -= map[s[i]];\\n      }\\n      else\\n      {\\n        // Add\\n        romanToInt += map[s[i]];\\n      }\\n    }\\n        return romanToInt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"roman-to-integer","has_notes":false,"flag_type":1,"frontend_id":340},{"id":1770096868,"question_id":13,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757823587,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1770096868/","is_pending":"Not Pending","title":"Roman to Integer","memory":"13.5 MB","code":"class Solution {\\npublic:\\n    int romanToInt(string s) {\\n        unordered_map<char,int> romanSet = {{\'I\',1},{\'V\',5},{\'X\',10},{\'L\',50},{\'C\',100},{\'D\',500},{\'M\',1000}};\\n        int number = 0;\\n\\n        for(int i=0;i<s.size();i++){\\n            if(s[i] == \'I\'){\\n                if(i+1 < s.size() && (s[i+1] == \'V\' || s[i+1] == \'X\')){\\n                    number += (romanSet[s[i+1]] - romanSet[s[i]]);\\n                    i++;\\n                }else{\\n                    number+= romanSet[\'I\'];\\n                }\\n            }\\n            else if(s[i] == \'X\'){\\n                if(i+1 < s.size() && (s[i+1] == \'L\' || s[i+1] == \'C\')){\\n                    number += (romanSet[s[i+1]] - romanSet[s[i]]);\\n                    i++;\\n                }else{\\n                    number+= romanSet[\'X\'];\\n                }\\n            }\\n            else if(s[i] == \'C\'){\\n                if(i+1 < s.size() && (s[i+1] == \'D\' || s[i+1] == \'M\')){\\n                    number += (romanSet[s[i+1]] - romanSet[s[i]]);\\n                    i++;\\n                }else{\\n                    number+= romanSet[\'C\'];\\n                }\\n            }else{\\n                number += romanSet[s[i]];\\n            }\\n        }\\n        return number;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"roman-to-integer","has_notes":false,"flag_type":1,"frontend_id":339},{"id":1770048820,"question_id":3873,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757820915,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1770048820/","is_pending":"Not Pending","title":"Subsequence Sum After Capping Elements","memory":"N/A","code":"class Solution {\\n    bool isPossible(vector<int>&arr,int sum,int index,int target,vector<vector<int>>&dp){\\n        if(sum == target)return true;\\n        if(index < 0 || sum > target)return false;\\n\\n        if(dp[index][sum]!=-1)return dp[index][sum];\\n        //Pick\\n        bool pick = isPossible(arr,sum+arr[index],index-1,target,dp);\\n        //Not pick\\n        bool notPick = isPossible(arr,sum,index-1,target,dp);\\n        return dp[index][sum] = pick | notPick;\\n    }\\npublic:\\n    vector<bool> subsequenceSumAfterCapping(vector<int>& nums, int k) {\\n        vector<bool>ans(nums.size(),1);\\n        int start = 1,end = nums.size(),minCap = -1;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            int currentCap = mid;\\n            // if(currentCap * nums.size() < k){ans[i]=0;continue; }// Clearly Here Not Possible\\n            // Otherwise May be possible\\n            vector<int>temp = nums;\\n            for(int j=0; j<temp.size();j++){\\n                temp[j] = min(nums[j],currentCap);\\n            }\\n            int sum = 0;\\n            vector<vector<int>>dp(nums.size(),vector<int>(k+1,-1));\\n            bool possible = isPossible(temp,sum,temp.size()-1,k,dp);\\n            if(possible){\\n                minCap = mid;\\n                end = mid-1;\\n            }\\n            else{\\n                start = mid+1;\\n            }\\n        }\\n        for(int i=0;i<nums.size(); i++){\\n            int currCap = i+1;\\n            if(minCap != -1 && currCap >= minCap){\\n                ans[i]=1;\\n            }else{\\n                ans[i]=0;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111101111111011100011111111111010111111011111101111100110110111111111011110111110111011111110111100101111111110111111101111101110111111111001111101111000101101110111111101111110111111111110111111111011111111111111111111110011110111111111111111110001110110111110011111111111011111111111111110011111111101110111111111111111101010101100101111111100111101100101011110001011111000111111011110111111011111110111111101011111011111110111111010110111111111111111111110111111111111111111111101101001111111111111111111101111111111111111111111111101100111111110111011111111111111110110111111110111011100110111101111111111110111110111111111111111011101111111011101111111111010111101111101111111111011111101111101111111111111111111110111111111111111111011110000000000000000000000000000000000000000000","title_slug":"subsequence-sum-after-capping-elements","has_notes":false,"flag_type":1,"frontend_id":338},{"id":1770034846,"question_id":3873,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757820317,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1770034846/","is_pending":"Not Pending","title":"Subsequence Sum After Capping Elements","memory":"N/A","code":"class Solution {\\n    bool isPossible(vector<int>&arr,int sum,int index,int target,vector<vector<int>>&dp){\\n        if(sum == target)return true;\\n        if(index < 0 || sum > target)return false;\\n\\n        if(dp[index][sum]!=-1)return dp[index][sum];\\n        //Pick\\n        bool pick = isPossible(arr,sum+arr[index],index-1,target,dp);\\n        //Not pick\\n        bool notPick = isPossible(arr,sum,index-1,target,dp);\\n        return dp[index][sum] = pick | notPick;\\n    }\\npublic:\\n    vector<bool> subsequenceSumAfterCapping(vector<int>& nums, int k) {\\n        vector<bool>ans(nums.size(),1);\\n        for(int i=0; i<nums.size();i++){\\n            int currentCap = i+1;\\n            // if(currentCap * nums.size() < k){ans[i]=0;continue; }// Clearly Here Not Possible\\n            // Otherwise May be possible\\n            vector<int>temp = nums;\\n            for(int j=0; j<temp.size();j++){\\n                temp[j] = min(nums[j],currentCap);\\n            }\\n            int sum = 0;\\n            vector<vector<int>>dp(nums.size(),vector<int>(k+1,-1));\\n            if(!isPossible(temp,sum,temp.size()-1,k,dp)){\\n                ans[i]=false;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000","title_slug":"subsequence-sum-after-capping-elements","has_notes":false,"flag_type":1,"frontend_id":337},{"id":1770025284,"question_id":3873,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757819919,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1770025284/","is_pending":"Not Pending","title":"Subsequence Sum After Capping Elements","memory":"N/A","code":"class Solution {\\n    bool isPossible(vector<int>&arr,int sum,int index,int target){\\n        if(sum == target)return true;\\n        if(index < 0 || sum > target)return false;\\n        \\n        //Pick\\n        bool pick = isPossible(arr,sum+arr[index],index-1,target);\\n        //Not pick\\n        bool notPick = isPossible(arr,sum,index-1,target);\\n        return pick | notPick;\\n    }\\npublic:\\n    vector<bool> subsequenceSumAfterCapping(vector<int>& nums, int k) {\\n        vector<bool>ans(nums.size(),1);\\n        for(int i=0; i<nums.size();i++){\\n            int currentCap = i+1;\\n            // if(currentCap * nums.size() < k){ans[i]=0;continue; }// Clearly Here Not Possible\\n            // Otherwise May be possible\\n            vector<int>temp = nums;\\n            for(int j=0; j<temp.size();j++){\\n                temp[j] = min(nums[j],currentCap);\\n            }\\n            int sum = 0;\\n            if(!isPossible(temp,sum,temp.size()-1,k)){\\n                ans[i]=false;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"subsequence-sum-after-capping-elements","has_notes":false,"flag_type":1,"frontend_id":336},{"id":1769985077,"question_id":3997,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757818314,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1769985077/","is_pending":"Not Pending","title":"Maximize Sum of At Most K Distinct Elements","memory":"27.9 MB","code":"#include<bits/stdc++.h>\\nclass Solution {\\n    static bool customOperator(int &a,int &b){\\n        return a>b;\\n    }\\npublic:\\n    vector<int> maxKDistinct(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),customOperator);\\n        int currK = 0;\\n        if(k==1)return {nums[0]};\\n        vector<int>ans;\\n        ans.push_back(nums[0]);\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i-1]==nums[i])continue;\\n            ans.push_back(nums[i]);\\n            if(ans.size() == k)break;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximize-sum-of-at-most-k-distinct-elements","has_notes":false,"flag_type":1,"frontend_id":335},{"id":1769955163,"question_id":4012,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757817286,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1769955163/","is_pending":"Not Pending","title":"Earliest Time to Finish One Task","memory":"36.6 MB","code":"class Solution {\\npublic:\\n    int earliestTime(vector<vector<int>>& tasks) {\\n        int minTime = INT_MAX;\\n        if(tasks.size() == 1)return tasks[0][0] + tasks[0][1];\\n\\n        for(auto &row:tasks){\\n           \\n                minTime = min(minTime,row[0] + row[1]);\\n            \\n        }\\n        return minTime;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"earliest-time-to-finish-one-task","has_notes":false,"flag_type":1,"frontend_id":334},{"id":1769523030,"question_id":3953,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757778388,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1769523030/","is_pending":"Not Pending","title":" Minimum Discards to Balance Inventory","memory":"N/A","code":"class Solution {\\npublic:\\n    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m) {\\n        unordered_map<int,int>map;\\n        pair<int,int>currentWindow={0,w-1};\\n        int discard = 0;\\n        for(int i=0; i<w;i++){\\n            if(map[arrivals[i]] > m){\\n                discard++;\\n            }\\n            map[arrivals[i]]++;\\n        }\\n        map[arrivals[0]]--;\\n        currentWindow.first++;\\n        currentWindow.second++;\\n\\n        while(currentWindow.second < arrivals.size()){\\n            map[arrivals[currentWindow.second]]++;\\n            if(map[arrivals[currentWindow.second]] > m){\\n                discard++;\\n            }\\n\\n            map[arrivals[currentWindow.first]]--;\\n            currentWindow.first++;\\n            currentWindow.second++;\\n        }\\n        return discard;\\n        \\n    }\\n};","compare_result":"111111011010111111110100111101011101111111110101011111111111010111010101101111101111111111101111111111010011111010110011111111111111111101110110100111100111101101111111111100101011111111111110110011110111101010111111011101101111101110111101010111110101000000010001000010010000110001000010000000100001100000000110100000110010000001000000000100100000010010000000000000000000000000000100000000000011111000010001000000000000000000000010000011000000010010000101010001000010010000100000000000000100010001001001001000000100010110100000111011101010111","title_slug":"minimum-discards-to-balance-inventory","has_notes":false,"flag_type":1,"frontend_id":333},{"id":1769429790,"question_id":4011,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757775535,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1769429790/","is_pending":"Not Pending","title":"Smallest Absent Positive Greater Than Average","memory":"85.7 MB","code":"class Solution {\\npublic:\\n    int smallestAbsent(vector<int>& nums) {\\n        int sumArr = accumulate(nums.begin(),nums.end(),0);\\n        int avg = floor((double)sumArr /(double)nums.size() );\\n        if(avg <=0)avg = 0;\\n        for(int i = avg+1;i<=INT_MAX;i++){\\n            auto it = find(nums.begin(),nums.end(),i);\\n            if(it == nums.end()){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-absent-positive-greater-than-average","has_notes":false,"flag_type":1,"frontend_id":332},{"id":1769424859,"question_id":4011,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757775410,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1769424859/","is_pending":"Not Pending","title":"Smallest Absent Positive Greater Than Average","memory":"N/A","code":"class Solution {\\npublic:\\n    int smallestAbsent(vector<int>& nums) {\\n        int sumArr = accumulate(nums.begin(),nums.end(),0);\\n        int avg = floor((double)sumArr /(double)nums.size() );\\n        if(avg <=0)avg = 0;\\n        for(int i = avg+1;i<=sumArr + nums.size();i++){\\n            auto it = find(nums.begin(),nums.end(),i);\\n            if(it == nums.end()){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-absent-positive-greater-than-average","has_notes":false,"flag_type":1,"frontend_id":331}],"has_next":true,"last_key":""}'
2026-01-10 09:25:14,287 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:14,291 [INFO] __main__.py:245 - Writing maximum-total-subarray-value-i/2025-09-21 08.14.30 - Accepted - runtime 0ms - memory 103.6MB.cpp
2026-01-10 09:25:14,617 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:14,619 [INFO] __main__.py:245 - Writing bitwise-or-of-even-numbers-in-an-array/2025-09-21 08.03.49 - Accepted - runtime 0ms - memory 24.5MB.cpp
2026-01-10 09:25:14,926 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:14,927 [INFO] __main__.py:245 - Writing sum-of-beauty-of-all-substrings/2025-09-17 10.03.19 - Accepted - runtime 642ms - memory 410.9MB.cpp
2026-01-10 09:25:14,928 [INFO] __main__.py:245 - Writing longest-palindromic-substring/2025-09-17 08.41.24 - Accepted - runtime 6ms - memory 11.9MB.cpp
2026-01-10 09:25:14,928 [INFO] __main__.py:245 - Writing longest-palindromic-substring/2025-09-16 08.38.52 - Accepted - runtime 862ms - memory 13.5MB.cpp
2026-01-10 09:25:14,929 [INFO] __main__.py:188 - Skipping longest-palindromic-substring 2025-09-16 08.38.14 because its status is 'Wrong Answer'
2026-01-10 09:25:14,929 [INFO] __main__.py:188 - Skipping longest-palindromic-substring 2025-09-16 08.37.26 because its status is 'Wrong Answer'
2026-01-10 09:25:15,236 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:15,242 [INFO] __main__.py:245 - Writing string-to-integer-atoi/2025-09-14 23.49.33 - Accepted - runtime 3ms - memory 9.1MB.cpp
2026-01-10 09:25:15,243 [INFO] __main__.py:188 - Skipping string-to-integer-atoi 2025-09-14 23.35.40 because its status is 'Runtime Error'
2026-01-10 09:25:15,562 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:15,565 [INFO] __main__.py:245 - Writing integer-to-roman/2025-09-14 12.13.06 - Accepted - runtime 0ms - memory 12.7MB.cpp
2026-01-10 09:25:17,093 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:17,095 [INFO] __main__.py:245 - Writing roman-to-integer/2025-09-14 10.13.13 - Accepted - runtime 12ms - memory 13.5MB.cpp
2026-01-10 09:25:17,096 [INFO] __main__.py:245 - Writing roman-to-integer/2025-09-14 09.49.47 - Accepted - runtime 11ms - memory 13.5MB.cpp
2026-01-10 09:25:17,096 [INFO] __main__.py:188 - Skipping subsequence-sum-after-capping-elements 2025-09-14 09.05.15 because its status is 'Wrong Answer'
2026-01-10 09:25:17,097 [INFO] __main__.py:188 - Skipping subsequence-sum-after-capping-elements 2025-09-14 08.55.17 because its status is 'Time Limit Exceeded'
2026-01-10 09:25:17,097 [INFO] __main__.py:188 - Skipping subsequence-sum-after-capping-elements 2025-09-14 08.48.39 because its status is 'Time Limit Exceeded'
2026-01-10 09:25:17,423 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:17,426 [INFO] __main__.py:245 - Writing maximize-sum-of-at-most-k-distinct-elements/2025-09-14 08.21.54 - Accepted - runtime 8ms - memory 27.9MB.cpp
2026-01-10 09:25:17,934 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:17,936 [INFO] __main__.py:245 - Writing earliest-time-to-finish-one-task/2025-09-14 08.04.46 - Accepted - runtime 3ms - memory 36.6MB.cpp
2026-01-10 09:25:17,937 [INFO] __main__.py:188 - Skipping minimum-discards-to-balance-inventory 2025-09-13 21.16.28 because its status is 'Wrong Answer'
2026-01-10 09:25:18,381 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:18,383 [INFO] __main__.py:245 - Writing smallest-absent-positive-greater-than-average/2025-09-13 20.28.55 - Accepted - runtime 0ms - memory 85.7MB.cpp
2026-01-10 09:25:18,384 [INFO] __main__.py:188 - Skipping smallest-absent-positive-greater-than-average 2025-09-13 20.26.50 because its status is 'Wrong Answer'
2026-01-10 09:25:23,388 [DEBUG] leetcode.py:150 - Exporting submissions from 220 to 240
2026-01-10 09:25:26,300 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=220&limit=20 HTTP/1.1" 200 None
2026-01-10 09:25:26,302 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1769421604,"question_id":4011,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757775332,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1769421604/","is_pending":"Not Pending","title":"Smallest Absent Positive Greater Than Average","memory":"N/A","code":"class Solution {\\npublic:\\n    int smallestAbsent(vector<int>& nums) {\\n        int sumArr = accumulate(nums.begin(),nums.end(),0);\\n        int avg = floor((double)sumArr /(double)nums.size() );\\n\\n        for(int i = avg+1;i<=sumArr + nums.size();i++){\\n            auto it = find(nums.begin(),nums.end(),i);\\n            if(it == nums.end()){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111010111111101111111111010011101111011111011001111111111111111110110111111000111110011110111101111011101011110110011111000111111111101111111110110111111111101111111111111101110111111101110011111101110111111110111111111111111100111110111111110111111111011111111110111110101111111111111011111011111110010111111111110111011100011111111111111111111011111111111111111111111101111010111111111111111111011111111111111111111011101111111111111111111111111111111111111111111101111111111111011111011101111110111010111010111111111101011111111111111111111111101111111111111111111111111111111111111111111111111111110111111111111111111101111111111111101011111111111111111111111111111111111111111111111111111111110111111111110111111111100111111011111110111111111111101110101111111101011111110111111111111111111111111111111111111111111111111111111111111111111111101110111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111011111111111011111011111111111111111111111111111111111111101111111111111111111111111111111110111111111111111111111111111111111111111111111011111111111111111111101111111111111111111111111011111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111011111111101111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110001101100101100111111111101111111","title_slug":"smallest-absent-positive-greater-than-average","has_notes":false,"flag_type":1,"frontend_id":330},{"id":1769402007,"question_id":4011,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757774885,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1769402007/","is_pending":"Not Pending","title":"Smallest Absent Positive Greater Than Average","memory":"N/A","code":"class Solution {\\n    int find_avg(vector<int>&nums){\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        return floor((double)sum/(double)nums.size());\\n    }\\npublic:\\n    int smallestAbsent(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0]+1;\\n        int avg = find_avg(nums); //ceil of avg\\n        int smallestBiggest = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i] < avg)continue;\\n            if(nums[i] > avg)smallestBiggest = nums[i];\\n        }\\n        for(int i=avg+1; i<accumulate(nums.begin(),nums.end(),0) + nums.size();i++){\\n            auto it = find(nums.begin(),nums.end(),i);\\n            if(it == nums.end()){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111010111111101111111111010011101111011111011001111111111111111110110111111000111110011110111101111011101011110110011111000111111111101111111110110111111111101111111111111101110111111101110011111101110111111110111111111111111100111110111111110111111111011111111110111110101111111111111011111011111110010111111111110111011100011111111111111111111011111111111111111111111101111010111111111111111111011111111111111111111011101111111111111111111111111111111111111111111101111111111111011111011101111110111010111010111111111101011111111111111111111111101111111111111111111111111111111111111111111111111111110111111111111111111101111111111111101011111111111111111111111111111111111111111111111111111111110111111111110111111111100111111011111110111111111111101110101111111101011111110111111111111111111111111111111111111111111111111111111111111111111111101110111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111011111111111011111011111111111111111111111111111111111111101111111111111111111111111111111110111111111111111111111111111111111111111111111011111111111111111111101111111111111111111111111011111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111011111111101111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110001001100101100111111111101111101","title_slug":"smallest-absent-positive-greater-than-average","has_notes":false,"flag_type":1,"frontend_id":329},{"id":1769395773,"question_id":4011,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757774755,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1769395773/","is_pending":"Not Pending","title":"Smallest Absent Positive Greater Than Average","memory":"N/A","code":"class Solution {\\n    int find_avg(vector<int>&nums){\\n        int sum = accumulate(nums.begin(),nums.end(),0);\\n        return floor((double)sum/(double)nums.size());\\n    }\\npublic:\\n    int smallestAbsent(vector<int>& nums) {\\n        int avg = find_avg(nums); //ceil of avg\\n        int smallestBiggest = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size();i++){\\n            if(nums[i] < avg)continue;\\n            if(nums[i] > avg)smallestBiggest = nums[i];\\n        }\\n        for(int i=avg+1; i<accumulate(nums.begin(),nums.end(),0) + nums.size();i++){\\n            auto it = find(nums.begin(),nums.end(),i);\\n            if(it == nums.end()){\\n                return i;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010011111000111111111101111111110110111111111101111111111111101110111111101110011111101110111111110111111111111111100111110111111110111111111011111111110111110101111111111111011111011111110010111111111110111011100011111111111111111111011111111111111111111111101111010111111111111111111011111111111111111111011101111111111111111111111111111111111111111111101111111111111011111011101111110111010111010111111111101011111111111111111111111101111111111111111111111111111111111111111111111111111110111111111111111111101111111111111101011111111111111111111111111111111111111111111111111111111110111111111110111111111100111111011111110111111111111101110101111111101011111110111111111111111111111111111111111111111111111111111111111111111111111101110111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111011111111111011111011111111111111111111111111111111111111101111111111111111111111111111111110111111111111111111111111111111111111111111111011111111111111111111101111111111111111111111111011111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111011111111101111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110110001001100101100111111111101101101","title_slug":"smallest-absent-positive-greater-than-average","has_notes":false,"flag_type":1,"frontend_id":328},{"id":1769313340,"question_id":1737,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757771354,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1769313340/","is_pending":"Not Pending","title":"Maximum Nesting Depth of the Parentheses","memory":"8.3 MB","code":"class Solution {\\npublic:\\n    int maxDepth(string s) {\\n        int maxCount=0,currentCount=0;\\n        for(auto character:s){\\n            if(character == \'(\'){\\n                currentCount++;\\n            }else if(character == \')\'){\\n                currentCount--;\\n            }\\n            maxCount = max(currentCount,maxCount);\\n        }\\n        return maxCount;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-nesting-depth-of-the-parentheses","has_notes":false,"flag_type":1,"frontend_id":327},{"id":1769309743,"question_id":1737,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757771122,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1769309743/","is_pending":"Not Pending","title":"Maximum Nesting Depth of the Parentheses","memory":"8.6 MB","code":"class Solution {\\npublic:\\n    int maxDepth(string s) {\\n        int maxDepth = 0;\\n        stack<char>stack;\\n        int currentDepth=0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \'(\'){\\n                stack.push(\'(\');\\n            }else if(s[i]==\')\'){\\n                stack.pop();\\n            }\\n            int size = stack.size();\\n            maxDepth = max(maxDepth,size);\\n        }\\n        return maxDepth;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-nesting-depth-of-the-parentheses","has_notes":false,"flag_type":1,"frontend_id":326},{"id":1769053403,"question_id":451,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757751594,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1769053403/","is_pending":"Not Pending","title":"Sort Characters By Frequency","memory":"11.4 MB","code":"class Solution {\\n    static bool customOperator(pair<char, int>& s1, pair<char, int>& s2) {\\n        if (s1.second > s2.second)\\n            return true;\\n        if (s1.second < s2.second)\\n            return false;\\n        return s1.first < s2.first; // Return smaller Occuring Character\\n    }\\n\\npublic:\\n    string frequencySort(string s) {\\n        if(s.size() <=2)return s;\\n        vector<pair<char, int>> frequency(256, {NULL, 0});\\n        for (auto& ch : s) {\\n            frequency[(int)ch].first = ch;\\n            frequency[(int)ch].second += 1;\\n        }\\n        sort(frequency.begin(), frequency.end(), customOperator);\\n        string ans = \\"\\";\\n        for (auto& element : frequency) {\\n            if (element.second != 0) {\\n                for (int i = 0; i < element.second; i++)\\n                    ans += element.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"sort-characters-by-frequency","has_notes":false,"flag_type":1,"frontend_id":325},{"id":1769044276,"question_id":451,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757750838,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1769044276/","is_pending":"Not Pending","title":"Sort Characters By Frequency","memory":"11.4 MB","code":"class Solution {\\n    static bool customOperator(pair<char, int>& s1, pair<char, int>& s2) {\\n        if (s1.second > s2.second)\\n            return true;\\n        if (s1.second < s2.second)\\n            return false;\\n        return s1.first < s2.first; // Return smaller Occuring Character\\n    }\\n\\npublic:\\n    string frequencySort(string s) {\\n        if(s.size() <=2)return s;\\n        vector<pair<char, int>> frequency(256, {NULL, 0});\\n        for (auto& ch : s) {\\n            frequency[ch - \'0\'].first = ch;\\n            frequency[ch - \'0\'].second += 1;\\n        }\\n        sort(frequency.begin(), frequency.end(), customOperator);\\n        string ans = \\"\\";\\n        for (auto& element : frequency) {\\n            if (element.second != 0) {\\n                for (int i = 0; i < element.second; i++)\\n                    ans += element.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"sort-characters-by-frequency","has_notes":false,"flag_type":1,"frontend_id":324},{"id":1769043069,"question_id":451,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757750737,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1769043069/","is_pending":"Not Pending","title":"Sort Characters By Frequency","memory":"N/A","code":"class Solution {\\n    static bool customOperator(pair<char, int>& s1, pair<char, int>& s2) {\\n        if (s1.second > s2.second)\\n            return true;\\n        if (s1.second < s2.second)\\n            return false;\\n        return s1.first < s2.first; // Return smaller Occuring Character\\n    }\\n\\npublic:\\n    string frequencySort(string s) {\\n        if(s.size() <=2)return s;\\n        vector<pair<char, int>> frequency(256, {NULL, 0});\\n        for (auto& ch : s) {\\n            frequency[ch - \'A\'].first = ch;\\n            frequency[ch - \'A\'].second += 1;\\n        }\\n        sort(frequency.begin(), frequency.end(), customOperator);\\n        string ans = \\"\\";\\n        for (auto& element : frequency) {\\n            if (element.second != 0) {\\n                for (int i = 0; i < element.second; i++)\\n                    ans += element.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111110000000000000000000000000","title_slug":"sort-characters-by-frequency","has_notes":false,"flag_type":1,"frontend_id":323},{"id":1768848690,"question_id":242,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757736344,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768848690/","is_pending":"Not Pending","title":"Valid Anagram","memory":"9.6 MB","code":"class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        int freq[256]={0};\\n\\n        for(int i=0 ;i <s.size();i++){\\n            freq[s[i]]++;\\n        }\\n        for(int i=0 ;i <t.size();i++){\\n            freq[t[i]]--;\\n        }\\n        for(auto &element:freq){\\n            if(element != 0 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"valid-anagram","has_notes":false,"flag_type":1,"frontend_id":322},{"id":1768847030,"question_id":242,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1757736189,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1768847030/","is_pending":"Not Pending","title":"Valid Anagram","memory":"9.9 MB","code":"class Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        map<char,int>freq;\\n\\n        for(int i=0 ;i <s.size();i++){\\n            freq[s[i]]++;\\n        }\\n        for(int i=0 ;i <t.size();i++){\\n            freq[t[i]]--;\\n        }\\n        for(auto &element:freq){\\n            if(element.second != 0 ){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111","title_slug":"valid-anagram","has_notes":false,"flag_type":1,"frontend_id":321},{"id":1768616245,"question_id":812,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757704079,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768616245/","is_pending":"Not Pending","title":"Rotate String","memory":"8.4 MB","code":"class Solution {\\n    bool isRotateSame(string &temp, string & goal,int index){\\n        reverse(temp.begin(),temp.begin()+index);\\n        reverse(temp.begin()+index,temp.end());\\n        reverse(temp.begin(),temp.end());\\n        if(temp == goal){\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool rotateString(string s, string goal) {\\n        if(s.size() != goal.size())return false;\\n        for(int i=0; i<goal.size(); i++){\\n            string temp = s;\\n            if(isRotateSame(temp,goal,i))return true;\\n        }\\n        return false;\\n\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"rotate-string","has_notes":false,"flag_type":1,"frontend_id":320},{"id":1768597679,"question_id":205,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757702735,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768597679/","is_pending":"Not Pending","title":"Isomorphic Strings","memory":"9.3 MB","code":"class Solution {\\npublic:\\n    bool isIsomorphic(string s, string t) {\\n        vector<int> arr1(256, -1), arr2(256, -1);\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (arr1[s[i]] != arr2[t[i]])\\n                return false;\\n            arr1[s[i]] = i ;\\n            arr2[t[i]] = i ;\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"isomorphic-strings","has_notes":false,"flag_type":1,"frontend_id":319},{"id":1768561515,"question_id":205,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757700598,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768561515/","is_pending":"Not Pending","title":"Isomorphic Strings","memory":"9.3 MB","code":"class Solution {\\npublic:\\n    bool isIsomorphic(string s, string t) {\\n        vector<int> arr1(256, 0), arr2(256, 0);\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (arr1[s[i]] != arr2[t[i]])\\n                return false;\\n            arr1[s[i]] = i + 1;\\n            arr2[t[i]] = i + 1;\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"isomorphic-strings","has_notes":false,"flag_type":1,"frontend_id":318},{"id":1768497561,"question_id":205,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757697141,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1768497561/","is_pending":"Not Pending","title":"Isomorphic Strings","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isIsomorphic(string s, string t) {\\n        vector<int>arr1(256,0),arr2(256,0);\\n\\n        for(int i=0; i<s.size();i++){\\n            if(arr1[s[i]] != arr2[t[i]])return false;\\n            arr1[s[i]]+=1;\\n            arr2[t[i]]+=1;\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111100111110011111101111111011111011011110","title_slug":"isomorphic-strings","has_notes":false,"flag_type":1,"frontend_id":317},{"id":1768448103,"question_id":14,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757694404,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768448103/","is_pending":"Not Pending","title":"Longest Common Prefix","memory":"12.1 MB","code":"class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 1)return strs[0];\\n        sort(strs.begin(), strs.end());\\n        \\n        string first = strs[0];\\n        string last = strs[strs.size() - 1];\\n\\n        string ans = \\"\\";\\n        for (int i = 0; i < min(first.size(),last.size()); i++) {\\n            if (first[i] != last[i]) {\\n                break;\\n            }\\n            ans += first[i];\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-common-prefix","has_notes":false,"flag_type":1,"frontend_id":316},{"id":1768445542,"question_id":14,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757694262,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1768445542/","is_pending":"Not Pending","title":"Longest Common Prefix","memory":"N/A","code":"class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 1)return strs[0];\\n        sort(strs.begin(), strs.end());\\n        string first = strs[0];\\n        string last = strs[strs.size() - 1];\\n\\n        string ans = \\"\\";\\n        for (int i = 0; i < strs.size(); i++) {\\n            if (first[i] != last[i]) {\\n                break;\\n            }\\n            ans += first[i];\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111101111011001111011011111111111111111111111111101111111111111111111111111111111111110111101111111111111100101111010111111101","title_slug":"longest-common-prefix","has_notes":false,"flag_type":1,"frontend_id":315},{"id":1768424373,"question_id":14,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757693015,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768424373/","is_pending":"Not Pending","title":"Longest Common Prefix","memory":"11.8 MB","code":"class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int minStrSize = INT_MAX,cnt=0;\\n        if(strs.size() == 1)return strs[0];\\n\\n        string temp = \\"\\" ,ans=\\"\\";\\n        for(int i=0; i<strs.size();i++){\\n            if(minStrSize > strs[i].size()-1){\\n                minStrSize = strs[i].size()-1;\\n                temp = strs[i];\\n            }\\n        }\\n\\n        for(int i=0;i<strs.size();i++){\\n            for(int j=0; j<=minStrSize; j++){\\n                if(strs[i][j] != temp[j]){\\n                    minStrSize = j-1;\\n                    temp = strs[i].substr(0,j);\\n                }\\n            }\\n        }\\n        if(minStrSize < 0)return \\"\\";\\n\\n        return temp;\\n\\n\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-common-prefix","has_notes":false,"flag_type":1,"frontend_id":314},{"id":1768355609,"question_id":2032,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757688559,"status":10,"status_display":"Accepted","runtime":"7 ms","url":"/submissions/detail/1768355609/","is_pending":"Not Pending","title":"Largest Odd Number in String","memory":"20.2 MB","code":"class Solution {\\npublic:\\n    string largestOddNumber(string num) {\\n        int indexOdd = -1;\\n        for(int i=num.size()-1;i>=0; i--){\\n            char ch = num[i];\\n            int currentDigit = stoi(to_string(ch));\\n            if(currentDigit % 2==1){\\n                return num.substr(0,i+1);\\n            }\\n        }\\n        return \\"\\";\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-odd-number-in-string","has_notes":false,"flag_type":1,"frontend_id":313},{"id":1768287015,"question_id":151,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757684043,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1768287015/","is_pending":"Not Pending","title":"Reverse Words in a String","memory":"10.1 MB","code":"class Solution {\\npublic:\\n    string reverseWords(string s) {\\n        int size = s.size();\\n        string ans = \\"\\";\\n        int startSpace=0,endSpace=0;\\n        for(int i=0;i<size;i++){\\n            if (s[i] != \' \'){\\n                startSpace = i;\\n                break;\\n            }\\n            \\n        }\\n        s.erase(0,startSpace);\\n        for(int i=s.size()-1;i>=0;i--){\\n            if (s[i] != \' \'){\\n                endSpace = i;\\n                break;\\n            }\\n        }\\n        s.erase(endSpace+1,s.size()-endSpace-1);\\n        size = s.size();\\n        int left = size - 1, right = size - 1;\\n        while (left >= 0) {\\n            char ch = s[left];\\n            if (left != size-1 && ch == \' \' && s[left + 1] == \' \') {\\n                left--;\\n                continue;\\n            }\\n            if (ch == \' \' && left != size - 1) {\\n                ans += s.substr(left + 1, right - (left + 1) + 1) + \\" \\";\\n            } else if (ch != \' \' && left != size - 1 && s[left + 1] == \' \') {\\n                right = left;\\n            }\\n            left--;\\n        }\\n        ans += s.substr(0, right + 1);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-words-in-a-string","has_notes":false,"flag_type":1,"frontend_id":312},{"id":1765993990,"question_id":1078,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757506238,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1765993990/","is_pending":"Not Pending","title":"Remove Outermost Parentheses","memory":"8.9 MB","code":"class Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        string ans = \\"\\";\\n        int paranthesisCount = 0;\\n\\n        for (char& ch : s) {\\n            if (ch == \'(\') {\\n                if (paranthesisCount != 0)\\n                    ans += \\"(\\";\\n                paranthesisCount++;\\n            } else {\\n                if (paranthesisCount > 1)\\n                    ans += \\")\\";\\n                paranthesisCount--;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"remove-outermost-parentheses","has_notes":false,"flag_type":1,"frontend_id":311}],"has_next":true,"last_key":""}'
2026-01-10 09:25:26,304 [INFO] __main__.py:188 - Skipping smallest-absent-positive-greater-than-average 2025-09-13 20.25.32 because its status is 'Wrong Answer'
2026-01-10 09:25:26,304 [INFO] __main__.py:188 - Skipping smallest-absent-positive-greater-than-average 2025-09-13 20.18.05 because its status is 'Wrong Answer'
2026-01-10 09:25:26,305 [INFO] __main__.py:188 - Skipping smallest-absent-positive-greater-than-average 2025-09-13 20.15.55 because its status is 'Wrong Answer'
2026-01-10 09:25:29,469 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:29,472 [INFO] __main__.py:245 - Writing maximum-nesting-depth-of-the-parentheses/2025-09-13 19.19.14 - Accepted - runtime 0ms - memory 8.3MB.cpp
2026-01-10 09:25:29,473 [INFO] __main__.py:245 - Writing maximum-nesting-depth-of-the-parentheses/2025-09-13 19.15.22 - Accepted - runtime 2ms - memory 8.6MB.cpp
2026-01-10 09:25:31,640 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:31,643 [INFO] __main__.py:245 - Writing sort-characters-by-frequency/2025-09-13 13.49.54 - Accepted - runtime 0ms - memory 11.4MB.cpp
2026-01-10 09:25:31,644 [INFO] __main__.py:245 - Writing sort-characters-by-frequency/2025-09-13 13.37.18 - Accepted - runtime 1ms - memory 11.4MB.cpp
2026-01-10 09:25:31,645 [INFO] __main__.py:188 - Skipping sort-characters-by-frequency 2025-09-13 13.35.37 because its status is 'Runtime Error'
2026-01-10 09:25:33,127 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:33,130 [INFO] __main__.py:245 - Writing valid-anagram/2025-09-13 09.35.44 - Accepted - runtime 0ms - memory 9.6MB.cpp
2026-01-10 09:25:33,131 [INFO] __main__.py:245 - Writing valid-anagram/2025-09-13 09.33.09 - Accepted - runtime 7ms - memory 9.9MB.cpp
2026-01-10 09:25:34,523 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:34,526 [INFO] __main__.py:245 - Writing rotate-string/2025-09-13 00.37.59 - Accepted - runtime 0ms - memory 8.4MB.cpp
2026-01-10 09:25:34,841 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:34,845 [INFO] __main__.py:245 - Writing isomorphic-strings/2025-09-13 00.15.35 - Accepted - runtime 0ms - memory 9.3MB.cpp
2026-01-10 09:25:34,846 [INFO] __main__.py:245 - Writing isomorphic-strings/2025-09-12 23.39.58 - Accepted - runtime 0ms - memory 9.3MB.cpp
2026-01-10 09:25:34,846 [INFO] __main__.py:188 - Skipping isomorphic-strings 2025-09-12 22.42.21 because its status is 'Wrong Answer'
2026-01-10 09:25:35,258 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:35,260 [INFO] __main__.py:245 - Writing longest-common-prefix/2025-09-12 21.56.44 - Accepted - runtime 0ms - memory 12.1MB.cpp
2026-01-10 09:25:35,260 [INFO] __main__.py:188 - Skipping longest-common-prefix 2025-09-12 21.54.22 because its status is 'Wrong Answer'
2026-01-10 09:25:35,261 [INFO] __main__.py:245 - Writing longest-common-prefix/2025-09-12 21.33.35 - Accepted - runtime 0ms - memory 11.8MB.cpp
2026-01-10 09:25:35,588 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:35,590 [INFO] __main__.py:245 - Writing largest-odd-number-in-string/2025-09-12 20.19.19 - Accepted - runtime 7ms - memory 20.2MB.cpp
2026-01-10 09:25:35,911 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:35,913 [INFO] __main__.py:245 - Writing reverse-words-in-a-string/2025-09-12 19.04.03 - Accepted - runtime 0ms - memory 10.1MB.cpp
2026-01-10 09:25:36,224 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:36,228 [INFO] __main__.py:245 - Writing remove-outermost-parentheses/2025-09-10 17.40.38 - Accepted - runtime 0ms - memory 8.9MB.cpp
2026-01-10 09:25:41,234 [DEBUG] leetcode.py:150 - Exporting submissions from 240 to 260
2026-01-10 09:25:42,043 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=240&limit=20 HTTP/1.1" 200 None
2026-01-10 09:25:42,045 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1765610638,"question_id":2047,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757477344,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1765610638/","is_pending":"Not Pending","title":"Find a Peak Element II","memory":"50.5 MB","code":"class Solution {\\npublic:\\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\\n        int start = 0, end = mat[0].size();\\n    while (start <= end)\\n    {\\n      int mid = start + (end - start) / 2;\\n      auto maxi = INT_MIN, maxi_index = -1;\\n      for (int i = 0; i < mat.size(); i++)\\n      {\\n        if (mat[i][mid] > maxi)\\n        {\\n          maxi = mat[i][mid];\\n          maxi_index = i;\\n        }\\n      }\\n      int leftElement = mid - 1 < 0 ? -1 : mat[maxi_index][mid-1];\\n      int rightElement = mid + 1 >= mat[0].size() ? -1 : mat[maxi_index][mid+1];\\n      bool leftGreater = leftElement < mat[maxi_index][mid];\\n      bool rightGreater = mat[maxi_index][mid] > rightElement;\\n      if (leftGreater && rightGreater)\\n      {\\n        \\n        return {maxi_index,mid};\\n      }\\n      else if(leftElement < mat[maxi_index][mid] && mat[maxi_index][mid] < rightElement){\\n        start = mid+1;\\n      }else{\\n        end = mid-1;\\n      }\\n    }\\n    return {-1,-1};\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"find-a-peak-element-ii","has_notes":false,"flag_type":1,"frontend_id":310},{"id":1765606667,"question_id":2047,"lang":"cpp","lang_name":"C++","time":"3\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1757477040,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1765606667/","is_pending":"Not Pending","title":"Find a Peak Element II","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\\n        int start = 0, end = mat[0].size();\\n    while (start <= end)\\n    {\\n      int mid = start + (end - start) / 2;\\n      auto maxi = INT_MIN, maxi_index = -1;\\n      for (int i = 0; i < mat.size(); i++)\\n      {\\n        if (mat[i][mid] > maxi)\\n        {\\n          maxi = mat[i][mid];\\n          maxi_index = i;\\n        }\\n      }\\n      int leftElement = mid - 1 < 0 ? -1 : mat[maxi_index][mid-1];\\n      int rightElement = mid + 1 >= mat[0].size() ? -1 : mat[maxi_index][mid+1];\\n      bool leftGreater = leftElement < mat[maxi_index][mid];\\n      bool rightGreater = mat[maxi_index][mid] > rightElement;\\n      if (leftGreater && rightGreater)\\n      {\\n        \\n        return {maxi_index,mid};\\n      }\\n      else if(mat[0][mid-1] < mat[0][mid] && mat[0][mid] < mat[0][mid+1]){\\n        start = mid+1;\\n      }else{\\n        end = mid-1;\\n      }\\n    }\\n    return {-1,-1};\\n    }\\n};","compare_result":"1111111111111100000000000000000000000000000000000000000000","title_slug":"find-a-peak-element-ii","has_notes":false,"flag_type":1,"frontend_id":309},{"id":1765015838,"question_id":2047,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757428432,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1765015838/","is_pending":"Not Pending","title":"Find a Peak Element II","memory":"50.6 MB","code":"class Solution {\\npublic:\\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\\n        for (int row = 0; row < mat.size(); row++) {\\n            for (int col = 0; col < mat[0].size(); col++) {\\n            bool currentPeak = true;\\n                int top = row - 1, right = col + 1, left = col - 1,\\n                    bottom = row + 1;\\n                if (top >= 0 && (mat[top][col] >= mat[row][col]))\\n                    currentPeak = false;\\n                if (left >= 0 && (mat[row][left] >= mat[row][col]))\\n                    currentPeak = false;\\n                if (right < mat[0].size() && (mat[row][right] >= mat[row][col]))\\n                    currentPeak = false;\\n                if (bottom < mat.size() && (mat[bottom][col] >= mat[row][col]))\\n                    currentPeak = false;\\n\\n                if (currentPeak) {\\n                    return {row, col};\\n                }\\n            }\\n        }\\n        return {-1, -1};\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"find-a-peak-element-ii","has_notes":false,"flag_type":1,"frontend_id":308},{"id":1764488908,"question_id":4,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757390255,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1764488908/","is_pending":"Not Pending","title":"Median of Two Sorted Arrays","memory":"95.3 MB","code":"class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(),n2 = nums2.size();\\n        if(n1 > n2)return findMedianSortedArrays(nums2,nums1);\\n\\n        int leftHalfSize = (n1 + n2 + 1)/2;\\n\\n        int start = 0, end = n1;\\n\\n        while(start <= end){\\n            int mid1 = start + (end - start)/2; // No. Array1 Elements in Left Half\\n            int mid2 = leftHalfSize - mid1;// No. Array2 Elements in Left Half\\n\\n            int l1=INT_MIN,l2=INT_MIN,r1=INT_MAX,r2=INT_MAX;\\n            if(mid1-1>=0 && mid1-1 < n1 )l1 = nums1[mid1-1];\\n            if(mid2-1 >=0 && mid2-1 < n2 )l2 = nums2[mid2-1];\\n            if(mid1>=0 && mid1 < n1 )r1 = nums1[mid1];\\n            if(mid2>=0 && mid2 < n2 )r2 = nums2[mid2];\\n\\n            if(l1 <= r2 && l2 <= r1 ){\\n                if((n1+n2)%2==0){\\n                    //EVEN\\n                    long double ans = (long double)(max(l1,l2) + min(r1,r2))/(long double)2;\\n                    return ans;\\n                }else{\\n                    // Odd\\n                    long double ans = (long double)(max(l1,l2));\\n                    return ans;\\n                }\\n            }\\n            else if(l1 > r2){\\n                end = mid1-1;\\n            }else{\\n                start = mid1+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"median-of-two-sorted-arrays","has_notes":false,"flag_type":1,"frontend_id":307},{"id":1764487901,"question_id":4,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757390169,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1764487901/","is_pending":"Not Pending","title":"Median of Two Sorted Arrays","memory":"N/A","code":"class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(),n2 = nums2.size();\\n        if(n2 > n1)return findMedianSortedArrays(nums2,nums1);\\n\\n        int leftHalfSize = (n1 + n2 + 1)/2;\\n\\n        int start = 0, end = n1;\\n\\n        while(start <= end){\\n            int mid1 = start + (end - start)/2; // No. Array1 Elements in Left Half\\n            int mid2 = leftHalfSize - mid1;// No. Array2 Elements in Left Half\\n\\n            int l1=INT_MIN,l2=INT_MIN,r1=INT_MAX,r2=INT_MAX;\\n            if(mid1-1>=0 && mid1-1 < n1 )l1 = nums1[mid1-1];\\n            if(mid2-1 >=0 && mid2-1 < n2 )l2 = nums2[mid2-1];\\n            if(mid1>=0 && mid1 < n1 )r1 = nums1[mid1];\\n            if(mid2>=0 && mid2 < n2 )r2 = nums2[mid2];\\n\\n            if(l1 <= r2 && l2 <= r1 ){\\n                if((n1+n2)%2==0){\\n                    //EVEN\\n                    long double ans = (long double)(max(l1,l2) + min(r1,r2))/(long double)2;\\n                    return ans;\\n                }else{\\n                    // Odd\\n                    long double ans = (long double)(max(l1,l2));\\n                    return ans;\\n                }\\n            }\\n            else if(l1 > r2){\\n                end = mid1-1;\\n            }else{\\n                start = mid1+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};","compare_result":"111001101001001111110011011111111111111111111111111111111111111111111111111111111111111111111111111111111000000000011111100111111111111111111111111111111111111111111111100000011111111111111111111111111111111111111111100001111110011111111111111111100111111111111111111111111111111111111111111111100000000000000111111110000111111110011111111111111110000000000000000111111110011111111111111111111111111110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000011111111111111111111111111111111111111111111111111111111111111111111111100000011111111000011111111001111111111111111111111111111000011111111001111111111111111111111111111001111111111111111111111111111111111111111111111111111111111111111111100001111111100111111111111111111111111111100111111111111111111111111111111111111111111111111111111111111111111110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000001111111111000000111111111100001111111111001111111111111111111100000000000000000000000000111111111100001111111111001111111111111111111111111111111111111111000011111111110011111111111111111111111111111111111111110011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100010011011111111111110","title_slug":"median-of-two-sorted-arrays","has_notes":false,"flag_type":1,"frontend_id":306},{"id":1764379956,"question_id":4,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757377889,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1764379956/","is_pending":"Not Pending","title":"Median of Two Sorted Arrays","memory":"95.2 MB","code":"class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(),n2 = nums2.size();\\n        int count1 =( n1 + n2) / 2, count2 = count1 - 1,element1=-1,element2=-1;\\n        int i=0,j=0,ptr=0;\\n\\n        while(i<n1 && j < n2){\\n            if(nums1[i] < nums2[j]){\\n                if(ptr == count1) element2 = nums1[i];\\n                if(ptr == count2) element1 = nums1[i];\\n                i++;ptr++;\\n            }else{\\n                if(ptr == count1) element2 = nums2[j];\\n                if(ptr == count2) element1 = nums2[j];\\n                j++;ptr++;\\n            }\\n        }\\n        while(i < n1){\\n                if(ptr == count1) element2 = nums1[i];\\n                if(ptr == count2) element1 = nums1[i];\\n                i++;ptr++;\\n        }\\n        while(j<n2){\\n                if(ptr == count1) element2 = nums2[j];\\n                if(ptr == count2) element1 = nums2[j];\\n                j++;ptr++;\\n        }\\n\\n        if((n1 + n2) % 2 == 1){\\n            return (double)element2;\\n        }else{\\n            double ans = (double)(element1 + element2) / (double)2;\\n            return ans;\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"median-of-two-sorted-arrays","has_notes":false,"flag_type":1,"frontend_id":305},{"id":1763587442,"question_id":4,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757323184,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1763587442/","is_pending":"Not Pending","title":"Median of Two Sorted Arrays","memory":"N/A","code":"class Solution {\\npublic:\\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size(), n2 = nums2.size(), element1, element2;\\n    int ptr1 = 0, ptr2 = 0, ptr3 = 0, count = (n1 + n2) / 2;\\n    while (ptr1 < nums1.size() && ptr2 < nums2.size())\\n    {\\n      if (nums1[ptr1] < nums2[ptr2])\\n      {\\n        if (ptr3 == count-1)\\n        {\\n          element1 = nums1[ptr1];\\n        }\\n        else if (ptr3 == count)\\n        {\\n          element2 = nums1[ptr1];\\n          break;\\n        }\\n        ptr1++;\\n        ptr3++;\\n      }\\n      else\\n      {\\n        if (ptr3 == count-1)\\n        {\\n          element1 = nums2[ptr2];\\n        }\\n        else if (ptr3 == count)\\n        {\\n          element2 = nums2[ptr2];break;\\n        }\\n        ptr2++;\\n        ptr3++;\\n      }\\n    }\\n\\n    while (ptr1 < nums1.size())\\n    {\\n      if (ptr3 == count-1)\\n      {\\n        element1 = nums1[ptr1];\\n      }\\n      else if (ptr3 == count)\\n      {\\n        element2 = nums1[ptr1];break;\\n      }\\n      ptr1++;\\n      ptr3++;\\n    }\\n    while (ptr2 < nums2.size())\\n    {\\n      if (ptr3 == count-1)\\n      {\\n        element1 = nums2[ptr2];\\n      }\\n      else if (ptr3 == count)\\n      {\\n        element2 = nums2[ptr2];break;\\n      }\\n      ptr2++;\\n      ptr3++;\\n    }\\n    long double median = -1;\\n    if ((n1 + n2) % 2 == 1)\\n    {\\n      // odd\\n      median = (long double)element2;\\n    }\\n    else\\n    {\\n      median = (long double)(element1 + element2) / (long double)2;\\n    }\\n    return median;\\n    }\\n};","compare_result":"111110010110111111111111110110101111011111111111111101101111011001011111101101011011010011010010110111111011010111101101011011010011010010110101101100101100100111111110110101011110110101011011010100110101001010110101011011010100110101001010110101001101010010101101010010101101010010101101111111101101010111111011010101111011010101101101010011010100101011010101111011010101101101010011010100101011010101101101010011010100101011010100110101001010110101001010110101001010110101110111000111011100011100011100010111000111000111000100011100010001111111111011010101011111101101010101111011010101011011010101001101010100101010110101010101011110110101010110110101010011010101001010101101010101010110110101010011010101001010101101010101010011010101001010101101010101010010101011010101010100101010101011010101011011010101001101010100101010110101010101001101010100101010110101010101001010101101010101010010101010101101010100110101010010101011010101010100101010110101010101001010101010110101010010101011010101010100101010101011010101001010101010110101010010101011011111111110110101010111111110110101010111111011010101011110110101010110110101010011010101001010101101010101010111111011010101011110110101010110110101010011010101001010101101010101010111101101010101101101010100110101010010101011010101010101101101010100110101010010101011010101010100110101010010101011010101010100101010110101010101001010101010110101010111101101010101101101010100110101010010101011010101010101101101010100110101010010101011010101010100110101010010101011010101010100101010110101010101001010101010110101010110110101010011010101001010101101010101010011010101001010101101010101010010101011010101010100101010101011010101001101010100101010110101010101001010101101010101010010101010101101010100101010110101010101001010101010110101010010101010101101010100101010110101111011110000111111011110000111111000011111100000011110111100001111110000111111000000111100001111110000001111000000111100001011110000111111000011111100000011110000111111000000111100000011110000100001111110000001111000000111100001000000111100001000011111001110100001111110111","title_slug":"median-of-two-sorted-arrays","has_notes":false,"flag_type":1,"frontend_id":304},{"id":1762135857,"question_id":3998,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757215022,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1762135857/","is_pending":"Not Pending","title":"Minimum Operations to Equalize Array","memory":"N/A","code":"class Solution {\\n    bool isEqual(vector<int>& arr) {\\n        for (int i = 0; i < arr.size() - 1; i++) {\\n            if (arr[i] != arr[i + 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int size = nums.size();\\n        if (size <= 1)\\n            return 0;\\n        int minimumOps = INT_MAX;\\n        if (isEqual(nums))\\n            return 0;\\n\\n        for (int i = 0; i < size; i++) {\\n            int operations = 0;\\n            vector<int> arr = nums;\\n            int bitwiseAND = arr[i];\\n            for (int j = i + 1; j < size; j++) {\\n                bitwiseAND = bitwiseAND & arr[j];\\n                operations++;\\n            }\\n            for (int j = i; j < size; j++) {\\n                arr[j] = bitwiseAND;\\n            }\\n\\n            if (isEqual(arr)) {\\n\\n                minimumOps = min(minimumOps, operations);\\n            }\\n        }\\n        return minimumOps;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000000000000000000000000000000000000000000000001111111111111111111111111111111111111110000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000001111111111111111111111111111111111111111111000000000111111000001111110000011111000000001111111111000000011111000001111111111000000111100000000001111100000000000111111000011110000011111000000001111111100000111111110000011111110000000111111111110011110001010110111110001000111100111000001100011110110010001011111111011001001111110011110000110011000010011000011000000011111110011111000110000100000010000001111110001100000111001111111100000001110110000101111000001010101100100111001011010111010011111000000000000000000101001010000000","title_slug":"minimum-operations-to-equalize-array","has_notes":false,"flag_type":1,"frontend_id":303},{"id":1762099251,"question_id":3999,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757213734,"status":10,"status_display":"Accepted","runtime":"35 ms","url":"/submissions/detail/1762099251/","is_pending":"Not Pending","title":"Minimum Operations to Transform String","memory":"59.8 MB","code":"class Solution {\\npublic:\\n    int minOperations(string s) {\\n        int operations = 0;\\n        int maxDistance = INT_MIN;\\n\\n        // if(s.size() == 1 && s[0] == \'a\')return 0;\\n\\n        for(int i=0; i<s.size();i++){\\n            int currentDistance1 = \'z\' - s[i]; // Do + 1\\n            if(currentDistance1 == 25)currentDistance1 = -1;\\n            maxDistance = max(currentDistance1,maxDistance);\\n        }\\n        return maxDistance+1;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-operations-to-transform-string","has_notes":false,"flag_type":1,"frontend_id":302},{"id":1760145292,"question_id":410,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1757053703,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1760145292/","is_pending":"Not Pending","title":"Split Array Largest Sum","memory":"10.4 MB","code":"class Solution {\\npublic:\\n    int splitArray(vector<int>& nums, int k) {\\n        int start = *max_element(nums.begin(),nums.end()),end = accumulate(nums.begin(),nums.end(),0);\\n        int answer = 0;\\n        if(nums.size()<k)return -1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int countSubarray=1,sumSubArr = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                if(sumSubArr + nums[i] > mid){\\n                    sumSubArr = nums[i];\\n                    countSubarray++;\\n                }else{\\n                    sumSubArr += nums[i];\\n                }\\n            }\\n\\n            if(countSubarray > k){\\n                start = mid+1;\\n            }else{\\n                answer = mid;\\n                end = mid-1;\\n            }\\n        }\\n        return answer;\\n    }\\n};","compare_result":"1111111111111111111111111111111111","title_slug":"split-array-largest-sum","has_notes":false,"flag_type":1,"frontend_id":301},{"id":1758883391,"question_id":1646,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1756956972,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1758883391/","is_pending":"Not Pending","title":"Kth Missing Positive Number","memory":"13.3 MB","code":"class Solution {\\npublic:\\n    int findKthPositive(vector<int>& arr, int k) {\\n        int arrSize = arr.size();\\n        int start = 0,end = arrSize-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int missing = arr[mid] - (mid+1);\\n            if(missing < k)start = mid+1;\\n            else end = mid-1;\\n        }\\n        if(end <= -1)return k;\\n        return (k + (end +1));\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"kth-missing-positive-number","has_notes":false,"flag_type":1,"frontend_id":300},{"id":1758882625,"question_id":1646,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1756956904,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1758882625/","is_pending":"Not Pending","title":"Kth Missing Positive Number","memory":"N/A","code":"class Solution {\\npublic:\\n    int findKthPositive(vector<int>& arr, int k) {\\n        int arrSize = arr.size();\\n        int start = 0,end = arrSize-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int missing = arr[mid] - (mid+1);\\n            if(missing < k)start = mid+1;\\n            else end = mid-1;\\n        }\\n        if(arr[end] <= -1)return k;\\n        return (k + (end +1));\\n    }\\n};","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"kth-missing-positive-number","has_notes":false,"flag_type":1,"frontend_id":299},{"id":1758880491,"question_id":1646,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months","timestamp":1756956725,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1758880491/","is_pending":"Not Pending","title":"Kth Missing Positive Number","memory":"N/A","code":"class Solution {\\npublic:\\n    int findKthPositive(vector<int>& arr, int k) {\\n        int arrSize = arr.size();\\n        int start = 0,end = arrSize-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int missing = arr[mid] - (mid+1);\\n            if(missing < k)start = mid+1;\\n            else end = mid-1;\\n        }\\n        if(arr[end] <= -1)return k;\\n        return (arr[end] + (k - (arr[end]-(end +1))));\\n    }\\n};","compare_result":"111000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"kth-missing-positive-number","has_notes":false,"flag_type":1,"frontend_id":298},{"id":1754291641,"question_id":3915,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756612694,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1754291641/","is_pending":"Not Pending","title":"Maximum Product of Two Integers With No Common Bits","memory":"N/A","code":"class Solution {\\n    long long max(long long n1,long long n2){\\n        if(n1 > n2)return n1;\\n        return n2;\\n    }\\npublic:\\n    long long maxProduct(vector<int>& nums) {\\n        vector<int>arr = nums;\\n        sort(arr.begin(),arr.end());\\n\\n        int start = 0,end = arr.size()-1;\\n        long long maximumProd = 0,totalProd=1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    long long currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        start = 0,end = arr.size()-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    long long currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return maximumProd;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111101111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111110111111111111111011111111111111111111111111101111111111111111111111111111111111010111111111111111111011111111111111111111011111111111111111111111111111111111111111110111111111111111111111111111111111011111101011111111111111011011111111110111011111111111111101111100100000000110001100000100110100010000000000101000000000010010100000000011000010000000000000000010000000100000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000001100000000000000000","title_slug":"maximum-product-of-two-integers-with-no-common-bits","has_notes":false,"flag_type":1,"frontend_id":297},{"id":1754275114,"question_id":3915,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756611991,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1754275114/","is_pending":"Not Pending","title":"Maximum Product of Two Integers With No Common Bits","memory":"N/A","code":"class Solution {\\n    long long max(long long n1,long long n2){\\n        if(n1 > n2)return n1;\\n        return n2;\\n    }\\npublic:\\n    long long maxProduct(vector<int>& nums) {\\n        vector<int>arr = nums;\\n        sort(arr.begin(),arr.end());\\n\\n        int start = 1,end = arr.size()-1;\\n        long long maximumProd = 0,totalProd=1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    long long currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        start = 1,end = arr.size()-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    long long currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return maximumProd;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111101111111111111111111111111111111110011111111111111111111011111111111111111111111001111111111111111111111111011111111111110111111111111111111111111111111110111111111111111111111110011111111111111111111111111111111111111000110010110110001100000100010101010100000001101000001000010010100000000011010010010000001000000010100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100000000000000000","title_slug":"maximum-product-of-two-integers-with-no-common-bits","has_notes":false,"flag_type":1,"frontend_id":296},{"id":1754255817,"question_id":3915,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756611161,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1754255817/","is_pending":"Not Pending","title":"Maximum Product of Two Integers With No Common Bits","memory":"N/A","code":"class Solution {\\n    long long max(long long n1,long long n2){\\n        if(n1 > n2)return n1;\\n        return n2;\\n    }\\npublic:\\n    long long maxProduct(vector<int>& nums) {\\n        vector<int>arr = nums;\\n        sort(arr.begin(),arr.end());\\n\\n        int start = arr.size()-2,end = arr.size()-1;\\n        long long maximumProd = 0,totalProd=1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    long long currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        start = 1,end = arr.size()-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            for(int j=arr.size()-1;j>=0;j--){\\n                if(j == mid)continue;\\n                if((arr[mid] & arr[j]) == 0){\\n                    int currentProd=arr[mid]*arr[j];\\n                    maximumProd = max(maximumProd,currentProd);\\n                    break;\\n                }\\n            }\\n            if(maximumProd == 0){\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return maximumProd;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111101111101111111111110111111111101111101111101111111101111111111111111111101101111111111111111111101111111111111111111111111111111111111111111011101111100111111111111111111111111111111111011111111111111111110111111111111111111111111111111011111111111111111111111111111111111111111111111111111011010111111111111111011111111111111110111111111110111111111111111111111110111111110111110011100100101111111111111001111111111111011111111111101111010110111100000101000110100001010010010010100001110000000001000000000100000100000000001100000001000001000000000100000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001100000000000000000","title_slug":"maximum-product-of-two-integers-with-no-common-bits","has_notes":false,"flag_type":1,"frontend_id":295},{"id":1754177667,"question_id":4008,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756607741,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1754177667/","is_pending":"Not Pending","title":"Restore Finishing Order","memory":"50.2 MB","code":"class Solution {\\npublic:\\n    vector<int> recoverOrder(vector<int>& order, vector<int>& friends) {\\n        vector<int>ans;\\n        for(int i=0; i<order.size();i++){\\n            if(find(friends.begin(),friends.end(),order[i]) != friends.end()){\\n                ans.push_back(order[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"restore-finishing-order","has_notes":false,"flag_type":1,"frontend_id":294},{"id":1753631361,"question_id":3994,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756565767,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1753631361/","is_pending":"Not Pending","title":"Find The Least Frequent Digit","memory":"8.9 MB","code":"class Solution {\\npublic:\\n    int getLeastFrequentDigit(int n) {\\n        map<int,int>map;\\n        int nCpy = n,remainder;\\n        while(nCpy != 0){\\n           remainder = nCpy %10;\\n            map[remainder]++;\\n            nCpy /= 10;\\n        }\\n\\n        int leastDigit=INT_MAX,leastFreq = INT_MAX;\\n        for(auto &it:map){\\n            if(it.second >= leastFreq)continue;\\n            \\n            leastFreq = min(it.second,leastFreq);\\n            \\n            leastDigit = it.first;\\n\\n        }\\n        return leastDigit;\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-least-frequent-digit","has_notes":false,"flag_type":1,"frontend_id":293},{"id":1753437712,"question_id":1056,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756554172,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1753437712/","is_pending":"Not Pending","title":"Capacity To Ship Packages Within D Days","memory":"35 MB","code":"class Solution {\\npublic:\\n    int shipWithinDays(vector<int>& weights, int days) {\\n        int  sumArr = accumulate(weights.begin(),weights.end(),0);\\n        int maxi = *max_element(weights.begin(),weights.end());\\n        int start = maxi,end = sumArr,finalCapacity=-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int currentDays = 1, currentPackageWeight = 0;\\n            for(auto &package : weights){\\n                if(currentPackageWeight + package > mid){\\n                    currentDays++;currentPackageWeight = package;\\n                }else{\\n                    currentPackageWeight += package;\\n                }\\n            }\\n\\n            if(currentDays <= days){\\n                finalCapacity = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return finalCapacity;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"capacity-to-ship-packages-within-d-days","has_notes":false,"flag_type":1,"frontend_id":292},{"id":1753308398,"question_id":1408,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756545176,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1753308398/","is_pending":"Not Pending","title":"Find the Smallest Divisor Given a Threshold","memory":"26 MB","code":"class Solution {\\n    int findMax(vector<int>&nums){\\n        int maxi = INT_MIN;\\n        for(auto& element:nums){\\n            maxi = max(maxi,element);\\n        }\\n        return maxi;\\n    }\\n    int calculateSum(vector<int>&nums,int threshold,int divisor){\\n        int currentSum = 0;\\n        for(auto &element:nums){\\n            currentSum += ceil((double)element / (double)divisor);\\n            if(currentSum > threshold)return currentSum;\\n        }\\n        return currentSum;\\n    }\\npublic:\\n    int smallestDivisor(vector<int>& nums, int threshold) {\\n        int maxElement = findMax(nums);\\n        int start = 1,end = maxElement,finalDivisor=-1;\\n\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            int currentSum = calculateSum(nums,threshold,mid);\\n            if(currentSum <= threshold){\\n                finalDivisor = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return finalDivisor;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-the-smallest-divisor-given-a-threshold","has_notes":false,"flag_type":1,"frontend_id":291}],"has_next":true,"last_key":""}'
2026-01-10 09:25:42,394 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:42,396 [INFO] __main__.py:245 - Writing find-a-peak-element-ii/2025-09-10 09.39.04 - Accepted - runtime 0ms - memory 50.5MB.cpp
2026-01-10 09:25:42,397 [INFO] __main__.py:188 - Skipping find-a-peak-element-ii 2025-09-10 09.34.00 because its status is 'Runtime Error'
2026-01-10 09:25:42,397 [INFO] __main__.py:245 - Writing find-a-peak-element-ii/2025-09-09 20.03.52 - Accepted - runtime 0ms - memory 50.6MB.cpp
2026-01-10 09:25:42,720 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:42,723 [INFO] __main__.py:245 - Writing median-of-two-sorted-arrays/2025-09-09 09.27.35 - Accepted - runtime 0ms - memory 95.3MB.cpp
2026-01-10 09:25:42,724 [INFO] __main__.py:188 - Skipping median-of-two-sorted-arrays 2025-09-09 09.26.09 because its status is 'Wrong Answer'
2026-01-10 09:25:42,724 [INFO] __main__.py:245 - Writing median-of-two-sorted-arrays/2025-09-09 06.01.29 - Accepted - runtime 0ms - memory 95.2MB.cpp
2026-01-10 09:25:42,725 [INFO] __main__.py:188 - Skipping median-of-two-sorted-arrays 2025-09-08 14.49.44 because its status is 'Wrong Answer'
2026-01-10 09:25:42,725 [INFO] __main__.py:188 - Skipping minimum-operations-to-equalize-array 2025-09-07 08.47.02 because its status is 'Wrong Answer'
2026-01-10 09:25:44,924 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:44,928 [INFO] __main__.py:245 - Writing minimum-operations-to-transform-string/2025-09-07 08.25.34 - Accepted - runtime 35ms - memory 59.8MB.cpp
2026-01-10 09:25:45,554 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:45,557 [INFO] __main__.py:245 - Writing split-array-largest-sum/2025-09-05 11.58.23 - Accepted - runtime 0ms - memory 10.4MB.cpp
2026-01-10 09:25:45,877 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:45,881 [INFO] __main__.py:245 - Writing kth-missing-positive-number/2025-09-04 09.06.12 - Accepted - runtime 0ms - memory 13.3MB.cpp
2026-01-10 09:25:45,882 [INFO] __main__.py:188 - Skipping kth-missing-positive-number 2025-09-04 09.05.04 because its status is 'Runtime Error'
2026-01-10 09:25:45,882 [INFO] __main__.py:188 - Skipping kth-missing-positive-number 2025-09-04 09.02.05 because its status is 'Runtime Error'
2026-01-10 09:25:45,882 [INFO] __main__.py:188 - Skipping maximum-product-of-two-integers-with-no-common-bits 2025-08-31 09.28.14 because its status is 'Wrong Answer'
2026-01-10 09:25:45,883 [INFO] __main__.py:188 - Skipping maximum-product-of-two-integers-with-no-common-bits 2025-08-31 09.16.31 because its status is 'Wrong Answer'
2026-01-10 09:25:45,883 [INFO] __main__.py:188 - Skipping maximum-product-of-two-integers-with-no-common-bits 2025-08-31 09.02.41 because its status is 'Wrong Answer'
2026-01-10 09:25:47,050 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:47,052 [INFO] __main__.py:245 - Writing restore-finishing-order/2025-08-31 08.05.41 - Accepted - runtime 0ms - memory 50.2MB.cpp
2026-01-10 09:25:47,370 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:47,373 [INFO] __main__.py:245 - Writing find-the-least-frequent-digit/2025-08-30 20.26.07 - Accepted - runtime 0ms - memory 8.9MB.cpp
2026-01-10 09:25:47,831 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:47,833 [INFO] __main__.py:245 - Writing capacity-to-ship-packages-within-d-days/2025-08-30 17.12.52 - Accepted - runtime 6ms - memory 35MB.cpp
2026-01-10 09:25:48,459 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:48,462 [INFO] __main__.py:245 - Writing find-the-smallest-divisor-given-a-threshold/2025-08-30 14.42.56 - Accepted - runtime 15ms - memory 26MB.cpp
2026-01-10 09:25:53,468 [DEBUG] leetcode.py:150 - Exporting submissions from 260 to 280
2026-01-10 09:25:56,390 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=260&limit=20 HTTP/1.1" 200 None
2026-01-10 09:25:56,392 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1753256515,"question_id":36,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756541320,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1753256515/","is_pending":"Not Pending","title":"Valid Sudoku","memory":"21.6 MB","code":"class Solution {\\n    void isPossible(vector < vector<char>> &board, int row, int col,\\n                    bool& isValid) {\\n        for (int i = 0; i < 9; i++) {\\n            if (i==row || col==i)\\n                continue;\\n            if (board[row][col] == board[row][i] ||\\n                board[row][col] == board[i][col]){\\n                isValid = false;return;}\\n        }\\n        int boxRow,boxCol;\\n        if(row >=0 && row < 3)boxRow=0;\\n        if(row >=3 && row < 6)boxRow=3;\\n        if(row >=6 && row < 9)boxRow=6;\\n        if(col >=0 && col < 3)boxCol=0;\\n        if(col >=3 && col < 6)boxCol=3;\\n        if(col >=6 && col < 9)boxCol=6;\\n        int cnt=0;\\n        for(int i=boxRow;i<boxRow+3;i++){\\n            for(int j=boxCol;j<boxCol+3;j++){\\n                \\n                if(board[row][col] == board[i][j]){\\n                    cnt++;\\n                }\\n                if(cnt>=2){isValid=false;return;}\\n            }\\n        }\\n        isValid = true;\\n    }\\n\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool isValid = true;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] - \'0\' >= 0 && board[i][j] - \'0\' <= 9) {\\n                    isPossible(board, i, j, isValid);\\n                    if (!isValid)\\n                        return false;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-sudoku","has_notes":false,"flag_type":1,"frontend_id":290},{"id":1753254371,"question_id":36,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756541155,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1753254371/","is_pending":"Not Pending","title":"Valid Sudoku","memory":"N/A","code":"class Solution {\\n    void isPossible(vector < vector<char>> &board, int row, int col,\\n                    bool& isValid) {\\n        for (int i = 0; i < 9; i++) {\\n            if (board[row][col])\\n                continue;\\n            if (board[row][col] == board[row][i] ||\\n                board[row][col] == board[i][col]){\\n                isValid = false;return;}\\n        }\\n        int boxRow,boxCol;\\n        if(row >=0 && row < 3)boxRow=0;\\n        if(row >=3 && row < 6)boxRow=3;\\n        if(row >=6 && row < 9)boxRow=6;\\n        if(col >=0 && col < 3)boxCol=0;\\n        if(col >=3 && col < 6)boxCol=3;\\n        if(col >=6 && col < 9)boxCol=6;\\n        int cnt=0;\\n        for(int i=boxRow;i<boxRow+3;i++){\\n            for(int j=boxCol;j<boxCol+3;j++){\\n                \\n                if(board[row][col] == board[i][j]){\\n                    cnt++;\\n                }\\n                if(cnt>=2){isValid=false;return;}\\n            }\\n        }\\n        isValid = true;\\n    }\\n\\npublic:\\n    bool isValidSudoku(vector<vector<char>>& board) {\\n        bool isValid = true;\\n        for (int i = 0; i < board.size(); i++) {\\n            for (int j = 0; j < board[0].size(); j++) {\\n                if (board[i][j] - \'0\' >= 0 && board[i][j] - \'0\' <= 9) {\\n                    isPossible(board, i, j, isValid);\\n                    if (!isValid)\\n                        return false;\\n                }\\n            }\\n        }\\n        return isValid;\\n    }\\n};","compare_result":"111110111101001111110111111111111111111111111111101011110101111111111111111111111111101101111111111011010000011000111111110101111100100101111110111111111111001101110001111111111010101001111101000111101111110111001011111111101101111000111011110100111111111001101110110000100001111111100111111010011111010001111110011010111100011101011111101111010110101111101111011110011101111010111111000100011011011111010111110010111111100101001011111111111011110100111111001110111111101111101111011010010011101101001110111","title_slug":"valid-sudoku","has_notes":false,"flag_type":1,"frontend_id":289},{"id":1753227804,"question_id":3279,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756539147,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1753227804/","is_pending":"Not Pending","title":"Alice and Bob Playing Flower Game","memory":"8.6 MB","code":"class Solution {\\npublic:\\n    long long flowerGame(int n, int m) {\\n        int nOdd = (n+1)/2,nEven = n/2,mOdd=(m+1)/2,mEven=m/2;\\n        return 1ll*nOdd*mEven + 1ll*mOdd*nEven;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"alice-and-bob-playing-flower-game","has_notes":false,"flag_type":1,"frontend_id":288},{"id":1753227381,"question_id":3279,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756539115,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1753227381/","is_pending":"Not Pending","title":"Alice and Bob Playing Flower Game","memory":"N/A","code":"class Solution {\\npublic:\\n    long long flowerGame(int n, int m) {\\n        int nOdd = (n+1)/2,nEven = n/2,mOdd=(m+1)/2,mEven=m/2;\\n        return nOdd*mEven + mOdd*nEven;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000","title_slug":"alice-and-bob-playing-flower-game","has_notes":false,"flag_type":1,"frontend_id":287},{"id":1752942378,"question_id":1605,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756509262,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1752942378/","is_pending":"Not Pending","title":"Minimum Number of Days to Make m Bouquets","memory":"70.5 MB","code":"class Solution {\\n    void findMaxMin(vector<int>&bloomDay,int &maxi,int &mini){\\n        for(auto &element:bloomDay){\\n            maxi = max(maxi,element);\\n            mini = min(mini,element);\\n        }\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int maxi = INT_MIN,mini = INT_MAX,minDays=-1;\\n        findMaxMin(bloomDay,maxi,mini);\\n        int size = bloomDay.size();\\n        if(size < (long long)m*k){\\n            return -1;\\n        }\\n\\n        int start = mini,end = maxi;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            int count=0,bouquetsFormed= 0;\\n            for(int i=0; i<bloomDay.size();i++){\\n                if(bloomDay[i] <= mid)count++;\\n                else{\\n                    bouquetsFormed += count / k ;\\n                    count=0;\\n                }\\n            }\\n            bouquetsFormed += count / k ;\\n            if(bouquetsFormed >= m){\\n                minDays = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n\\n        }\\n        return minDays;\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-number-of-days-to-make-m-bouquets","has_notes":false,"flag_type":1,"frontend_id":286},{"id":1752942037,"question_id":1605,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756509202,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1752942037/","is_pending":"Not Pending","title":"Minimum Number of Days to Make m Bouquets","memory":"N/A","code":"class Solution {\\n    void findMaxMin(vector<int>&bloomDay,int &maxi,int &mini){\\n        for(auto &element:bloomDay){\\n            maxi = max(maxi,element);\\n            mini = min(mini,element);\\n        }\\n    }\\npublic:\\n    int minDays(vector<int>& bloomDay, int m, int k) {\\n        int maxi = INT_MIN,mini = INT_MAX,minDays=-1;\\n        findMaxMin(bloomDay,maxi,mini);\\n        int size = bloomDay.size();\\n        if(size < m*k){\\n            return -1;\\n        }\\n\\n        int start = mini,end = maxi;\\n        while(start <= end){\\n            int mid = start + (end-start)/2;\\n            int count=0,bouquetsFormed= 0;\\n            for(int i=0; i<bloomDay.size();i++){\\n                if(bloomDay[i] <= mid)count++;\\n                else{\\n                    bouquetsFormed += count / k ;\\n                    count=0;\\n                }\\n            }\\n            bouquetsFormed += count / k ;\\n            if(bouquetsFormed >= m){\\n                minDays = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n\\n        }\\n        return minDays;\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100","title_slug":"minimum-number-of-days-to-make-m-bouquets","has_notes":false,"flag_type":1,"frontend_id":285},{"id":1752909490,"question_id":907,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756503786,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1752909490/","is_pending":"Not Pending","title":"Koko Eating Bananas","memory":"22.9 MB","code":"class Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int size=piles.size(),maxElement = INT_MIN,ans=-1;\\n\\n        for(int i=0; i<size;i++)maxElement = max(maxElement,piles[i]);\\n        int start = 1,end = maxElement;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            long long currentSum=0;\\n            for(auto &element:piles){\\n                currentSum += ceil((double(element)/double(mid)));\\n            }\\n            if(currentSum <= h){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"koko-eating-bananas","has_notes":false,"flag_type":1,"frontend_id":284},{"id":1752908552,"question_id":907,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 1\xc2\xa0week","timestamp":1756503649,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1752908552/","is_pending":"Not Pending","title":"Koko Eating Bananas","memory":"N/A","code":"class Solution {\\npublic:\\n    int minEatingSpeed(vector<int>& piles, int h) {\\n        int size=piles.size(),maxElement = INT_MIN,ans=-1;\\n\\n        for(int i=0; i<size;i++)maxElement = max(maxElement,piles[i]);\\n        int start = 1,end = maxElement;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            int currentSum=0;\\n            for(auto &element:piles){\\n                currentSum += ceil((double(element)/double(mid)));\\n            }\\n            if(currentSum <= h){\\n                ans = mid;\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000","title_slug":"koko-eating-bananas","has_notes":false,"flag_type":1,"frontend_id":283},{"id":1749664845,"question_id":162,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756261273,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749664845/","is_pending":"Not Pending","title":"Find Peak Element","memory":"12.5 MB","code":"class Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n        int start = 1,size = nums.size(),end = size-2;\\n        if(size == 1 || nums[0]>nums[1])return 0;\\n        if(nums[size-1]>nums[size-2])return size-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid-1]<nums[mid] && nums[mid] > nums[mid+1]){\\n                return mid;\\n            }\\n            if(nums[mid-1]<nums[mid] && nums[mid] < nums[mid+1]){\\n                start=mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-peak-element","has_notes":false,"flag_type":1,"frontend_id":282},{"id":1749648984,"question_id":540,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756259125,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749648984/","is_pending":"Not Pending","title":"Single Element in a Sorted Array","memory":"26.1 MB","code":"class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums[0]!= nums[1])return nums[0];\\n        if(nums[nums.size()-1]!=nums[nums.size()-2])return nums[nums.size()-1];\\n\\n        int start = 1,end = nums.size()-2;\\n\\n        while(start <=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid]!=nums[mid-1] && nums[mid]!=nums[mid+1])return nums[mid];\\n            if(((mid%2==0) && nums[mid]==nums[mid+1]) || ((mid%2==1) && nums[mid]==nums[mid-1]))start = mid+1;\\n            else end = mid-1;\\n        }\\n        return -1;\\n    }\\n};","compare_result":"1111111111111111","title_slug":"single-element-in-a-sorted-array","has_notes":false,"flag_type":1,"frontend_id":281},{"id":1749647224,"question_id":540,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756258873,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1749647224/","is_pending":"Not Pending","title":"Single Element in a Sorted Array","memory":"N/A","code":"class Solution {\\npublic:\\n    int singleNonDuplicate(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        if(nums[0]!= nums[1])return nums[0];\\n        if(nums[nums.size()-1]!=nums[nums.size()-2])return nums[nums.size()-1];\\n\\n        int start = 1,end = nums.size()-1;\\n\\n        while(start <=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid]!=nums[mid-1] && nums[mid]!=nums[mid+1])return nums[mid];\\n            if((mid&0 && nums[mid]==nums[mid+1]) || (mid&1 && nums[mid]==nums[mid-1]))start = mid+1;\\n            else end = mid-1;\\n        }\\n        return -1;\\n    }\\n};","compare_result":"1111111111111001","title_slug":"single-element-in-a-sorted-array","has_notes":false,"flag_type":1,"frontend_id":280},{"id":1749473853,"question_id":153,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756237397,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749473853/","is_pending":"Not Pending","title":"Find Minimum in Rotated Sorted Array","memory":"14.2 MB","code":"class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1,minElement = INT_MAX;\\n        while(start <= end){\\n            int mid = start+(end-start)/2;\\n            if(nums[start]<=nums[mid]){\\n                minElement = min(minElement,nums[start]);\\n                start = mid+1;\\n            }else{\\n                minElement = min(minElement,nums[mid]);\\n                end = mid-1;\\n            }\\n        }\\n        return minElement;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-minimum-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":279},{"id":1749230586,"question_id":81,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756225441,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749230586/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array II","memory":"17.8 MB","code":"class Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size()-1;\\n        bool ans = false;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n            if(nums[start] == nums[mid] && nums[mid] == nums[end]){\\n                start++;end--;continue;\\n            }\\n            if(nums[start] <= nums[mid]){\\n                if(nums[start] <= target && target <= nums[mid]){\\n                    end = mid - 1;\\n                }else{  \\n                    start = mid+1;\\n                }\\n            }else{  \\n                if(nums[mid]<=target && target <= nums[end]){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-in-rotated-sorted-array-ii","has_notes":false,"flag_type":1,"frontend_id":278},{"id":1749227371,"question_id":81,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756225287,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1749227371/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array II","memory":"N/A","code":"class Solution {\\npublic:\\n    bool search(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size()-1;\\n        bool ans = false;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target){\\n                return true;\\n            }\\n            if(nums[start] == nums[mid] && nums[mid] == nums[end]){\\n                start++;end--;continue;\\n            }\\n            if(nums[start] <= nums[mid]){\\n                if(nums[start] <= target && target <= nums[end]){\\n                    end = mid - 1;\\n                }else{  \\n                    start = mid+1;\\n                }\\n            }else{  \\n                if(nums[mid]<=target && target <= nums[end]){\\n                    start = mid+1;\\n                }else{\\n                    end = mid-1;\\n                }\\n\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111001111111101111111111111011111111111111110111101111111111111011110111111111111110111101111111111111111110100011111111111111101111111111111111101111100111111111111111111111111111111111111110111111110111111111111111111101111111111101111111111111101011111110001111011111011011111","title_slug":"search-in-rotated-sorted-array-ii","has_notes":false,"flag_type":1,"frontend_id":277},{"id":1749184980,"question_id":33,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756223146,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749184980/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"15.3 MB","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start =0,end= nums.size()-1,ans = -1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid]==target){ans = mid;break;}\\n            if(nums[start] <= nums[mid]){\\n                if(nums[start]<=target && target <= nums[mid])end = mid-1;\\n                else start = mid+1;\\n            }else{\\n                if(nums[mid]<=target && target<=nums[end])start=mid+1;\\n                else end = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":276},{"id":1749179474,"question_id":33,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756222855,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1749179474/","is_pending":"Not Pending","title":"Search in Rotated Sorted Array","memory":"15.2 MB","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target ){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-in-rotated-sorted-array","has_notes":false,"flag_type":1,"frontend_id":275},{"id":1747332884,"question_id":34,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756098891,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1747332884/","is_pending":"Not Pending","title":"Find First and Last Position of Element in Sorted Array","memory":"17.7 MB","code":"class Solution {\\n    void find_first(vector<int>&arr,int start,int end,int &firstOcc,int target){\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(arr[mid]==target){\\n                firstOcc = mid;\\n                end = mid - 1;\\n            }else if(arr[mid] > target){\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n    }\\n    void find_last(vector<int>&arr,int start,int end,int &lastOcc,int target){\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(arr[mid]==target){\\n                lastOcc = mid;\\n                start = mid + 1;\\n            }else if(arr[mid] > target){\\n                end = mid-1;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n    }\\npublic:\\n    vector<int> searchRange(vector<int>& nums, int target) {\\n        int size = nums.size();\\n        int start = 0,end = size - 1,firstOcc = -1,lastOcc = -1;\\n        if(size == 0){\\n            return {-1,-1};\\n        }\\n        find_first(nums,start,end,firstOcc,target);\\n        find_last(nums,start,end,lastOcc,target);\\n\\n        return {firstOcc,lastOcc};\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-first-and-last-position-of-element-in-sorted-array","has_notes":false,"flag_type":1,"frontend_id":274},{"id":1747295764,"question_id":35,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756096182,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1747295764/","is_pending":"Not Pending","title":"Search Insert Position","memory":"13.6 MB","code":"class Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size()-1;\\n        int ansIndex = nums.size();\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] >= target){\\n                ansIndex = mid;\\n                end = mid -1;\\n            }else{\\n                start = mid +1;\\n            }\\n        }\\n        return ansIndex;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-insert-position","has_notes":false,"flag_type":1,"frontend_id":273},{"id":1746404938,"question_id":792,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756026076,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1746404938/","is_pending":"Not Pending","title":"Binary Search","memory":"31.3 MB","code":"class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size()-1;\\n\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }else if(nums[mid] < target){\\n                start = mid+1;\\n            }else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111","title_slug":"binary-search","has_notes":false,"flag_type":1,"frontend_id":272},{"id":1746384622,"question_id":152,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756024614,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1746384622/","is_pending":"Not Pending","title":"Maximum Product Subarray","memory":"17.6 MB","code":"class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        long long prefixProduct = nums[0], suffixProduct = nums[nums.size()-1],\\n                  maxProduct = max(prefixProduct,suffixProduct);\\n        bool allZero = true;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (prefixProduct == 0) {\\n                prefixProduct = 1;\\n            }\\n            if (suffixProduct == 0) {\\n                suffixProduct = 1;\\n            }\\n            allZero = false;\\n            prefixProduct *= nums[i];\\n            suffixProduct *= nums[nums.size() - i - 1];\\n            maxProduct = max(maxProduct, max(suffixProduct, prefixProduct));\\n\\n        }\\n\\n\\n        if (allZero && nums.size() > 1) {\\n            return 0;\\n        }\\n        return maxProduct;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-subarray","has_notes":false,"flag_type":1,"frontend_id":271}],"has_next":true,"last_key":""}'
2026-01-10 09:25:59,933 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:25:59,937 [INFO] __main__.py:245 - Writing valid-sudoku/2025-08-30 13.38.40 - Accepted - runtime 0ms - memory 21.6MB.cpp
2026-01-10 09:25:59,938 [INFO] __main__.py:188 - Skipping valid-sudoku 2025-08-30 13.35.55 because its status is 'Wrong Answer'
2026-01-10 09:26:02,122 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:02,124 [INFO] __main__.py:245 - Writing alice-and-bob-playing-flower-game/2025-08-30 13.02.27 - Accepted - runtime 0ms - memory 8.6MB.cpp
2026-01-10 09:26:02,125 [INFO] __main__.py:188 - Skipping alice-and-bob-playing-flower-game 2025-08-30 13.01.55 because its status is 'Runtime Error'
2026-01-10 09:26:04,809 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:04,811 [INFO] __main__.py:245 - Writing minimum-number-of-days-to-make-m-bouquets/2025-08-30 04.44.22 - Accepted - runtime 20ms - memory 70.5MB.cpp
2026-01-10 09:26:04,812 [INFO] __main__.py:188 - Skipping minimum-number-of-days-to-make-m-bouquets 2025-08-30 04.43.22 because its status is 'Runtime Error'
2026-01-10 09:26:05,128 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:05,131 [INFO] __main__.py:245 - Writing koko-eating-bananas/2025-08-30 03.13.06 - Accepted - runtime 15ms - memory 22.9MB.cpp
2026-01-10 09:26:05,131 [INFO] __main__.py:188 - Skipping koko-eating-bananas 2025-08-30 03.10.49 because its status is 'Runtime Error'
2026-01-10 09:26:06,031 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:06,033 [INFO] __main__.py:245 - Writing find-peak-element/2025-08-27 07.51.13 - Accepted - runtime 0ms - memory 12.5MB.cpp
2026-01-10 09:26:06,357 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:06,358 [INFO] __main__.py:245 - Writing single-element-in-a-sorted-array/2025-08-27 07.15.25 - Accepted - runtime 0ms - memory 26.1MB.cpp
2026-01-10 09:26:06,359 [INFO] __main__.py:188 - Skipping single-element-in-a-sorted-array 2025-08-27 07.11.13 because its status is 'Wrong Answer'
2026-01-10 09:26:06,359 [INFO] __main__.py:245 - Writing find-minimum-in-rotated-sorted-array/2025-08-27 01.13.17 - Accepted - runtime 0ms - memory 14.2MB.cpp
2026-01-10 09:26:06,678 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:06,679 [INFO] __main__.py:245 - Writing search-in-rotated-sorted-array-ii/2025-08-26 21.54.01 - Accepted - runtime 0ms - memory 17.8MB.cpp
2026-01-10 09:26:06,679 [INFO] __main__.py:188 - Skipping search-in-rotated-sorted-array-ii 2025-08-26 21.51.27 because its status is 'Wrong Answer'
2026-01-10 09:26:06,680 [INFO] __main__.py:245 - Writing search-in-rotated-sorted-array/2025-08-26 21.15.46 - Accepted - runtime 0ms - memory 15.3MB.cpp
2026-01-10 09:26:06,680 [INFO] __main__.py:245 - Writing search-in-rotated-sorted-array/2025-08-26 21.10.55 - Accepted - runtime 0ms - memory 15.2MB.cpp
2026-01-10 09:26:07,302 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:07,305 [INFO] __main__.py:245 - Writing find-first-and-last-position-of-element-in-sorted-array/2025-08-25 10.44.51 - Accepted - runtime 0ms - memory 17.7MB.cpp
2026-01-10 09:26:08,314 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:08,316 [INFO] __main__.py:245 - Writing search-insert-position/2025-08-25 09.59.42 - Accepted - runtime 0ms - memory 13.6MB.cpp
2026-01-10 09:26:09,582 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:09,584 [INFO] __main__.py:245 - Writing binary-search/2025-08-24 14.31.16 - Accepted - runtime 0ms - memory 31.3MB.cpp
2026-01-10 09:26:09,994 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:09,996 [INFO] __main__.py:245 - Writing maximum-product-subarray/2025-08-24 14.06.54 - Accepted - runtime 0ms - memory 17.6MB.cpp
2026-01-10 09:26:15,001 [DEBUG] leetcode.py:150 - Exporting submissions from 280 to 300
2026-01-10 09:26:17,866 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=280&limit=20 HTTP/1.1" 200 None
2026-01-10 09:26:17,868 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1746384366,"question_id":152,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756024595,"status":10,"status_display":"Accepted","runtime":"235 ms","url":"/submissions/detail/1746384366/","is_pending":"Not Pending","title":"Maximum Product Subarray","memory":"17.7 MB","code":"class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        long long prefixProduct = nums[0], suffixProduct = nums[nums.size()-1],\\n                  maxProduct = max(prefixProduct,suffixProduct);\\n        bool allZero = true;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (prefixProduct == 0) {\\n                prefixProduct = 1;\\n            }\\n            if (suffixProduct == 0) {\\n                suffixProduct = 1;\\n            }\\n            allZero = false;\\n            prefixProduct *= nums[i];\\n            suffixProduct *= nums[nums.size() - i - 1];\\n            maxProduct = max(maxProduct, max(suffixProduct, prefixProduct));\\n            cout<<\\"Prefix: \\"<<prefixProduct<<\\", Suffix: \\"<<suffixProduct<<\\", Max: \\"<<maxProduct<<\\"\\\\n\\";\\n        }\\n\\n\\n        if (allZero && nums.size() > 1) {\\n            return 0;\\n        }\\n        return maxProduct;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-subarray","has_notes":false,"flag_type":1,"frontend_id":270},{"id":1746382103,"question_id":152,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756024431,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746382103/","is_pending":"Not Pending","title":"Maximum Product Subarray","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        long long prefixProduct = nums[0], suffixProduct = nums[nums.size()-1],\\n                  maxProduct = nums[0];\\n        bool allZero = true;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (prefixProduct == 0) {\\n                prefixProduct = 1;\\n            }\\n            if (suffixProduct == 0) {\\n                suffixProduct = 1;\\n            }\\n            allZero = false;\\n            prefixProduct *= nums[i];\\n            suffixProduct *= nums[nums.size() - i - 1];\\n            maxProduct = max(maxProduct, max(suffixProduct, prefixProduct));\\n        }\\n\\n\\n        if (allZero && nums.size() > 1) {\\n            return 0;\\n        }\\n        return maxProduct;\\n    }\\n};","compare_result":"1111111111110111111111111111111111111101111111111111111111111111011111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-subarray","has_notes":false,"flag_type":1,"frontend_id":269},{"id":1746381286,"question_id":152,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756024368,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746381286/","is_pending":"Not Pending","title":"Maximum Product Subarray","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxProduct(vector<int>& nums) {\\n        long long prefixProduct = nums[0], suffixProduct = nums[nums.size()-1],\\n                  maxProduct = nums[0];\\n        bool allZero = true;\\n        for (int i = 1; i < nums.size(); i++) {\\n            if (prefixProduct == 0) {\\n                prefixProduct = 1;\\n            }\\n            if (suffixProduct == 0) {\\n                suffixProduct = 1;\\n            }\\n            allZero = false;\\n            prefixProduct *= nums[i];\\n            suffixProduct *= nums[nums.size() - i - 1];\\n            maxProduct = max(maxProduct, max(suffixProduct, prefixProduct));\\n        }\\n\\n\\n        if (allZero) {\\n            return 0;\\n        }\\n        return maxProduct;\\n    }\\n};","compare_result":"1101011111110111111111111111111111111101111111111111111111111111011111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-product-subarray","has_notes":false,"flag_type":1,"frontend_id":268},{"id":1746335412,"question_id":493,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756021114,"status":10,"status_display":"Accepted","runtime":"548 ms","url":"/submissions/detail/1746335412/","is_pending":"Not Pending","title":"Reverse Pairs","memory":"240.3 MB","code":"class Solution {\\n    void merge(vector<int>&nums,int start,int mid,int end){\\n        vector<int>temp;\\n        int left = start,right = mid +1;\\n        while(left <= mid && right <= end){\\n            if(nums[left] <= nums[right]){\\n                temp.push_back(nums[left++]);\\n            }else{\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left <= mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right <= end){\\n            temp.push_back(nums[right++]);\\n        }\\n\\n        for(int i=start; i<= end; i++){\\n            nums[i] = temp[i-start];\\n        }\\n    }\\n    void count_pairs(vector<int>&nums,int start,int mid,int end,int & count){\\n        int left = start;\\n        int right = mid+1;\\n\\n        while(left <= mid ){\\n            while(right <= end && nums[left] > (long long)2*nums[right])right++;\\n            count+= (right - (mid+1));\\n            left++;\\n        }\\n    }\\n    void mergeSort(vector<int>&nums,int start,int end,int &count){\\n        if(start >=end)return;\\n        int mid = start + (end - start)/2;\\n        mergeSort(nums,start,mid,count);\\n        mergeSort(nums,mid+1,end,count);\\n        count_pairs(nums,start,mid,end,count);\\n        merge(nums,start,mid,end);\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        mergeSort(nums,0,nums.size()-1,count);\\n        return count;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-pairs","has_notes":false,"flag_type":1,"frontend_id":267},{"id":1746320511,"question_id":493,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756020158,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746320511/","is_pending":"Not Pending","title":"Reverse Pairs","memory":"N/A","code":"class Solution {\\n    void merge(vector<int>&nums,int start,int mid,int end){\\n        vector<int>temp;\\n        int left = start,right = mid +1;\\n        while(left <= mid && right <= end){\\n            if(nums[left] <= nums[right]){\\n                temp.push_back(nums[left++]);\\n            }else{\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left <= mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right <= end){\\n            temp.push_back(nums[right++]);\\n        }\\n\\n        for(int i=start; i<= end; i++){\\n            nums[i] = temp[i-start];\\n        }\\n    }\\n    void count_pairs(vector<int>&nums,int start,int mid,int end,int & count){\\n        int left = start;\\n        int right = mid+1;\\n\\n        while(left <= mid && right <= end){\\n            while(right <= end && nums[left] > (long long)2*nums[right])right++;\\n            count+= (right - (mid+1));\\n            left++;\\n        }\\n    }\\n    void mergeSort(vector<int>&nums,int start,int end,int &count){\\n        if(start >=end)return;\\n        int mid = start + (end - start)/2;\\n        mergeSort(nums,start,mid,count);\\n        mergeSort(nums,mid+1,end,count);\\n        count_pairs(nums,start,mid,end,count);\\n        merge(nums,start,mid,end);\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        mergeSort(nums,0,nums.size()-1,count);\\n        return count;\\n    }\\n};","compare_result":"11111111110000000000000000000000000011101111111111111111110111011111110111110100000111100110000011101010001111101111100000100100010000100011","title_slug":"reverse-pairs","has_notes":false,"flag_type":1,"frontend_id":266},{"id":1746319777,"question_id":493,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756020111,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1746319777/","is_pending":"Not Pending","title":"Reverse Pairs","memory":"N/A","code":"class Solution {\\n    void merge(vector<int>&nums,int start,int mid,int end){\\n        vector<int>temp;\\n        int left = start,right = mid +1;\\n        while(left <= mid && right <= end){\\n            if(nums[left] <= nums[right]){\\n                temp.push_back(nums[left++]);\\n            }else{\\n                temp.push_back(nums[right++]);\\n            }\\n        }\\n        while(left <= mid){\\n            temp.push_back(nums[left++]);\\n        }\\n        while(right <= end){\\n            temp.push_back(nums[right++]);\\n        }\\n\\n        for(int i=start; i<= end; i++){\\n            nums[i] = temp[i-start];\\n        }\\n    }\\n    void count_pairs(vector<int>&nums,int start,int mid,int end,int & count){\\n        int left = start;\\n        int right = mid+1;\\n\\n        while(left <= mid && right <= end){\\n            while(right <= end && nums[left] > 2*nums[right])right++;\\n            count+= (right - (mid+1));\\n            left++;\\n        }\\n    }\\n    void mergeSort(vector<int>&nums,int start,int end,int &count){\\n        if(start >=end)return;\\n        int mid = start + (end - start)/2;\\n        mergeSort(nums,start,mid,count);\\n        mergeSort(nums,mid+1,end,count);\\n        count_pairs(nums,start,mid,end,count);\\n        merge(nums,start,mid,end);\\n    }\\npublic:\\n    int reversePairs(vector<int>& nums) {\\n        int count = 0;\\n        mergeSort(nums,0,nums.size()-1,count);\\n        return count;\\n    }\\n};","compare_result":"11111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-pairs","has_notes":false,"flag_type":1,"frontend_id":265},{"id":1746129325,"question_id":3979,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756007901,"status":10,"status_display":"Accepted","runtime":"39 ms","url":"/submissions/detail/1746129325/","is_pending":"Not Pending","title":"Partition Array Into K-Distinct Groups","memory":"255.7 MB","code":"class Solution {\\npublic:\\n    bool partitionArray(vector<int>& nums, int k) {\\n        if(nums.size() % k != 0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int countDuplicates=1;\\n        int maxCountDuplicate = 0;\\n        for(int i=0;i<nums.size();i++ ){\\n            if(i==0)continue;\\n            if(nums[i-1] == nums[i])countDuplicates++;\\n            if(nums[i-1]!= nums[i])countDuplicates = 1;\\n\\n            maxCountDuplicate = max(maxCountDuplicate,countDuplicates);\\n        }\\n        \\n        if(maxCountDuplicate == 0){\\n            return true;\\n        }\\n        cout<<maxCountDuplicate;\\n\\n        int sizeDivideDuplicate = nums.size() / maxCountDuplicate;\\n        if(sizeDivideDuplicate < k){\\n            return false;\\n        }\\n        return true;\\n\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"partition-array-into-k-distinct-groups","has_notes":false,"flag_type":1,"frontend_id":264},{"id":1746099389,"question_id":3979,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756006620,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746099389/","is_pending":"Not Pending","title":"Partition Array Into K-Distinct Groups","memory":"N/A","code":"class Solution {\\npublic:\\n    bool partitionArray(vector<int>& nums, int k) {\\n        if(nums.size() % k != 0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int countDuplicates=0;\\n        for(int i=0;i<nums.size();i++ ){\\n            if(i==0)continue;\\n            if(nums[i-1] == nums[i])countDuplicates++;\\n        }\\n        countDuplicates = 2*countDuplicates;\\n        if(countDuplicates == 0){\\n            return true;\\n        }\\n\\n        int sizeDivideDuplicate = nums.size() / countDuplicates;\\n        if(sizeDivideDuplicate < k){\\n            return false;\\n        }\\n        return true;\\n\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111001110011111","title_slug":"partition-array-into-k-distinct-groups","has_notes":false,"flag_type":1,"frontend_id":263},{"id":1746097929,"question_id":3979,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756006557,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746097929/","is_pending":"Not Pending","title":"Partition Array Into K-Distinct Groups","memory":"N/A","code":"class Solution {\\npublic:\\n    bool partitionArray(vector<int>& nums, int k) {\\n        if(nums.size() % k != 0){\\n            return false;\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int countDuplicates=0;\\n        for(int i=0;i<nums.size();i++ ){\\n            if(i==0)continue;\\n            if(nums[i-1] == nums[i])countDuplicates++;\\n        }\\n        countDuplicates = 2*countDuplicates;\\n        if(countDuplicates == 0){\\n            return true;\\n        }\\n\\n        int sizeDivideDuplicate = nums.size() / countDuplicates;\\n        if(sizeDivideDuplicate < countDuplicates){\\n            return false;\\n        }\\n        return true;\\n\\n        \\n    }\\n};","compare_result":"111111111111111111111111111111101111111111111111111111111111111111111111111101011111111111111111111111111111101111111111111111011011111110111111111111101111111111101111111111111111111111100110111101111110111111111111111110111111111111101111110111111111011111110111111111111111111111111111111111111111111110111100111111111110111111111111111111111111111101111011111111111011111011111111101111111111111111110010111111111111010111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111011111111111111111111110111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111001111001110011111","title_slug":"partition-array-into-k-distinct-groups","has_notes":false,"flag_type":1,"frontend_id":262},{"id":1746016164,"question_id":3979,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756003573,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1746016164/","is_pending":"Not Pending","title":"Partition Array Into K-Distinct Groups","memory":"N/A","code":"class Solution {\\npublic:\\n    bool partitionArray(vector<int>& nums, int k) {\\n        if(nums.size() % k == 0){\\n            return true;\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111110110101111111111111111111111111111111111111111111111011111111111111111111111111111101111111111111111011011111110111111111111101011111111101111111111111111110111111110111101111110111111111111111110111111101111101110111111111111011111100111111111111111111111111111111111111111111110111100111111111110111111111111111111111111111101101001111111111011111011111111011111111111111111110010111111111111010111100111111111111011111111101111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111100111011110101111111111111111110111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111110111111110111111110111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100101111111101100010","title_slug":"partition-array-into-k-distinct-groups","has_notes":false,"flag_type":1,"frontend_id":261},{"id":1746003268,"question_id":3995,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1756003168,"status":10,"status_display":"Accepted","runtime":"575 ms","url":"/submissions/detail/1746003268/","is_pending":"Not Pending","title":"GCD of Odd and Even Sums","memory":"8.5 MB","code":"class Solution {\\npublic:\\n    int gcdOfOddEvenSums(int n) {\\n        long long sumOdd = 0;\\n        long long sumEven = 0;\\n        for(int i=1; i<2*abs(n); i++){\\n            if(i&1)sumOdd+=i;\\n            else sumEven+=i;\\n        }\\n\\n        long long mini = min(sumOdd,sumEven);\\n        int ans=1;\\n        for(int i = mini; i>=2;i--){\\n            if(sumOdd %i ==0 && sumEven%i==0){\\n                ans=i;break;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"gcd-of-odd-and-even-sums","has_notes":false,"flag_type":1,"frontend_id":260},{"id":1743875919,"question_id":56,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755834494,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1743875919/","is_pending":"Not Pending","title":"Merge Intervals","memory":"23.8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        sort(intervals.begin(), intervals.end(),[](const vector<int>&a,const vector<int>&b){return a[0]<b[0];});\\n\\n        if(intervals.size() == 1){\\n            return intervals;\\n        }\\n\\n        vector<vector<int>>ans;\\n\\n        for(int i=0; i<intervals.size(); i++){\\n            if(ans.empty()){\\n                ans.push_back(intervals[i]);\\n                continue;\\n            }\\n            int start = intervals[i][0];\\n            int end = intervals[i][1];\\n\\n            if(start <= ans.back()[1]){\\n                ans.back()[1] = max(end,ans.back()[1]);\\n            }else{\\n                ans.push_back({start,end});\\n            }\\n        }\\n\\n        \\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":259},{"id":1741856450,"question_id":18,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755681291,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/1741856450/","is_pending":"Not Pending","title":"4Sum","memory":"17.4 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        if(nums.size() < 4)return ans;\\n        for(int i=0; i<nums.size()-3; i++){\\n            if(i!=0 && nums[i-1] == nums[i]){\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size()-2; j++){\\n                if(j != i+1 && nums[j-1]==nums[j]){\\n                    continue;\\n                }\\n                int start = j+1,end = nums.size()-1;\\n                while(start < end){\\n                    long long sumQuad = (long long)nums[i] + (long long)nums[j] + (long long)nums[start] + (long long)nums[end];\\n                    if(sumQuad == target){\\n                        ans.push_back({nums[i] , nums[j] , nums[start] , nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == nums[start-1] )start++;\\n                        while(start < end && nums[end] == nums[end+1] )end--;\\n                    }else if(sumQuad < target){\\n                        start++;\\n                    }else{\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"4sum","has_notes":false,"flag_type":1,"frontend_id":258},{"id":1741854972,"question_id":18,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755681197,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1741854972/","is_pending":"Not Pending","title":"4Sum","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n        if(nums.size() < 4)return ans;\\n        for(int i=0; i<nums.size()-3; i++){\\n            if(i!=0 && nums[i-1] == nums[i]){\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size()-2; j++){\\n                if(j != i+1 && nums[j-1]==nums[j]){\\n                    continue;\\n                }\\n                int start = j+1,end = nums.size()-1;\\n                while(start < end){\\n                    int sumQuad = nums[i] + nums[j] + nums[start] + nums[end];\\n                    if(sumQuad == target){\\n                        ans.push_back({nums[i] , nums[j] , nums[start] , nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == nums[start-1] )start++;\\n                        while(start < end && nums[end] == nums[end+1] )end--;\\n                    }else if(sumQuad < target){\\n                        start++;\\n                    }else{\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000","title_slug":"4sum","has_notes":false,"flag_type":1,"frontend_id":257},{"id":1741852183,"question_id":18,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755681011,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1741852183/","is_pending":"Not Pending","title":"4Sum","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n\\n        for(int i=0; i<nums.size()-3; i++){\\n            if(i!=0 && nums[i-1] == nums[i]){\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size()-2; j++){\\n                if(j > i+1 && nums[j-1]==nums[j]){\\n                    continue;\\n                }\\n                int start = j+1,end = nums.size()-1;\\n                while(start < end){\\n                    int sumQuad = nums[i] + nums[j] + nums[start] + nums[end];\\n                    if(sumQuad == target){\\n                        ans.push_back({nums[i] , nums[j] , nums[start] , nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == nums[start-1] )start++;\\n                        while(start < end && nums[end] == nums[end+1] )end--;\\n                    }else if(sumQuad < target){\\n                        start++;\\n                    }else{\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"4sum","has_notes":false,"flag_type":1,"frontend_id":256},{"id":1741851836,"question_id":18,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755680987,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1741851836/","is_pending":"Not Pending","title":"4Sum","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        vector<vector<int>>ans;\\n\\n        for(int i=0; i<nums.size()-3; i++){\\n            if(i!=0 && nums[i-1] == nums[i]){\\n                continue;\\n            }\\n            for(int j=i+1; j<nums.size()-2; j++){\\n                if(j != i+1 && nums[j-1]==nums[j]){\\n                    continue;\\n                }\\n                int start = j+1,end = nums.size()-1;\\n                while(start < end){\\n                    int sumQuad = nums[i] + nums[j] + nums[start] + nums[end];\\n                    if(sumQuad == target){\\n                        ans.push_back({nums[i] , nums[j] , nums[start] , nums[end]});\\n                        start++;\\n                        end--;\\n                        while(start < end && nums[start] == nums[start-1] )start++;\\n                        while(start < end && nums[end] == nums[end+1] )end--;\\n                    }else if(sumQuad < target){\\n                        start++;\\n                    }else{\\n                        end--;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"4sum","has_notes":false,"flag_type":1,"frontend_id":255},{"id":1741741456,"question_id":15,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755672741,"status":10,"status_display":"Accepted","runtime":"43 ms","url":"/submissions/detail/1741741456/","is_pending":"Not Pending","title":"3Sum","memory":"29 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int target = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(i!=0 && nums[i] == nums[i-1])continue;\\n            int ptr1 = i+1, ptr2 = nums.size()-1;\\n            while(ptr1 < ptr2){\\n                if(nums[i]+nums[ptr1] + nums[ptr2] == target){\\n                    ans.push_back({nums[i],nums[ptr1],nums[ptr2]});\\n                    ptr1++;ptr2--;\\n                    while(ptr1 < ptr2 && nums[ptr1] == nums[ptr1-1])ptr1++;\\n                    while(ptr1 < ptr2 && nums[ptr2] == nums[ptr2+1])ptr2--;\\n                }\\n                else if(nums[i]+nums[ptr1] + nums[ptr2]< target){\\n                    ptr1++;\\n                }\\n                else if(nums[i]+nums[ptr1] + nums[ptr2] > target){\\n                    ptr2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"3sum","has_notes":false,"flag_type":1,"frontend_id":254},{"id":1741735785,"question_id":15,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1755672383,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1741735785/","is_pending":"Not Pending","title":"3Sum","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        int target = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size()-1; i++){\\n            if(i!=0 && nums[i] == nums[i-1])continue;\\n            int ptr1 = i+1, ptr2 = nums.size()-1;\\n            while(ptr1 < ptr2){\\n                if(nums[i]+nums[ptr1] + nums[ptr2] == target){\\n                    ans.push_back({nums[i],nums[ptr1],nums[ptr2]});\\n                    ptr1++;ptr2--;\\n                }\\n                else if(nums[i]+nums[ptr1] + nums[ptr2]< target){\\n                    ptr1++;\\n                }\\n                else if(nums[i]+nums[ptr1] + nums[ptr2] > target){\\n                    ptr2--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111110011100111001111101111010111110010001000101111010001100111110111010011001101111111001110010000111111100110001001001010100101000011101010010010110010101110101010001011100011011001101110001001010111111100010010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"3sum","has_notes":false,"flag_type":1,"frontend_id":253},{"id":1740946561,"question_id":229,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755613995,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1740946561/","is_pending":"Not Pending","title":"Majority Element II","memory":"23.5 MB","code":"class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1 = 0,element1 = INT_MIN,count2 = 0,element2 = INT_MIN;\\n\\n        for(int i=0; i<nums.size();i++){\\n            if(count1==0 && element2 != nums[i]){\\n                count1 = 1;\\n                element1 = nums[i];\\n            }\\n            else if(count2==0 && element1 != nums[i]){\\n                count2 = 1;\\n                element2 = nums[i];\\n            }else if(element1 == nums[i]){\\n                count1++;\\n            }else if(element2 == nums[i]){\\n                count2++;\\n            }else{\\n                count1--;count2--;\\n            }\\n        }\\n        vector<int>ans;\\n        count1=0,count2=0;\\n        for(auto &it:nums){\\n            if(element1 == it)count1++;\\n            if(element2 == it)count2++;\\n        }\\n        if(count1 > floor(nums.size()/3))ans.push_back(element1);\\n        if(count2 > floor(nums.size()/3))ans.push_back(element2);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"majority-element-ii","has_notes":false,"flag_type":1,"frontend_id":252},{"id":1740932820,"question_id":229,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755613311,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1740932820/","is_pending":"Not Pending","title":"Majority Element II","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> majorityElement(vector<int>& nums) {\\n        int count1 = 0,element1 = INT_MIN,count2 = 0,element2 = INT_MIN;\\n\\n        for(int i=0; i<nums.size();i++){\\n            if(count1==0 && element2 != nums[i]){\\n                count1 = 1;\\n                element1 = nums[i];\\n            }\\n            else if(count2==0 && element1 != nums[i]){\\n                count2 = 1;\\n                element2 = nums[i];\\n            }else if(element1 == nums[i]){\\n                count1++;\\n            }else if(element2 == nums[i]){\\n                count2++;\\n            }else{\\n                count1--;count2--;\\n            }\\n        }\\n        vector<int>ans;\\n        if(count1 > floor(nums.size()/3))ans.push_back(element1);\\n        if(count2 > floor(nums.size()/3))ans.push_back(element2);\\n        return ans;\\n    }\\n};","compare_result":"11111111110000011111100111010100100000101010001001111111111110000000000000101111111111111111111","title_slug":"majority-element-ii","has_notes":false,"flag_type":1,"frontend_id":251}],"has_next":true,"last_key":""}'
2026-01-10 09:26:17,870 [INFO] __main__.py:245 - Writing maximum-product-subarray/2025-08-24 14.06.35 - Accepted - runtime 235ms - memory 17.7MB.cpp
2026-01-10 09:26:17,871 [INFO] __main__.py:188 - Skipping maximum-product-subarray 2025-08-24 14.03.51 because its status is 'Wrong Answer'
2026-01-10 09:26:17,872 [INFO] __main__.py:188 - Skipping maximum-product-subarray 2025-08-24 14.02.48 because its status is 'Wrong Answer'
2026-01-10 09:26:19,809 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:19,811 [INFO] __main__.py:245 - Writing reverse-pairs/2025-08-24 13.08.34 - Accepted - runtime 548ms - memory 240.3MB.cpp
2026-01-10 09:26:19,811 [INFO] __main__.py:188 - Skipping reverse-pairs 2025-08-24 12.52.38 because its status is 'Wrong Answer'
2026-01-10 09:26:19,812 [INFO] __main__.py:188 - Skipping reverse-pairs 2025-08-24 12.51.51 because its status is 'Runtime Error'
2026-01-10 09:26:20,128 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:20,131 [INFO] __main__.py:245 - Writing partition-array-into-k-distinct-groups/2025-08-24 09.28.21 - Accepted - runtime 39ms - memory 255.7MB.cpp
2026-01-10 09:26:20,132 [INFO] __main__.py:188 - Skipping partition-array-into-k-distinct-groups 2025-08-24 09.07.00 because its status is 'Wrong Answer'
2026-01-10 09:26:20,132 [INFO] __main__.py:188 - Skipping partition-array-into-k-distinct-groups 2025-08-24 09.05.57 because its status is 'Wrong Answer'
2026-01-10 09:26:20,133 [INFO] __main__.py:188 - Skipping partition-array-into-k-distinct-groups 2025-08-24 08.16.13 because its status is 'Wrong Answer'
2026-01-10 09:26:22,304 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:22,306 [INFO] __main__.py:245 - Writing gcd-of-odd-and-even-sums/2025-08-24 08.09.28 - Accepted - runtime 575ms - memory 8.5MB.cpp
2026-01-10 09:26:22,307 [INFO] __main__.py:245 - Writing merge-intervals/2025-08-22 09.18.14 - Accepted - runtime 4ms - memory 23.8MB.cpp
2026-01-10 09:26:23,299 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:23,302 [INFO] __main__.py:245 - Writing 4sum/2025-08-20 14.44.51 - Accepted - runtime 16ms - memory 17.4MB.cpp
2026-01-10 09:26:23,302 [INFO] __main__.py:188 - Skipping 4sum 2025-08-20 14.43.17 because its status is 'Runtime Error'
2026-01-10 09:26:23,303 [INFO] __main__.py:188 - Skipping 4sum 2025-08-20 14.40.11 because its status is 'Runtime Error'
2026-01-10 09:26:23,303 [INFO] __main__.py:188 - Skipping 4sum 2025-08-20 14.39.47 because its status is 'Runtime Error'
2026-01-10 09:26:23,630 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:23,631 [INFO] __main__.py:245 - Writing 3sum/2025-08-20 12.22.21 - Accepted - runtime 43ms - memory 29MB.cpp
2026-01-10 09:26:23,631 [INFO] __main__.py:188 - Skipping 3sum 2025-08-20 12.16.23 because its status is 'Wrong Answer'
2026-01-10 09:26:24,895 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:24,897 [INFO] __main__.py:245 - Writing majority-element-ii/2025-08-19 20.03.15 - Accepted - runtime 0ms - memory 23.5MB.cpp
2026-01-10 09:26:24,897 [INFO] __main__.py:188 - Skipping majority-element-ii 2025-08-19 19.51.51 because its status is 'Wrong Answer'
2026-01-10 09:26:29,902 [DEBUG] leetcode.py:150 - Exporting submissions from 300 to 320
2026-01-10 09:26:31,192 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=300&limit=20 HTTP/1.1" 200 None
2026-01-10 09:26:31,193 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1739290428,"question_id":560,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755498365,"status":10,"status_display":"Accepted","runtime":"54 ms","url":"/submissions/detail/1739290428/","is_pending":"Not Pending","title":"Subarray Sum Equals K","memory":"51 MB","code":"class Solution {\\npublic:\\n    int subarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>map;\\n        int currentSum = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<nums.size();i++){\\n            currentSum += nums[i];\\n            if(currentSum == k){\\n                count++;\\n            }\\n            if(map[currentSum - k]){\\n                count+= map[currentSum-k];\\n            }\\n            map[currentSum]++;\\n        }\\n        return count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subarray-sum-equals-k","has_notes":false,"flag_type":1,"frontend_id":250},{"id":1739284710,"question_id":560,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755498006,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1739284710/","is_pending":"Not Pending","title":"Subarray Sum Equals K","memory":"N/A","code":"class Solution {\\npublic:\\n    int subarraySum(vector<int>& nums, int k) {\\n        unordered_set<int>set;\\n        int currentSum = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<nums.size();i++){\\n            currentSum += nums[i];\\n            if(currentSum == k){\\n                count++;\\n            }\\n            if(set.find(currentSum - k) != set.end()){\\n                count++;\\n            }\\n            set.insert(currentSum);\\n        }\\n        return count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111101111111111111111111111101000001111000000000001110000101","title_slug":"subarray-sum-equals-k","has_notes":false,"flag_type":1,"frontend_id":249},{"id":1739279523,"question_id":560,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755497677,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1739279523/","is_pending":"Not Pending","title":"Subarray Sum Equals K","memory":"N/A","code":"class Solution {\\npublic:\\n    int subarraySum(vector<int>& nums, int k) {\\n        int left = 0,right = 0;\\n        int currentSum = nums[0];\\n        int count = 0;\\n\\n        if(nums.size() == 1 ){\\n            return nums[0]==k;\\n        }\\n\\n        while(right < nums.size()){\\n            while(left <= right && currentSum > k){\\n                currentSum -= nums[left++];\\n            }\\n            if(currentSum == k){\\n                count++;\\n            }\\n            right++;\\n            if(right < nums.size()){\\n                currentSum+=nums[right];\\n            }\\n        }\\n        return count;\\n    }\\n};","compare_result":"111110010101111011111111111101101011000000000000000000000000100000000000000000000001110000001","title_slug":"subarray-sum-equals-k","has_notes":false,"flag_type":1,"frontend_id":248},{"id":1739277124,"question_id":560,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755497522,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1739277124/","is_pending":"Not Pending","title":"Subarray Sum Equals K","memory":"N/A","code":"class Solution {\\npublic:\\n    int subarraySum(vector<int>& nums, int k) {\\n        int left = 0,right = 0;\\n        int currentSum = nums[0];\\n        int count = 0;\\n\\n        while(right < nums.size()){\\n            while(left <= right && currentSum > k){\\n                currentSum -= nums[left++];\\n            }\\n            if(currentSum == k){\\n                count++;\\n            }\\n            right++;\\n            if(right < nums.size()){\\n                currentSum+=nums[right];\\n            }\\n        }\\n        return count;\\n    }\\n};","compare_result":"111100010101111011111111111101101011000000000000000000000000100000000000000000000001110000001","title_slug":"subarray-sum-equals-k","has_notes":false,"flag_type":1,"frontend_id":247},{"id":1738871428,"question_id":128,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755455349,"status":10,"status_display":"Accepted","runtime":"85 ms","url":"/submissions/detail/1738871428/","is_pending":"Not Pending","title":"Longest Consecutive Sequence","memory":"88.8 MB","code":"class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n\\n        unordered_set<int> set;\\n\\n        for (auto& it : nums)\\n            set.insert(it);\\n\\n        int currentSequence = 1, longestSequence = 1;\\n        if (nums.size() <= 1) {\\n            return nums.size();\\n        }\\n\\n        for (auto setIterator: set) {\\n            if (set.find(setIterator - 1) == set.end()) {\\n                int cnt = 1;\\n                currentSequence = 1;\\n                while (set.find(setIterator + cnt) != set.end()) {\\n                    currentSequence++;\\n                    longestSequence = max(longestSequence, currentSequence);\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return longestSequence;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"longest-consecutive-sequence","has_notes":false,"flag_type":1,"frontend_id":246},{"id":1738860991,"question_id":128,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755454804,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1738860991/","is_pending":"Not Pending","title":"Longest Consecutive Sequence","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> set;\\n                set.reserve(nums.size() * 2);       // avoid rehashes\\n        set.max_load_factor(0.7f);\\n        for (auto& it : nums)\\n            set.insert(it);\\n\\n        int currentSequence = 1, longestSequence = 1;\\n        if (nums.size() <= 1) {\\n            return nums.size();\\n        }\\n\\n        for (int i = 0; i < set.size(); i++) {\\n            if (set.find(nums[i] - 1) == set.end()) {\\n                int cnt = 1;\\n                currentSequence = 1;\\n                while (set.find(nums[i] + cnt) != set.end()) {\\n                    currentSequence++;\\n                    longestSequence = max(longestSequence, currentSequence);\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return longestSequence;\\n    }\\n};","compare_result":"111111101111011111101001111111111111110111110111111111100011011110111111111111111","title_slug":"longest-consecutive-sequence","has_notes":false,"flag_type":1,"frontend_id":245},{"id":1738850763,"question_id":128,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755454285,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1738850763/","is_pending":"Not Pending","title":"Longest Consecutive Sequence","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int> set;\\n        for (auto& it : nums)\\n            set.insert(it);\\n\\n        int currentSequence = 1, longestSequence = 1;\\n        if (nums.size() <= 1) {\\n            return nums.size();\\n        }\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n            if (set.find(nums[i] - 1) == set.end()) {\\n                int cnt = 1;\\n                while (set.find(nums[i] + cnt) != set.end()) {\\n                    currentSequence++;\\n                    longestSequence = max(longestSequence, currentSequence);\\n                    cnt++;\\n                }\\n            }\\n            currentSequence = 1;\\n        }\\n\\n        return longestSequence;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111000","title_slug":"longest-consecutive-sequence","has_notes":false,"flag_type":1,"frontend_id":244},{"id":1738850188,"question_id":128,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755454255,"status":13,"status_display":"Output Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1738850188/","is_pending":"Not Pending","title":"Longest Consecutive Sequence","memory":"N/A","code":"class Solution {\\npublic:\\n    int longestConsecutive(vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(auto& it:nums) set.insert(it);\\n\\n        int currentSequence = 1,longestSequence = 1;\\n        if(nums.size() <= 1){\\n            return nums.size();\\n        }\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(set.find(nums[i]-1) == set.end()){\\n                int cnt = 1;\\n                while(set.find(nums[i]+cnt) != set.end()){\\n                    currentSequence++;\\n                    cout<<\\"nums[i]: \\"<<nums[i]<<\\", nums[i] + cnt : \\"<<nums[i]+cnt<<endl;\\n                    longestSequence = max(longestSequence,currentSequence);\\n                    cnt++;\\n                }\\n            }\\n            currentSequence = 1;\\n        }\\n\\n        return longestSequence;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111100000000000","title_slug":"longest-consecutive-sequence","has_notes":false,"flag_type":1,"frontend_id":243},{"id":1738719699,"question_id":31,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755447373,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1738719699/","is_pending":"Not Pending","title":"Next Permutation","memory":"15.5 MB","code":"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int breakPoint = -1;\\n\\n        for(int i = nums.size()-1; i>0;i--){\\n            if(nums[i-1] < nums[i]){\\n                breakPoint = i-1;\\n                break;\\n            }\\n        }\\n\\n        if(breakPoint == -1){\\n            reverse(nums.begin(),nums.end());\\n            return;\\n        }\\n\\n        for(int i=nums.size()-1; i>breakPoint; i--){\\n            if(nums[breakPoint] < nums[i]){\\n                swap(nums[breakPoint],nums[i]);\\n                break;\\n            }\\n        }\\n\\n        reverse(nums.begin()+breakPoint+1,nums.end());\\n\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"next-permutation","has_notes":false,"flag_type":1,"frontend_id":242},{"id":1738053518,"question_id":3966,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755402537,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1738053518/","is_pending":"Not Pending","title":"Minimum Sum After Divisible Sum Deletions","memory":"N/A","code":"class Solution {\\npublic:\\n    long long minArraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        long long sumArr = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            long long tempSum = 0;\\n            for (int j = i; j < nums.size(); j++) {\\n                tempSum += nums[j];\\n                if (tempSum % k == 0) {\\n                   \\n                    nums.erase(nums.begin()+i, nums.begin() + j+1);\\n                    i=-1;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            sumArr += nums[i];\\n        }\\n        return sumArr;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111100110000100011001011010100100001110100010101101010000000010000100000000000000001000011000000000000000100000000000100000001000000000000000010100010001000100000000000000001000000000000000001010010000000011000000000000000000000001100000000000010000001000000000000000000000010010010000000000000000000000000000000001111111000000000000000","title_slug":"minimum-sum-after-divisible-sum-deletions","has_notes":false,"flag_type":1,"frontend_id":241},{"id":1738049004,"question_id":3966,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755402321,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1738049004/","is_pending":"Not Pending","title":"Minimum Sum After Divisible Sum Deletions","memory":"N/A","code":"class Solution {\\npublic:\\n    long long minArraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> map;\\n        long long sumArr = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            long long tempSum = 0;\\n            for (int j = i; j < nums.size(); j++) {\\n                tempSum += nums[j];\\n                if (tempSum % k == 0) {\\n                   \\n                    nums.erase(nums.begin()+i, nums.begin() + j+1);\\n                    i--;\\n                    \\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            sumArr += nums[i];\\n        }\\n        return sumArr;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111100110000100011001011010100100001110100010101101010000000010000100000000000000001000011000000000000000100000000000100000001000000000000000010100010001000100000000000000001000000000000000001010010000000011000000000000000000000001100000000000010000001000000000000000000000010010010000000000000000000000000000000001111111000000000000000","title_slug":"minimum-sum-after-divisible-sum-deletions","has_notes":false,"flag_type":1,"frontend_id":240},{"id":1737984808,"question_id":3975,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755399620,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1737984808/","is_pending":"Not Pending","title":"XOR After Range Multiplication Queries II","memory":"N/A","code":"class Solution {\\npublic:\\n    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\\n        int mod = 1e9 + 7;\\n\\n        for(int i=0; i<queries.size(); i++){\\n            long long left = queries[i][0];\\n            long long right = queries[i][1];\\n            long long k = queries[i][2];\\n            long long v = queries[i][3];\\n            while(left <= right){\\n                nums[left] = (nums[left] % mod * v % mod) % mod;\\n                left += k;\\n            }\\n        }\\n        int xorN = 0;\\n        for(int i=0; i<nums.size();i++){\\n            xorN ^= nums[i];\\n        }\\n        return xorN;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000","title_slug":"xor-after-range-multiplication-queries-ii","has_notes":false,"flag_type":1,"frontend_id":239},{"id":1737972009,"question_id":3974,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755399102,"status":10,"status_display":"Accepted","runtime":"71 ms","url":"/submissions/detail/1737972009/","is_pending":"Not Pending","title":"XOR After Range Multiplication Queries I","memory":"158.2 MB","code":"class Solution {\\npublic:\\n    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\\n        int mod = 1e9 + 7;\\n\\n        for(int i=0; i<queries.size(); i++){\\n            long long left = queries[i][0];\\n            long long right = queries[i][1];\\n            long long k = queries[i][2];\\n            long long v = queries[i][3];\\n            while(left <= right){\\n                nums[left] = (nums[left] % mod * v % mod) % mod;\\n                left += k;\\n            }\\n        }\\n        int xorN = 0;\\n        for(int i=0; i<nums.size();i++){\\n            xorN ^= nums[i];\\n        }\\n        return xorN;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"xor-after-range-multiplication-queries-i","has_notes":false,"flag_type":1,"frontend_id":238},{"id":1737969407,"question_id":3974,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755398993,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1737969407/","is_pending":"Not Pending","title":"XOR After Range Multiplication Queries I","memory":"N/A","code":"class Solution {\\npublic:\\n    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\\n        int mod = 1e9 + 7;\\n\\n        for(int i=0; i<queries.size(); i++){\\n            int left = queries[i][0];\\n            int right = queries[i][1];\\n            int k = queries[i][2];\\n            int v = queries[i][3];\\n            while(left <= right){\\n                nums[left] = (nums[left] * v) % mod;\\n                left += k;\\n            }\\n        }\\n        int xorN = 0;\\n        for(int i=0; i<nums.size();i++){\\n            xorN ^= nums[i];\\n        }\\n        return xorN;\\n    }\\n};","compare_result":"110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"xor-after-range-multiplication-queries-i","has_notes":false,"flag_type":1,"frontend_id":237},{"id":1737386400,"question_id":3963,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755355302,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1737386400/","is_pending":"Not Pending","title":"Number of Perfect Pairs","memory":"N/A","code":"class Solution {\\npublic:\\n    long long perfectPairs(vector<int>& nums) {\\n        long long pairCount = 0;\\n        long long a = -1;\\n        long long b = -1;\\n        for(int i=0; i<nums.size()-1; i++){\\n            a = nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                b = nums[j];\\n                if(min(abs(a-b),abs(a+b)) <= min(abs(a),abs(b)) && max(abs(a-b),abs(a+b)) >= max(abs(a),abs(b))){\\n                    pairCount++;\\n                }\\n            }\\n        }\\n        return pairCount;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000","title_slug":"number-of-perfect-pairs","has_notes":false,"flag_type":1,"frontend_id":236},{"id":1736780011,"question_id":2271,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1755316722,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1736780011/","is_pending":"Not Pending","title":"Rearrange Array Elements by Sign","memory":"134.5 MB","code":"class Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        vector<int>ans;\\n        int currentIndex = 0;\\n        int positiveIndex = 0;\\n        int negativeIndex = 0;\\n\\n        while(positiveIndex < nums.size() && negativeIndex < nums.size()){\\n            while(positiveIndex < nums.size() && nums[positiveIndex] <= 0 ){\\n                positiveIndex++;\\n            }   \\n            while(negativeIndex < nums.size() && nums[negativeIndex] > 0 ){\\n                negativeIndex++;\\n            } \\n\\n            if(currentIndex %2 == 0){\\n                ans.push_back(nums[positiveIndex]);\\n                positiveIndex++;\\n                currentIndex++;\\n            }  else{\\n                ans.push_back(nums[negativeIndex]);\\n                negativeIndex++;\\n                currentIndex++;\\n            }\\n        }\\n\\n        while(positiveIndex < nums.size() && nums[positiveIndex] >= 0){\\n            ans.push_back(nums[positiveIndex]);\\n            positiveIndex++;\\n            currentIndex++;\\n        }\\n        while(negativeIndex < nums.size() && nums[negativeIndex] < 0){\\n            ans.push_back(nums[negativeIndex]);\\n            negativeIndex++;\\n            currentIndex++;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rearrange-array-elements-by-sign","has_notes":false,"flag_type":1,"frontend_id":235},{"id":1729697594,"question_id":136,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1754802010,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1729697594/","is_pending":"Not Pending","title":"Single Number","memory":"20.7 MB","code":"class Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int xorArr = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            xorArr ^= nums[i];\\n        }\\n\\n        return xorArr;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111","title_slug":"single-number","has_notes":false,"flag_type":1,"frontend_id":234},{"id":1729682356,"question_id":485,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1754800842,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1729682356/","is_pending":"Not Pending","title":"Max Consecutive Ones","memory":"50.1 MB","code":"class Solution {\\npublic:\\n    int findMaxConsecutiveOnes(vector<int>& nums) {\\n        int currentOne = 0;\\n        int maxOne = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == 0){\\n                currentOne = 0;\\n                continue;\\n            }\\n            currentOne++;\\n            maxOne = max(maxOne,currentOne);\\n        }\\n        return maxOne;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111","title_slug":"max-consecutive-ones","has_notes":false,"flag_type":1,"frontend_id":233},{"id":1729674624,"question_id":268,"lang":"cpp","lang_name":"C++","time":"4\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1754800216,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1729674624/","is_pending":"Not Pending","title":"Missing Number","memory":"21.8 MB","code":"class Solution {\\npublic:\\n    int missingNumber(vector<int>& nums) {\\n        int missingNumber = 0;\\n        int xorN = 0;\\n        int xorArr = 0;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            xorArr ^= nums[i];\\n        }\\n\\n        for(int i=0; i<= nums.size(); i++){\\n            xorN ^= i;\\n        }\\n\\n        missingNumber = xorN ^ xorArr;\\n        return missingNumber;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"missing-number","has_notes":false,"flag_type":1,"frontend_id":232},{"id":1729643999,"question_id":3951,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754798069,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1729643999/","is_pending":"Not Pending","title":"Next Special Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    long long specialPalindrome(long long n) {\\n        if(n<=1){\\n            return 1;\\n        }\\n        if(n<22){\\n            return 22;\\n        }\\n        long long palindrome = 1;\\n        vector<int>digits = {2,4,6,8};\\n\\n        // int countDigits = 0;\\n        // int remainder = 0;\\n        // long long numCopy = n;\\n        // while(numCopy != 0){\\n        //     numCopy /= 10;\\n        //     countDigits++;\\n        // }\\n\\n        deque<int>ans = {1};\\n        int currentDigitCount = 0;\\n        \\n        long long finalAns = 0;\\n        while(finalAns < n){\\n            currentDigitCount = currentDigitCount % 4;\\n            int currentDigit = digits[currentDigitCount];\\n\\n            for(int i=0; i<currentDigit/2; i++){\\n                ans.push_front(currentDigit);\\n                ans.push_back(currentDigit);\\n            }\\n            deque<int>temp=ans;\\n            finalAns = 0;\\n        while(!temp.empty()){\\n            int poppedElement = temp.front();\\n            temp.pop_front();\\n            finalAns = finalAns*10 + poppedElement;\\n        }\\n            currentDigitCount++;\\n        }\\n\\n\\n        return finalAns;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"next-special-palindrome-number","has_notes":false,"flag_type":1,"frontend_id":231}],"has_next":true,"last_key":""}'
2026-01-10 09:26:31,195 [INFO] __main__.py:245 - Writing subarray-sum-equals-k/2025-08-18 11.56.05 - Accepted - runtime 54ms - memory 51MB.cpp
2026-01-10 09:26:31,196 [INFO] __main__.py:188 - Skipping subarray-sum-equals-k 2025-08-18 11.50.06 because its status is 'Wrong Answer'
2026-01-10 09:26:31,197 [INFO] __main__.py:188 - Skipping subarray-sum-equals-k 2025-08-18 11.44.37 because its status is 'Wrong Answer'
2026-01-10 09:26:31,197 [INFO] __main__.py:188 - Skipping subarray-sum-equals-k 2025-08-18 11.42.02 because its status is 'Wrong Answer'
2026-01-10 09:26:33,036 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:33,039 [INFO] __main__.py:245 - Writing longest-consecutive-sequence/2025-08-17 23.59.09 - Accepted - runtime 85ms - memory 88.8MB.cpp
2026-01-10 09:26:33,040 [INFO] __main__.py:188 - Skipping longest-consecutive-sequence 2025-08-17 23.50.04 because its status is 'Wrong Answer'
2026-01-10 09:26:33,040 [INFO] __main__.py:188 - Skipping longest-consecutive-sequence 2025-08-17 23.41.25 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:33,040 [INFO] __main__.py:188 - Skipping longest-consecutive-sequence 2025-08-17 23.40.55 because its status is 'Output Limit Exceeded'
2026-01-10 09:26:33,352 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:33,354 [INFO] __main__.py:245 - Writing next-permutation/2025-08-17 21.46.13 - Accepted - runtime 0ms - memory 15.5MB.cpp
2026-01-10 09:26:33,355 [INFO] __main__.py:188 - Skipping minimum-sum-after-divisible-sum-deletions 2025-08-17 09.18.57 because its status is 'Wrong Answer'
2026-01-10 09:26:33,356 [INFO] __main__.py:188 - Skipping minimum-sum-after-divisible-sum-deletions 2025-08-17 09.15.21 because its status is 'Wrong Answer'
2026-01-10 09:26:33,356 [INFO] __main__.py:188 - Skipping xor-after-range-multiplication-queries-ii 2025-08-17 08.30.20 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:34,824 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:34,827 [INFO] __main__.py:245 - Writing xor-after-range-multiplication-queries-i/2025-08-17 08.21.42 - Accepted - runtime 71ms - memory 158.2MB.cpp
2026-01-10 09:26:34,828 [INFO] __main__.py:188 - Skipping xor-after-range-multiplication-queries-i 2025-08-17 08.19.53 because its status is 'Runtime Error'
2026-01-10 09:26:34,828 [INFO] __main__.py:188 - Skipping number-of-perfect-pairs 2025-08-16 20.11.42 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:35,134 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:35,138 [INFO] __main__.py:245 - Writing rearrange-array-elements-by-sign/2025-08-16 09.28.42 - Accepted - runtime 15ms - memory 134.5MB.cpp
2026-01-10 09:26:36,168 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:36,171 [INFO] __main__.py:245 - Writing single-number/2025-08-10 10.30.10 - Accepted - runtime 0ms - memory 20.7MB.cpp
2026-01-10 09:26:36,495 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:36,498 [INFO] __main__.py:245 - Writing max-consecutive-ones/2025-08-10 10.10.42 - Accepted - runtime 0ms - memory 50.1MB.cpp
2026-01-10 09:26:37,982 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:37,986 [INFO] __main__.py:245 - Writing missing-number/2025-08-10 10.00.16 - Accepted - runtime 0ms - memory 21.8MB.cpp
2026-01-10 09:26:37,987 [INFO] __main__.py:188 - Skipping next-special-palindrome-number 2025-08-10 09.24.29 because its status is 'Wrong Answer'
2026-01-10 09:26:42,992 [DEBUG] leetcode.py:150 - Exporting submissions from 320 to 340
2026-01-10 09:26:44,101 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=320&limit=20 HTTP/1.1" 200 None
2026-01-10 09:26:44,105 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1729591835,"question_id":3950,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754795800,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1729591835/","is_pending":"Not Pending","title":"Maximum K to Sort a Permutation","memory":"N/A","code":"class Solution {\\npublic:\\n    int sortPermutation(vector<int>& nums) {\\n        int currentK = 0;\\n        int maxK = 0;\\n\\n        vector<int>temp = nums;\\n\\n        sort(temp.begin(),temp.end());\\n        // check sorted\\n        bool isSorted=true;\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] != temp[i]){\\n            currentK = nums[i] & temp[i];\\n            maxK = max(maxK,currentK);\\n                isSorted=false;\\n            }\\n        }\\n\\n        if(isSorted){\\n            return 0;\\n        }\\n\\n        return maxK;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111011000010011011010100111111000101001011010111110011111011011001111011110010011011000011100011001101110100111110100010010111010011000001001000000000010010000000000011100110000000001010100001000010010110111100100010010001000100010100010010010000110010010010111100110101000010011001100101100010110001101001001111111010110100110000110001000000001001000100010110110110001011110110111110101000010110001000010011001100100111011011011100111001110110000111111001100001011001010000000111100100100001000101010011011111000111100100011110000000001011001100100110010010011001001011100111001110100100111010101100101101000010011010000100000101010010100011100101010001110000100000010010000101100001100010001110111011000001100110101000110000010010000000110111000111000100001000011111100001110011111","title_slug":"maximum-k-to-sort-a-permutation","has_notes":false,"flag_type":1,"frontend_id":230},{"id":1729564705,"question_id":3973,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754794708,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1729564705/","is_pending":"Not Pending","title":"Flip Square Submatrix Vertically","memory":"34 MB","code":"class Solution {\\n    void swapfn(vector<vector<int>>&grid,int col,int start,int end){\\n        swap(grid[start][col],grid[end][col]);\\n    }\\npublic:\\n    vector<vector<int>> reverseSubmatrix(vector<vector<int>>& grid, int x, int y, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        for(int i=y; i<y+k; i++){\\n            int start = x;\\n            int end = x+k-1;\\n            while(start < end){\\n                swapfn(grid,i,start,end);\\n                start++;end--;\\n            }\\n        }\\n        return grid;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flip-square-submatrix-vertically","has_notes":false,"flag_type":1,"frontend_id":229},{"id":1729559744,"question_id":3973,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754794511,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1729559744/","is_pending":"Not Pending","title":"Flip Square Submatrix Vertically","memory":"N/A","code":"class Solution {\\n    void swapfn(vector<vector<int>>&grid,int col,int start,int end){\\n        swap(grid[start][col],grid[end][col]);\\n    }\\npublic:\\n    vector<vector<int>> reverseSubmatrix(vector<vector<int>>& grid, int x, int y, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        for(int i=y; i<y+k; i++){\\n            int start = x;\\n            int end = grid.size()-1;\\n            while(start < end){\\n                swapfn(grid,i,start,end);\\n                start++;end--;\\n            }\\n        }\\n        return grid;\\n    }\\n};","compare_result":"11111111111101000000110000100010101110101100111000000100000010000010100100100000101101010011001100111000111011010101011000111010101110001100011000000000111110101111010111110011011010000101101100111010101101111001111001000100111111011110110001101100011000011011011100101011010001101011111101101111001101001010111010010110011101101001100111101011000010111010101111110001101111110110001000000111000011011011111011000010110001010010011111011000101100001111101111010110111110110101111011001011111110110111111000100100100100100011000001001010111000000100000001010010001100100100000100111100001100111000100000010000000010000000000000000000000000000000100010000000000000000000000011","title_slug":"flip-square-submatrix-vertically","has_notes":false,"flag_type":1,"frontend_id":228},{"id":1729555977,"question_id":3973,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754794364,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1729555977/","is_pending":"Not Pending","title":"Flip Square Submatrix Vertically","memory":"N/A","code":"class Solution {\\n    void swapfn(vector<vector<int>>&grid,int col,int start,int end){\\n        swap(grid[start][col],grid[end][col]);\\n    }\\npublic:\\n    vector<vector<int>> reverseSubmatrix(vector<vector<int>>& grid, int x, int y, int k) {\\n        for(int i=y; i<y+k; i++){\\n            int start = x;\\n            int end = grid.size()-1;\\n            while(start < end){\\n                swapfn(grid,i,start,end);\\n                start++;end--;\\n            }\\n        }\\n        return grid;\\n    }\\n};","compare_result":"11111111111101000000110000100010101110101100111000000100000010000010100100100000101101010011001100111000111011010101011000111010101110001100011000000000111110101111010111110011011010000101101100111010101101111001111001000100111111011110110001101100011000011011011100101011010001101011111101101111001101001010111010010110011101101001100111101011000010111010101111110001101111110110001000000111000011011011111011000010110001010010011111011000101100001111101111010110111110110101111011001011111110110111111000100100100100100011000001001010111000000100000001010010001100100100000100111100001100111000100000010000000010000000000000000000000000000000100010000000000000000000000011","title_slug":"flip-square-submatrix-vertically","has_notes":false,"flag_type":1,"frontend_id":227},{"id":1721844168,"question_id":9,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754222998,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1721844168/","is_pending":"Not Pending","title":"Palindrome Number","memory":"8.7 MB","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0){\\n            return false;\\n        }\\n        long reverse = 0,remainder = 0,number = x;\\n        while(number != 0){\\n            remainder = number % 10;\\n            number /= 10;\\n            reverse = reverse * 10 + remainder;\\n        }\\n        if(reverse == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":226},{"id":1721843736,"question_id":9,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754222967,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1721843736/","is_pending":"Not Pending","title":"Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x < 0){\\n            return false;\\n        }\\n        int reverse = 0,remainder = 0,number = x;\\n        while(number != 0){\\n            remainder = number % 10;\\n            number /= 10;\\n            reverse = reverse * 10 + remainder;\\n        }\\n        if(reverse == x){\\n            return true;\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":225},{"id":1721835405,"question_id":7,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754222393,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1721835405/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.6 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n            int remainder=0,numCpy=x,finalAns = 0;\\n\\n            while(numCpy!=0){\\n                remainder = numCpy % 10;\\n                numCpy /= 10;\\n                if(finalAns > INT_MAX/10 || finalAns < INT_MIN/10){return 0;}\\n                finalAns = finalAns * 10 + remainder;\\n            }\\n\\n            return finalAns;\\n        }\\n\\n    \\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":224},{"id":1721831007,"question_id":7,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754222086,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1721831007/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n            int remainder=0,numCpy=x,finalAns = 0;\\n\\n            if((x > INT_MAX) || (x < INT_MIN)){\\n                return 0;\\n            }\\n            while(numCpy!=0){\\n                remainder = numCpy % 10;\\n                numCpy /= 10;\\n                finalAns = finalAns * 10 + remainder;\\n            }\\n\\n            return finalAns;\\n        }\\n\\n    \\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":223},{"id":1721830110,"question_id":7,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months","timestamp":1754222022,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1721830110/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n            int remainder=0,numCpy=x,finalAns = 0;\\n\\n            if((x > INT_MAX) || (x < INT_MIN)){\\n                return 0;\\n            }\\n            while(numCpy!=0){\\n                remainder = numCpy % 10;\\n                numCpy /= 10;\\n                finalAns = finalAns * 10 + remainder;\\n            }\\n\\n            return finalAns;\\n        }\\n\\n    \\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":222},{"id":1721072428,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754159059,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721072428/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n    sort(intervals.begin(),intervals.end());\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0])) {\\n                    vector<int> ans = {intervals[i][0], max(intervals[i][1],intervals[j][1])};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":221},{"id":1721071877,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754159033,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721071877/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n    sort(intervals.begin(),intervals.end());\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0])) {\\n                    vector<int> ans = {intervals[i][0], max(intervals[i][0],intervals[j][1])};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111111100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":220},{"id":1721070787,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754158977,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721070787/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n    sort(intervals.begin(),intervals.end());\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0]) &&\\n                    (intervals[i][1] <= intervals[j][1])) {\\n                    vector<int> ans = {intervals[i][0], max(intervals[i][0],intervals[j][1])};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111111100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":219},{"id":1721065740,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754158725,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721065740/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n    sort(intervals.begin(),intervals.end());\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0]) &&\\n                    (intervals[i][1] <= intervals[j][1])) {\\n                    vector<int> ans = {intervals[i][0], intervals[j][1]};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111111100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":218},{"id":1721059708,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754158428,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721059708/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0]) &&\\n                    (intervals[i][1] <= intervals[j][1])) {\\n                    vector<int> ans = {intervals[i][0], intervals[j][1]};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":217},{"id":1721058834,"question_id":56,"lang":"cpp","lang_name":"C++","time":"5\xc2\xa0months, 1\xc2\xa0week","timestamp":1754158387,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1721058834/","is_pending":"Not Pending","title":"Merge Intervals","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        vector<vector<int>> result;\\n        vector<vector<int>> exists;\\n\\n        for (int i = 0; i < intervals.size(); i++) {\\n            bool flag = false;\\n            for (int j = i+1; j < intervals.size(); j++) {\\n                if ((intervals[i][1] >= intervals[j][0]) &&\\n                    (intervals[i][1] < intervals[j][1])) {\\n                    vector<int> ans = {intervals[i][0], intervals[j][1]};\\n                   \\n                    exists.push_back(intervals[i]);\\n                    exists.push_back(intervals[j]);\\n\\n                    result.push_back(ans);\\n                    flag = true;\\n                }\\n            }\\n            if (!flag) {\\n                bool check = false;\\n                for (int k=0; k<exists.size();k++) {\\n                    if (intervals[k] == intervals[i]) {\\n                        check = true;\\n                    }\\n                }\\n                if (!check) {\\n\\n                    result.push_back(intervals[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"111011100000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"merge-intervals","has_notes":false,"flag_type":1,"frontend_id":216},{"id":1677564002,"question_id":48,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750962322,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677564002/","is_pending":"Not Pending","title":"Rotate Image","memory":"10.1 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j = i; j<matrix[0].size(); j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n                \\n            }\\n        }\\n        int size = matrix.size()-1;\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix[0].size()/2; j++){\\n                swap(matrix[i][j], matrix[i][size-j]) ;\\n            }\\n        }\\n\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"rotate-image","has_notes":false,"flag_type":1,"frontend_id":215},{"id":1677559113,"question_id":48,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750962060,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677559113/","is_pending":"Not Pending","title":"Rotate Image","memory":"10.1 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j = i; j<matrix[0].size(); j++){\\n                swap(matrix[i][j],matrix[j][i]);\\n                \\n            }\\n        }\\n        int size = matrix.size()-1;\\n        for(int i=0; i<matrix.size(); i++){\\n            for(int j=0; j<matrix[0].size()/2; j++){\\n                swap(matrix[i][j], matrix[i][size-j]) ;\\n            }\\n        }\\n\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"rotate-image","has_notes":false,"flag_type":1,"frontend_id":214},{"id":1677535180,"question_id":121,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750960801,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677535180/","is_pending":"Not Pending","title":"Best Time to Buy and Sell Stock","memory":"97.3 MB","code":"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int mini = INT_MAX, maxi = INT_MIN;\\n        for (int i = 0; i < prices.size(); i++) {\\n            if (prices[i] < mini) {\\n                mini = prices[i];\\n            } else {\\n                int difference = prices[i] - mini;\\n                maxi = max(maxi, difference);\\n            }\\n        }\\n        if (maxi <= 0) {\\n            return 0;\\n        }\\n        return maxi;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"best-time-to-buy-and-sell-stock","has_notes":false,"flag_type":1,"frontend_id":213},{"id":1677520281,"question_id":121,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750960037,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1677520281/","is_pending":"Not Pending","title":"Best Time to Buy and Sell Stock","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = 0, sell = prices.size() - 1;\\n        int maxDiff = INT_MIN;\\n        for (int i = 0; i < prices.size(); i++) {\\n            for (int j = i; j < prices.size(); j++) {\\n                int difference = prices[j] - prices[i];\\n                if (difference >= 0) {\\n                    maxDiff = max(maxDiff, difference);\\n                }\\n            }\\n        }\\n        if (maxDiff <= 0) {\\n            return 0;\\n        }\\n        return maxDiff;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000","title_slug":"best-time-to-buy-and-sell-stock","has_notes":false,"flag_type":1,"frontend_id":212},{"id":1677512681,"question_id":121,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750959650,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1677512681/","is_pending":"Not Pending","title":"Best Time to Buy and Sell Stock","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy = 0, sell = prices.size()-1;\\n        int difference = 0;\\n        int maxDiff = INT_MIN;\\n        while(buy < sell){\\n            difference = prices[sell] - prices[buy];\\n            if(difference > 0){\\n                maxDiff = max(maxDiff,difference);\\n            }\\n            buy++;sell--;\\n        }\\n        if(maxDiff <= 0){\\n            return 0;\\n        }\\n        return maxDiff;\\n    }\\n};","compare_result":"11111110000111000100000101000010000010100010101101000101000101000000000010100000000000000000000010100000100000000000000010100000100000000000000010100000100000000000001001000000010000110000100000000000000000001100","title_slug":"best-time-to-buy-and-sell-stock","has_notes":false,"flag_type":1,"frontend_id":211}],"has_next":true,"last_key":""}'
2026-01-10 09:26:44,106 [INFO] __main__.py:188 - Skipping maximum-k-to-sort-a-permutation 2025-08-10 08.46.40 because its status is 'Wrong Answer'
2026-01-10 09:26:44,453 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:44,455 [INFO] __main__.py:245 - Writing flip-square-submatrix-vertically/2025-08-10 08.28.28 - Accepted - runtime 0ms - memory 34MB.cpp
2026-01-10 09:26:44,455 [INFO] __main__.py:188 - Skipping flip-square-submatrix-vertically 2025-08-10 08.25.11 because its status is 'Wrong Answer'
2026-01-10 09:26:44,455 [INFO] __main__.py:188 - Skipping flip-square-submatrix-vertically 2025-08-10 08.22.44 because its status is 'Wrong Answer'
2026-01-10 09:26:44,778 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:44,780 [INFO] __main__.py:245 - Writing palindrome-number/2025-08-03 17.39.58 - Accepted - runtime 3ms - memory 8.7MB.cpp
2026-01-10 09:26:44,781 [INFO] __main__.py:188 - Skipping palindrome-number 2025-08-03 17.39.27 because its status is 'Runtime Error'
2026-01-10 09:26:45,093 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:45,095 [INFO] __main__.py:245 - Writing reverse-integer/2025-08-03 17.29.53 - Accepted - runtime 0ms - memory 8.6MB.cpp
2026-01-10 09:26:45,095 [INFO] __main__.py:188 - Skipping reverse-integer 2025-08-03 17.24.46 because its status is 'Runtime Error'
2026-01-10 09:26:45,095 [INFO] __main__.py:188 - Skipping reverse-integer 2025-08-03 17.23.42 because its status is 'Runtime Error'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.54.19 because its status is 'Wrong Answer'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.53.53 because its status is 'Wrong Answer'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.52.57 because its status is 'Wrong Answer'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.48.45 because its status is 'Wrong Answer'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.43.48 because its status is 'Wrong Answer'
2026-01-10 09:26:45,096 [INFO] __main__.py:188 - Skipping merge-intervals 2025-08-02 23.43.07 because its status is 'Wrong Answer'
2026-01-10 09:26:45,097 [INFO] __main__.py:245 - Writing rotate-image/2025-06-26 23.55.22 - Accepted - runtime 0ms - memory 10.1MB.cpp
2026-01-10 09:26:45,098 [INFO] __main__.py:245 - Writing rotate-image/2025-06-26 23.51.00 - Accepted - runtime 0ms - memory 10.1MB.cpp
2026-01-10 09:26:45,098 [INFO] __main__.py:245 - Writing best-time-to-buy-and-sell-stock/2025-06-26 23.30.01 - Accepted - runtime 0ms - memory 97.3MB.cpp
2026-01-10 09:26:45,098 [INFO] __main__.py:188 - Skipping best-time-to-buy-and-sell-stock 2025-06-26 23.17.17 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:45,098 [INFO] __main__.py:188 - Skipping best-time-to-buy-and-sell-stock 2025-06-26 23.10.50 because its status is 'Wrong Answer'
2026-01-10 09:26:50,104 [DEBUG] leetcode.py:150 - Exporting submissions from 340 to 360
2026-01-10 09:26:50,627 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=340&limit=20 HTTP/1.1" 200 None
2026-01-10 09:26:50,635 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1677501269,"question_id":53,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750959065,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677501269/","is_pending":"Not Pending","title":"Maximum Subarray","memory":"71.6 MB","code":"class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n\\n            if(sum > maxi){\\n                maxi = sum;\\n            }\\n            if(sum < 0 ){\\n                sum = 0;\\n            }\\n\\n        }\\n        return maxi;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"maximum-subarray","has_notes":false,"flag_type":1,"frontend_id":210},{"id":1677498745,"question_id":53,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750958935,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1677498745/","is_pending":"Not Pending","title":"Maximum Subarray","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        int sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sum+=nums[i];\\n\\n            if(sum > maxi){\\n                maxi = sum;\\n            }\\n            else if(sum < 0 ){\\n                sum = 0;\\n            }\\n\\n        }\\n        return maxi;\\n    }\\n};","compare_result":"111110010111011111110111101111111110010101011001011011111110111111100101110011111110111111110111010111111111011111110111111101110111111111111010110111111111111011111111111111110111011111111001111111111111111111","title_slug":"maximum-subarray","has_notes":false,"flag_type":1,"frontend_id":209},{"id":1677485776,"question_id":53,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750958275,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1677485776/","is_pending":"Not Pending","title":"Maximum Subarray","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++){\\n            int sum = 0;\\n            for(int j=i; j<nums.size();j++){\\n                sum += nums[j];\\n                maxi = max(sum,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000","title_slug":"maximum-subarray","has_notes":false,"flag_type":1,"frontend_id":208},{"id":1677475106,"question_id":53,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750957727,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1677475106/","is_pending":"Not Pending","title":"Maximum Subarray","memory":"N/A","code":"class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxi = INT_MIN;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j = i; j<nums.size(); j++){\\n                int sum = 0;\\n                for(int k = i; k<=j ;k++){\\n                    sum += nums[k];\\n                }   \\n                maxi = max(sum,maxi);\\n            }\\n        }\\n        return maxi;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000","title_slug":"maximum-subarray","has_notes":false,"flag_type":1,"frontend_id":207},{"id":1677367461,"question_id":75,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750951740,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677367461/","is_pending":"Not Pending","title":"Sort Colors","memory":"11.7 MB","code":"class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        if(nums.size() == 1){\\n            return;\\n        }\\n\\n        int low=0,mid=0,high=nums.size()-1;\\n\\n        while(mid<=high){\\n            if(nums[mid] == 0){\\n                swap(nums[low],nums[mid]);\\n                low++;\\n                mid++;\\n            }\\n            else if(nums[mid]==1){\\n                mid++;\\n            }\\n            else if(nums[mid]==2){\\n                swap(nums[mid],nums[high]);\\n                high--;\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"sort-colors","has_notes":false,"flag_type":1,"frontend_id":206},{"id":1677357104,"question_id":75,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 2\xc2\xa0weeks","timestamp":1750951140,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1677357104/","is_pending":"Not Pending","title":"Sort Colors","memory":"11.7 MB","code":"class Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        unordered_map<int,int>count;\\n        int i = nums.size()-1;\\n        while(i>=0){\\n            if(nums[i]==0){\\n                count[0]++;\\n            }\\n            else if(nums[i]==1){\\n                count[1]++;\\n            }\\n            else if(nums[i]==2){\\n                count[2]++;\\n            }\\n            i--;\\n        }\\n        vector<int> ans;\\n        for(int i=0; i<3; i++){\\n            int size = count[i];\\n            for(int j=0; j<size;j++){\\n                ans.push_back(i);\\n            }\\n        }\\n        nums=ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"sort-colors","has_notes":false,"flag_type":1,"frontend_id":205},{"id":1662420397,"question_id":118,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1749776494,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1662420397/","is_pending":"Not Pending","title":"Pascal\'s Triangle","memory":"9.6 MB","code":"class Solution {\\n    vector<int> calculatePascalRow(int numRow){\\n        long long val = 1;\\n        vector<int>ans;\\n        ans.push_back(val);\\n        for(int i=1; i<numRow; i++){\\n            val = val * (numRow-i)/i;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>result;\\n        for(int i=1; i<=numRows; i++){\\n            result.push_back(calculatePascalRow(i));\\n        }\\n        return result;\\n    }\\n};","compare_result":"111111111111111111111111111111","title_slug":"pascals-triangle","has_notes":false,"flag_type":1,"frontend_id":204},{"id":1662418852,"question_id":118,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1749776223,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1662418852/","is_pending":"Not Pending","title":"Pascal\'s Triangle","memory":"N/A","code":"class Solution {\\n    vector<int> calculatePascalRow(int i){\\n        int val = 1;\\n        vector<int>ans;\\n        ans.push_back(val);\\n        for(int i=2; i<numRows; i++){\\n            val = val * (val-i)/i;\\n            ans.push_back(val);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<int>> generate(int numRows) {\\n        vector<vector<int>>result;\\n        for(int i=1; i<=numRows; i++){\\n            ans.push_back(calculatePascalRow(i))\\n        }\\n    }\\n};","compare_result":null,"title_slug":"pascals-triangle","has_notes":false,"flag_type":1,"frontend_id":203},{"id":1661538259,"question_id":118,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1749706880,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1661538259/","is_pending":"Not Pending","title":"Pascal\'s Triangle","memory":"N/A","code":"class Solution {\\npublic:\\n    long long factorial(int n)\\n  {\\n    long long result = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n      result *= i;\\n    }\\n    return result;\\n  }\\n  int nCr(int n, int r)\\n  {\\n    int nfact = factorial(n);\\n    int rfact = factorial(r);\\n    int nrfact = factorial(n - r);\\n    return nfact / (rfact * nrfact);\\n  }\\n  vector<int>\\n  calculatePascalRow(int numRow)\\n  {\\n    vector<int> pascalRow;\\n    pascalRow.push_back(1);\\n    if (numRow >= 2)\\n    {\\n      for (int i = 2; i < numRow; i++)\\n      {\\n        long long pascalElement = nCr(numRow - 1, i - 1);\\n        pascalRow.push_back(pascalElement);\\n      }\\n      pascalRow.push_back(1);\\n    }\\n    return pascalRow;\\n  }\\n\\npublic:\\n  vector<vector<int>> generate(int numRows)\\n  {\\n    vector<vector<int>> ans;\\n    for (int i = 1; i <= numRows; i++)\\n    {\\n      vector<int> rowAns = calculatePascalRow(i);\\n      ans.push_back(rowAns);\\n    }\\n    return ans;\\n  }\\n};","compare_result":"111111111111100000000000000000","title_slug":"pascals-triangle","has_notes":false,"flag_type":1,"frontend_id":202},{"id":1661534758,"question_id":118,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1749706668,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1661534758/","is_pending":"Not Pending","title":"Pascal\'s Triangle","memory":"N/A","code":"class Solution {\\npublic:\\n    int factorial(int n)\\n  {\\n    int result = 1;\\n    for (int i = 1; i <= n; i++)\\n    {\\n      result *= i;\\n    }\\n    return result;\\n  }\\n  int nCr(int n, int r)\\n  {\\n    int nfact = factorial(n);\\n    int rfact = factorial(r);\\n    int nrfact = factorial(n - r);\\n    return nfact / (rfact * nrfact);\\n  }\\n  vector<int>\\n  calculatePascalRow(int numRow)\\n  {\\n    vector<int> pascalRow;\\n    pascalRow.push_back(1);\\n    if (numRow >= 2)\\n    {\\n      for (int i = 2; i < numRow; i++)\\n      {\\n        int pascalElement = nCr(numRow - 1, i - 1);\\n        pascalRow.push_back(pascalElement);\\n      }\\n      pascalRow.push_back(1);\\n    }\\n    return pascalRow;\\n  }\\n\\npublic:\\n  vector<vector<int>> generate(int numRows)\\n  {\\n    vector<vector<int>> ans;\\n    for (int i = 1; i <= numRows; i++)\\n    {\\n      vector<int> rowAns = calculatePascalRow(i);\\n      ans.push_back(rowAns);\\n    }\\n    return ans;\\n  }\\n};","compare_result":"111111111111100000000000000000","title_slug":"pascals-triangle","has_notes":false,"flag_type":1,"frontend_id":201},{"id":1661452291,"question_id":73,"lang":"cpp","lang_name":"C++","time":"6\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1749701113,"status":10,"status_display":"Accepted","runtime":"1 ms","url":"/submissions/detail/1661452291/","is_pending":"Not Pending","title":"Set Matrix Zeroes","memory":"18.5 MB","code":"class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size();\\n        int colSize = matrix[0].size();\\n        int row0col0 = matrix[0][0];\\n        for (int i = 0; i < rowSize; i++) {\\n            for (int j = 0; j < colSize; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0) {\\n                        matrix[0][j] = 0;\\n                    } else {\\n                        row0col0 = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < rowSize; i++) {\\n            for (int j = 1; j < colSize; j++) {\\n                if (matrix[i][j] != 0) {\\n                    if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n\\n        if (matrix[0][0] == 0) {\\n            for (int j = 0; j < colSize; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        if (row0col0 == 0) {\\n            for (int i = 0; i < rowSize; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n;","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"set-matrix-zeroes","has_notes":false,"flag_type":1,"frontend_id":200},{"id":1610584511,"question_id":104,"lang":"cpp","lang_name":"C++","time":"8\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1744986368,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1610584511/","is_pending":"Not Pending","title":"Maximum Depth of Binary Tree","memory":"19 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int findHeight(TreeNode* root){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int left = findHeight(root->left);\\n        int right = findHeight(root->right);\\n        return max(left,right)+1;\\n    }\\npublic:\\n    int maxDepth(TreeNode* root) {\\n\\n        int ans = findHeight(root);\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"maximum-depth-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":199},{"id":1610578160,"question_id":144,"lang":"cpp","lang_name":"C++","time":"8\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1744985902,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1610578160/","is_pending":"Not Pending","title":"Binary Tree Preorder Traversal","memory":"10.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void preorder(vector<int>&ans,TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans.push_back(root->val);\\n        preorder(ans,root->left);\\n        preorder(ans,root->right);\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        preorder(ans,root);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-preorder-traversal","has_notes":false,"flag_type":1,"frontend_id":198},{"id":1610574931,"question_id":102,"lang":"cpp","lang_name":"C++","time":"8\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1744985679,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1610574931/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"17.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>finalans;\\n        if(root== NULL){\\n            return finalans;\\n        }\\n        queue<TreeNode* >q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int qsize = q.size();\\n            vector<int>tempans;\\n            for(int i=0;i<qsize;i++){\\n                TreeNode* front = q.front();\\n                q.pop();\\n\\n                tempans.push_back(front->val);\\n                if(front->left != NULL){\\n                    q.push(front->left); \\n                }\\n                if(front->right != NULL){\\n                    q.push(front->right);\\n                }\\n            }\\n                finalans.push_back(tempans);\\n        }\\n        return finalans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":197},{"id":1610547991,"question_id":94,"lang":"cpp","lang_name":"C++","time":"8\xc2\xa0months, 3\xc2\xa0weeks","timestamp":1744983778,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1610547991/","is_pending":"Not Pending","title":"Binary Tree Inorder Traversal","memory":"10.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void findInorder(TreeNode* root,vector<int>&ans){\\n        if(root == NULL){\\n            return;\\n        }\\n        findInorder(root->left,ans);\\n        ans.push_back(root->val);\\n        findInorder(root->right,ans);\\n    }\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n        findInorder(root,ans);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-inorder-traversal","has_notes":false,"flag_type":1,"frontend_id":196},{"id":1504925492,"question_id":733,"lang":"cpp","lang_name":"C++","time":"11\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1736588863,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1504925492/","is_pending":"Not Pending","title":"Flood Fill","memory":"18.2 MB","code":"class Solution {\\n    void dfs(vector<vector<int>>& ans, int sr, int sc, vector<int>& directionx,\\n             vector<int>& directiony, int color, int initialColor) \\n             {\\n                ans[sr][sc] = color;\\n                int n = ans.size();\\n                int m = ans[0].size();\\n\\n                for(int i=0; i<4; i++){\\n                    int nrow = sr + directionx[i];\\n                    int ncol = sc + directiony[i];\\n\\n                    if(nrow>=0 && nrow < n && ncol>=0 && ncol<m\\n                    && ans[nrow][ncol]==initialColor && ans[nrow][ncol]!=color){\\n                        dfs(ans, nrow, ncol, directionx, directiony, color, initialColor);\\n                    }\\n                }\\n             }\\n\\npublic:\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc,\\n                                  int color) {\\n        vector<vector<int>> ans = image;\\n        int initialColor = ans[sr][sc];\\n\\n        vector<int> directionx = {0, -1, 0, 1}; // LURD\\n        vector<int> directiony = {-1, 0, 1, 0}; // LURD\\n\\n        dfs(ans, sr, sc, directionx, directiony, color, initialColor);\\n\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flood-fill","has_notes":false,"flag_type":1,"frontend_id":195},{"id":1504839362,"question_id":200,"lang":"cpp","lang_name":"C++","time":"11\xc2\xa0months, 4\xc2\xa0weeks","timestamp":1736581692,"status":10,"status_display":"Accepted","runtime":"50 ms","url":"/submissions/detail/1504839362/","is_pending":"Not Pending","title":"Number of Islands","memory":"30.4 MB","code":"class Solution {\\n    void bfs(int row, int col, vector<vector<bool>>& visited,\\n             vector<vector<char>>& grid, int n, int m) {\\n        visited[row][col] = true;\\n        queue<pair<int, int>> q;\\n        q.push({row, col});\\n\\n        while (!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n            int qrow = front.first;\\n            int qcol = front.second;\\n            vector<int> directionRow = {0, -1, 0, 1}; // LURD\\n            vector<int> directionCol = {-1, 0, 1, 0};\\n\\n            for (int i = 0; i < 4; i++) {\\n                int nrow = qrow + directionRow[i];\\n                int ncol = qcol + directionCol[i];\\n\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < m &&\\n                    visited[nrow][ncol] == false && grid[nrow][ncol] == \'1\') {\\n                    q.push({nrow, ncol});\\n                    visited[nrow][ncol] = true;\\n                }\\n            }\\n        }\\n    }\\n\\npublic:\\n    int numIslands(vector<vector<char>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int cnt = 0;\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (!visited[i][j] && grid[i][j] == \'1\') {\\n                    cnt++;\\n                    bfs(i, j, visited, grid, n, m);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111","title_slug":"number-of-islands","has_notes":false,"flag_type":1,"frontend_id":194},{"id":1502489899,"question_id":1300,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year","timestamp":1736393817,"status":10,"status_display":"Accepted","runtime":"151 ms","url":"/submissions/detail/1502489899/","is_pending":"Not Pending","title":"Critical Connections in a Network","memory":"169.2 MB","code":"class Solution {\\n\\n    void dfs(int node,int timer,int parent,vector<int>&discovery,vector<bool>&visited,vector<int>&low,vector<vector<int>>&adj,vector<vector<int>>&result){\\n\\n        visited[node] = true;\\n        discovery[node] = low[node] = timer++;\\n\\n        for(auto neighbour: adj[node]){\\n            if(neighbour == parent){\\n                continue;\\n            }\\n            if(!visited[neighbour]){\\n                dfs(neighbour,timer,node,discovery,visited,low,adj,result);\\n                low[node] = min(low[node],low[neighbour]);\\n\\n                if(low[neighbour] > discovery[node]){\\n                    result.push_back({node,neighbour});\\n                }\\n            }\\n            else{\\n                //Backedge\\n                low[node] = min(low[node],discovery[neighbour]);\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0; i<connections.size();i++){\\n            int u = connections[i][0];\\n            int v = connections[i][1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        vector<int>discovery(n,-1);\\n        vector<int>low(n,-1);\\n        vector<bool>visited(n,false);\\n        int parent = -1;\\n        int timer=0;\\n\\n        vector<vector<int>>result;\\n\\n        for(int i=0; i<n; i++){\\n            if(!visited[i]){\\n                dfs(i,timer,parent,discovery,visited,low,adj,result);\\n            }\\n        }\\n        return result;\\n    }\\n};","compare_result":"11111111111111111","title_slug":"critical-connections-in-a-network","has_notes":false,"flag_type":1,"frontend_id":193},{"id":1487793368,"question_id":23,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year","timestamp":1735111480,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1487793368/","is_pending":"Not Pending","title":"Merge k Sorted Lists","memory":"18.3 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    class compare\\n{\\npublic:\\n  bool operator()(ListNode *a, ListNode *b)\\n  {\\n    return a->val > b->val;\\n  }\\n};\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode *, vector<ListNode *>, compare> minHeap;\\n\\n        int k = lists.size();\\n  for (int i = 0; i < k; i++)\\n  {\\n    if (lists[i] != NULL)\\n    {\\n      minHeap.push(lists[i]);\\n    }\\n  }\\n\\n  ListNode* head = NULL;\\n  ListNode* tail = NULL;\\n\\n  while(!minHeap.empty()){\\n    ListNode *top = minHeap.top();\\n    minHeap.pop();\\n    if(top->next != NULL){\\n      minHeap.push(top->next);\\n    }\\n\\n    if(head == NULL){\\n      head = top;\\n      tail = top;\\n    }\\n    else\\n    {\\n      tail->next = top;\\n      tail = top;\\n    }\\n  }\\n  return head;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"merge-k-sorted-lists","has_notes":false,"flag_type":1,"frontend_id":192},{"id":1473817188,"question_id":236,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733694253,"status":10,"status_display":"Accepted","runtime":"14 ms","url":"/submissions/detail/1473817188/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"17.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* getLCA(TreeNode* root, int p,int q){\\n        if(root == NULL){\\n            return NULL;\\n        }\\n        if(root->val == p || root->val == q){\\n            return root;\\n        }\\n        TreeNode* left = getLCA(root->left,p,q);\\n        TreeNode* right = getLCA(root->right,p,q);\\n\\n        if(left != NULL && right != NULL){\\n            return root;\\n        }\\n        else if(left == NULL && right != NULL){\\n            return right;\\n        }\\n        else if(left != NULL && right == NULL){\\n            return left;\\n        }\\n        else{\\n            return NULL;\\n        }\\n    }\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        \\n        TreeNode* ans = getLCA(root,p->val,q->val);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1,"frontend_id":191}],"has_next":true,"last_key":""}'
2026-01-10 09:26:50,946 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:50,948 [INFO] __main__.py:245 - Writing maximum-subarray/2025-06-26 23.01.05 - Accepted - runtime 0ms - memory 71.6MB.cpp
2026-01-10 09:26:50,949 [INFO] __main__.py:188 - Skipping maximum-subarray 2025-06-26 22.58.55 because its status is 'Wrong Answer'
2026-01-10 09:26:50,949 [INFO] __main__.py:188 - Skipping maximum-subarray 2025-06-26 22.47.55 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:50,950 [INFO] __main__.py:188 - Skipping maximum-subarray 2025-06-26 22.38.47 because its status is 'Time Limit Exceeded'
2026-01-10 09:26:51,273 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:51,276 [INFO] __main__.py:245 - Writing sort-colors/2025-06-26 20.59.00 - Accepted - runtime 0ms - memory 11.7MB.cpp
2026-01-10 09:26:51,277 [INFO] __main__.py:245 - Writing sort-colors/2025-06-26 20.49.00 - Accepted - runtime 0ms - memory 11.7MB.cpp
2026-01-10 09:26:51,685 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:51,687 [INFO] __main__.py:245 - Writing pascals-triangle/2025-06-13 06.31.34 - Accepted - runtime 0ms - memory 9.6MB.cpp
2026-01-10 09:26:51,688 [INFO] __main__.py:188 - Skipping pascals-triangle 2025-06-13 06.27.03 because its status is 'Compile Error'
2026-01-10 09:26:51,688 [INFO] __main__.py:188 - Skipping pascals-triangle 2025-06-12 11.11.20 because its status is 'Wrong Answer'
2026-01-10 09:26:51,689 [INFO] __main__.py:188 - Skipping pascals-triangle 2025-06-12 11.07.48 because its status is 'Runtime Error'
2026-01-10 09:26:51,689 [INFO] __main__.py:245 - Writing set-matrix-zeroes/2025-06-12 09.35.13 - Accepted - runtime 1ms - memory 18.5MB.cpp
2026-01-10 09:26:51,690 [INFO] __main__.py:245 - Writing maximum-depth-of-binary-tree/2025-04-18 19.56.08 - Accepted - runtime 0ms - memory 19MB.cpp
2026-01-10 09:26:52,092 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:52,094 [INFO] __main__.py:245 - Writing binary-tree-preorder-traversal/2025-04-18 19.48.22 - Accepted - runtime 0ms - memory 10.8MB.cpp
2026-01-10 09:26:52,095 [INFO] __main__.py:245 - Writing binary-tree-level-order-traversal/2025-04-18 19.44.39 - Accepted - runtime 0ms - memory 17.1MB.cpp
2026-01-10 09:26:52,406 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:52,408 [INFO] __main__.py:245 - Writing binary-tree-inorder-traversal/2025-04-18 19.12.58 - Accepted - runtime 0ms - memory 10.8MB.cpp
2026-01-10 09:26:52,995 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:53,003 [INFO] __main__.py:245 - Writing flood-fill/2025-01-11 15.17.43 - Accepted - runtime 0ms - memory 18.2MB.cpp
2026-01-10 09:26:53,311 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:53,313 [INFO] __main__.py:245 - Writing number-of-islands/2025-01-11 13.18.12 - Accepted - runtime 50ms - memory 30.4MB.cpp
2026-01-10 09:26:53,710 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:53,713 [INFO] __main__.py:245 - Writing critical-connections-in-a-network/2025-01-09 09.06.57 - Accepted - runtime 151ms - memory 169.2MB.cpp
2026-01-10 09:26:53,714 [INFO] __main__.py:245 - Writing merge-k-sorted-lists/2024-12-25 12.54.40 - Accepted - runtime 0ms - memory 18.3MB.cpp
2026-01-10 09:26:53,714 [INFO] __main__.py:245 - Writing lowest-common-ancestor-of-a-binary-tree/2024-12-09 03.14.13 - Accepted - runtime 14ms - memory 17.5MB.cpp
2026-01-10 09:26:58,717 [DEBUG] leetcode.py:150 - Exporting submissions from 360 to 380
2026-01-10 09:26:59,092 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=360&limit=20 HTTP/1.1" 200 None
2026-01-10 09:26:59,119 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1473804662,"question_id":101,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733692619,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1473804662/","is_pending":"Not Pending","title":"Symmetric Tree","memory":"18.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root1, TreeNode* root2, bool& ans) {\\n        if (root1 == NULL && root2 == NULL) {\\n            return;\\n        } else if ((root1 == NULL || root2 == NULL)) {\\n            ans = false;\\n            return;\\n        }\\n        solve(root1->left, root2->right, ans);\\n        if (root1->val != root2->val) {\\n            ans = false;\\n        }\\n        solve(root1->right, root2->left, ans);\\n    }\\n\\npublic:\\n    bool isSymmetric(TreeNode* root) {\\n        bool ans = true;\\n        if (root == NULL) {\\n            return ans;\\n        }\\n        solve(root->left, root->right, ans);\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"symmetric-tree","has_notes":false,"flag_type":1,"frontend_id":190},{"id":1473795719,"question_id":199,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733691458,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1473795719/","is_pending":"Not Pending","title":"Binary Tree Right Side View","memory":"15.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        map<int, int> mapping;\\n        vector<int> ans;\\n\\n        if (root == NULL) {\\n            return ans;\\n        }\\n        queue<pair<TreeNode*, int>> q;\\n        q.push({root, 0});\\n\\n        while (!q.empty()) {\\n            auto front = q.front();\\n            q.pop();\\n\\n            int lvl = front.second;\\n            TreeNode* temp = front.first;\\n\\n            mapping[lvl] = temp->val;\\n\\n            if (temp->left) {\\n                q.push({temp->left, lvl + 1});\\n            }\\n            if (temp->right) {\\n                q.push({temp->right, lvl + 1});\\n            }\\n        }\\n\\n        for(auto i:mapping){\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-right-side-view","has_notes":false,"flag_type":1,"frontend_id":189},{"id":1473355984,"question_id":1029,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733648544,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1473355984/","is_pending":"Not Pending","title":"Vertical Order Traversal of a Binary Tree","memory":"15.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\\n        vector<vector<int>> output;\\n        if (root == NULL) {\\n            return output;\\n        }\\n        map<int, map<int, vector<int>>> map;\\n        queue<pair<TreeNode*, pair<int, int>>> q;\\n\\n        q.push(make_pair(root, make_pair(0,0)));\\n\\n        while (!q.empty()) {\\n\\n            pair<TreeNode*, pair<int, int>> front = q.front();\\n            q.pop();\\n\\n            int hd = front.second.first;\\n            int lvl = front.second.second;\\n            TreeNode* curr = front.first;\\n            map[hd][lvl].push_back(curr->val);\\n\\n            if (curr->left) {\\n                q.push(make_pair(curr->left, make_pair(hd - 1, lvl + 1)));\\n            }\\n            if (curr->right) {\\n                q.push(make_pair(curr->right, make_pair(hd + 1, lvl + 1)));\\n            }\\n        }\\n\\n        for (auto i : map) {\\n                vector<int>ans;\\n                for(auto j: i.second){\\n                    sort(j.second.begin(), j.second.end());\\n                    for(auto k: j.second)\\n                    ans.push_back(k);\\n                }\\n                output.push_back(ans);\\n        }\\n        return output;\\n    }\\n};","compare_result":"1111111111111111111111111111111111","title_slug":"vertical-order-traversal-of-a-binary-tree","has_notes":false,"flag_type":1,"frontend_id":188},{"id":1472907912,"question_id":103,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733599165,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472907912/","is_pending":"Not Pending","title":"Binary Tree Zigzag Level Order Traversal","memory":"15.2 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>output;\\n        if(root == NULL){\\n            return output;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool ltor = true;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int>ans(size);\\n            int index = 0;\\n\\n            for(int i=0 ;i < size; i++){\\n                TreeNode* front = q.front();\\n                q.pop();\\n                \\n                if(ltor){\\n                    index = i;\\n                }else{\\n                    index = size - i - 1;\\n                }\\n                ans[index] = front->val;\\n\\n                if(front->left){\\n                    q.push(front->left);\\n                }\\n                if(front->right){\\n                    q.push(front->right);\\n                }\\n\\n            }\\n            ltor = !ltor;       //Flag Changed\\n\\n                output.push_back(ans);\\n\\n        }\\n        return output;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"binary-tree-zigzag-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":187},{"id":1472899777,"question_id":103,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733598375,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472899777/","is_pending":"Not Pending","title":"Binary Tree Zigzag Level Order Traversal","memory":"15.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>output;\\n        if(root == NULL){\\n            return output;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        bool ltor = true;\\n\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int>ans(size);\\n            int index = 0;\\n\\n            for(int i=0 ;i < size; i++){\\n                TreeNode* front = q.front();\\n                q.pop();\\n                \\n                if(ltor){\\n                    index = i;\\n                }else{\\n                    index = size - i - 1;\\n                }\\n                ans[index] = front->val;\\n\\n                if(front->left){\\n                    q.push(front->left);\\n                }\\n                if(front->right){\\n                    q.push(front->right);\\n                }\\n\\n            }\\n            ltor = !ltor;       //Flag Changed\\n\\n                output.push_back(ans);\\n\\n        }\\n        return output;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"binary-tree-zigzag-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":186},{"id":1472894066,"question_id":100,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733597826,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472894066/","is_pending":"Not Pending","title":"Same Tree","memory":"12.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void checkIdentical(TreeNode* root1, TreeNode* root2 , bool &ans){\\n        if(root1 == NULL && root2 == NULL){\\n            return ;\\n        }\\n        else if(root1==NULL || root2 == NULL){\\n            ans = false;\\n            return;\\n        }\\n        \\n        checkIdentical(root1->left,root2->left, ans);\\n        if(root1->val != root2->val){\\n            ans = false;\\n        }\\n        checkIdentical(root1->right,root2->right, ans);\\n    }\\npublic:\\n    bool isSameTree(TreeNode* p, TreeNode* q) {\\n        bool ans = true;\\n        checkIdentical(p,q,ans);\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111","title_slug":"same-tree","has_notes":false,"flag_type":1,"frontend_id":185},{"id":1472873567,"question_id":124,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733595947,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1472873567/","is_pending":"Not Pending","title":"Binary Tree Maximum Path Sum","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    vector<int> solve(TreeNode* root){\\n        if(root == NULL){\\n            vector<int> ans(3);\\n            ans[0] = 0;\\n            ans[1] = 0;\\n            ans[2] = 0;\\n            return ans;\\n        }\\n        vector<int>left = solve(root->left);\\n        vector<int>right = solve(root->right);\\n\\n        vector<int>output(3);\\n        output[0] = max(left[0],right[0]) + 1;\\n        \\n        int currentDiameter = left[0] + right[0] + 1;\\n        output[1] = max(left[1],max(right[1],currentDiameter));\\n\\n        int currentSum = left[2] +right[2] + root->val;\\n        output[2] = max(left[2],max(right[2],currentSum));\\n\\n        return output;\\n    }\\npublic:\\n    int maxPathSum(TreeNode* root) {\\n        // vector 0->height, 1->diameter, 2->maxPathSum\\n        vector<int>ans(3);\\n        ans = solve(root);\\n        return ans[2];\\n    }\\n};","compare_result":"111101110011110111000011001111111111111101000010111101000100000001000110110010010000000000000010","title_slug":"binary-tree-maximum-path-sum","has_notes":false,"flag_type":1,"frontend_id":184},{"id":1472860313,"question_id":543,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733594894,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472860313/","is_pending":"Not Pending","title":"Diameter of Binary Tree","memory":"23.6 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    pair<int,int> solve(TreeNode* root){\\n        if(root == NULL){\\n            return make_pair(0,0);\\n        }\\n        pair<int,int> left = solve(root->left);\\n        pair<int,int> right = solve(root->right);\\n\\n        pair<int,int>ans;\\n        int currDiameter = left.first + right.first + 1;\\n        ans.first = max(left.first, right.first) + 1;\\n        ans.second = max(left.second, max(right.second, currDiameter));\\n        return ans;\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        return solve(root).second-1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"diameter-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":183},{"id":1472841895,"question_id":110,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733593460,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472841895/","is_pending":"Not Pending","title":"Balanced Binary Tree","memory":"23.1 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    pair<bool,int> solve(TreeNode* root){\\n        if(root == NULL){\\n            return make_pair(true,0);\\n        }\\n        pair<bool,int>left = solve(root->left);\\n        pair<bool,int>right = solve(root->right);\\n        bool diff = abs(left.second - right.second) <= 1;\\n        pair<bool,int>ans;\\n        ans.first = diff && left.first && right.first;\\n        ans.second = max(left.second , right.second) + 1;\\n        return ans;\\n    }\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        pair<bool,int>ans = solve(root);\\n        return ans.first;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"balanced-binary-tree","has_notes":false,"flag_type":1,"frontend_id":182},{"id":1472836387,"question_id":104,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1733593021,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1472836387/","is_pending":"Not Pending","title":"Maximum Depth of Binary Tree","memory":"18.8 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int height(TreeNode* root){\\n        if(root == NULL){\\n            return 0;\\n        }\\n        int l = height(root->left);\\n        int r = height(root->right);\\n        int ans = max(l,r)+1;\\n\\n        return ans;\\n        \\n    }\\npublic:\\n    int maxDepth(TreeNode* root) {\\n        return height(root);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111","title_slug":"maximum-depth-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":181},{"id":1465730823,"question_id":114,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732878977,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1465730823/","is_pending":"Not Pending","title":"Flatten Binary Tree to Linked List","memory":"17.4 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* &root){\\n        TreeNode* curr = root;\\n        while(curr!=NULL){\\n            if(curr->left == NULL){\\n\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* pred = curr->left;\\n                while(pred->right != NULL && pred->right != curr->right){\\n                    pred = pred->right;\\n                }\\n                if(pred->right == NULL){\\n                    pred->right = curr->right;\\n                    curr->right = curr->left;\\n                }\\n\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }\\n        }\\n    }\\npublic:\\n    void flatten(TreeNode* root) {\\n        solve(root);\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flatten-binary-tree-to-linked-list","has_notes":null,"flag_type":1,"frontend_id":180},{"id":1465730255,"question_id":114,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732878903,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1465730255/","is_pending":"Not Pending","title":"Flatten Binary Tree to Linked List","memory":"17.7 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr!=NULL){\\n            if(curr->left == NULL){\\n\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* pred = curr->left;\\n                while(pred->right != NULL && pred->right != curr->right){\\n                    pred = pred->right;\\n                }\\n                if(pred->right == NULL){\\n                    pred->right = curr->right;\\n                    curr->right = curr->left;\\n                }\\n\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flatten-binary-tree-to-linked-list","has_notes":false,"flag_type":1,"frontend_id":179},{"id":1465730124,"question_id":114,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732878887,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1465730124/","is_pending":"Not Pending","title":"Flatten Binary Tree to Linked List","memory":"17.4 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr!=NULL){\\n            if(curr->left == NULL){\\n                cout<<curr->val<<\\" \\";\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* pred = curr->left;\\n                while(pred->right != NULL && pred->right != curr->right){\\n                    pred = pred->right;\\n                }\\n                if(pred->right == NULL){\\n                    pred->right = curr->right;\\n                    curr->right = curr->left;\\n                }\\n                cout<<curr->val<<\\" \\";\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"flatten-binary-tree-to-linked-list","has_notes":false,"flag_type":1,"frontend_id":178},{"id":1464899292,"question_id":102,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732786010,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1464899292/","is_pending":"Not Pending","title":"Binary Tree Level Order Traversal","memory":"17.3 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> levelOrder(TreeNode* root) {\\n        vector<vector<int>>output;\\n        \\n        if(root == NULL){\\n            return output;\\n        }\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<int>ans;\\n            for(int i=0; i<size; i++){\\n                TreeNode* front = q.front();\\n                q.pop();\\n                ans.push_back(front->val);\\n\\n                if(front->left){\\n                    q.push(front->left);\\n                }\\n                if(front->right){\\n                    q.push(front->right);\\n                }\\n\\n            }\\n            output.push_back(ans);\\n        }\\n        return output;\\n    }\\n};","compare_result":"11111111111111111111111111111111111","title_slug":"binary-tree-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":177},{"id":1464878350,"question_id":893,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732783925,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1464878350/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"15.5 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* getParentTarget(TreeNode* root, int target,\\n                              unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        nodeParent[root] = NULL;\\n\\n        TreeNode* targetNode = NULL;\\n\\n        while (!q.empty()) {\\n            TreeNode* front = q.front();\\n            q.pop();\\n\\n            if (front->left) {\\n                nodeParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if (front->right) {\\n                nodeParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n            if (front->val == target) {\\n                 targetNode = front;\\n            }\\n        }\\n        return targetNode;\\n    }\\n\\n    void solve(TreeNode* targetNode,\\n               unordered_map<TreeNode*, TreeNode*>& nodeParent, int k,\\n               vector<int>& ans) {\\n        if (targetNode == NULL) {\\n            return;\\n        }\\n        if(k==0){\\n            ans.push_back(targetNode->val);return;\\n        }\\n        queue<TreeNode*> q;\\n        unordered_map<TreeNode*, bool> visited;\\n\\n        q.push(targetNode);\\n        visited[targetNode] = true;\\n        int flag = 0;\\n\\n        int cnt = 1;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* front = q.front();\\n                q.pop();\\n\\n                if (front->left && !visited[front->left]) {\\n                    q.push(front->left);\\n                    visited[front->left] = true;\\n                    if (cnt == k) {\\n                        ans.push_back(front->left->val);\\n                    }\\n                }\\n                if (front->right && !visited[front->right]) {\\n                    q.push(front->right);\\n                    visited[front->right] = true;\\n                    if (cnt == k) {\\n                        ans.push_back(front->right->val);\\n                    }\\n                }\\n                if (nodeParent[front] && !visited[nodeParent[front]]) {\\n                    q.push(nodeParent[front]);\\n                    visited[nodeParent[front]] = true;\\n                    if (cnt == k) {\\n                        TreeNode* temp = nodeParent[front];\\n                        ans.push_back(nodeParent[front]->val);\\n                    }\\n                }\\n            }\\n            cnt++;\\n            }\\n        \\n    }\\n\\npublic:\\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\\n        unordered_map<TreeNode*, TreeNode*> nodeParent;\\n        TreeNode* targetNode = getParentTarget(root, target->val, nodeParent);\\n        vector<int> ans;\\n        solve(targetNode, nodeParent, k, ans);\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":176},{"id":1464874487,"question_id":893,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732783537,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1464874487/","is_pending":"Not Pending","title":"All Nodes Distance K in Binary Tree","memory":"N/A","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* getParentTarget(TreeNode* root, int target,\\n                              unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        nodeParent[root] = NULL;\\n\\n        TreeNode* targetNode = NULL;\\n\\n        while (!q.empty()) {\\n            TreeNode* front = q.front();\\n            q.pop();\\n\\n            if (front->left) {\\n                nodeParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if (front->right) {\\n                nodeParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n            if (front->val == target) {\\n                 targetNode = front;\\n            }\\n        }\\n        return targetNode;\\n    }\\n\\n    void solve(TreeNode* targetNode,\\n               unordered_map<TreeNode*, TreeNode*>& nodeParent, int k,\\n               vector<int>& ans) {\\n        if (targetNode == NULL) {\\n            return;\\n        }\\n        queue<TreeNode*> q;\\n        unordered_map<TreeNode*, bool> visited;\\n\\n        q.push(targetNode);\\n        visited[targetNode] = true;\\n        int flag = 0;\\n\\n        int cnt = 1;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                TreeNode* front = q.front();\\n                q.pop();\\n\\n                if (front->left && !visited[front->left]) {\\n                    q.push(front->left);\\n                    visited[front->left] = true;\\n                    flag = 1;\\n                    if (cnt == k) {\\n                        ans.push_back(front->left->val);\\n                    }\\n                }\\n                if (front->right && !visited[front->right]) {\\n                    q.push(front->right);\\n                    visited[front->right] = true;\\n                    flag = 1;\\n                    if (cnt == k) {\\n                        ans.push_back(front->right->val);\\n                    }\\n                }\\n                if (nodeParent[front] && !visited[nodeParent[front]]) {\\n                    q.push(nodeParent[front]);\\n                    visited[nodeParent[front]] = true;\\n                    flag = 1;\\n                    if (cnt == k) {\\n                        TreeNode* temp = nodeParent[front];\\n                        ans.push_back(nodeParent[front]->val);\\n                    }\\n                }\\n            }\\n            if(cnt==k){\\n                return;\\n            }\\n            if (flag) {\\n                cnt++;\\n            }\\n        }\\n    }\\n\\npublic:\\n    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {\\n        unordered_map<TreeNode*, TreeNode*> nodeParent;\\n        TreeNode* targetNode = getParentTarget(root, target->val, nodeParent);\\n        vector<int> ans;\\n        solve(targetNode, nodeParent, k, ans);\\n        return ans;\\n    }\\n};","compare_result":"111111101110101101111001111101011111111111111111111111111","title_slug":"all-nodes-distance-k-in-binary-tree","has_notes":false,"flag_type":1,"frontend_id":175},{"id":1464859249,"question_id":2461,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732781860,"status":10,"status_display":"Accepted","runtime":"151 ms","url":"/submissions/detail/1464859249/","is_pending":"Not Pending","title":"Amount of Time for Binary Tree to Be Infected","memory":"195.1 MB","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* getTargetParent(TreeNode* root, int start,\\n                              unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* res = NULL;\\n\\n        nodeParent[root] = NULL;\\n\\n        while (!q.empty()) {\\n            TreeNode* front = q.front();\\n            q.pop();\\n\\n            if (front->val == start) {\\n                res = front;\\n            }\\n\\n            if (front->left) {\\n                nodeParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if (front->right) {\\n                nodeParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int infectTree(TreeNode* root,\\n                   unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        int time = 0;\\n        unordered_map<TreeNode*, bool> visited;\\n        visited[root] = true;\\n\\n        queue<TreeNode*> q;\\n        q.push(root);\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n            bool flag = 0;\\n\\n            for(int i=0; i<size; i++){\\n            TreeNode* front = q.front();\\n            q.pop();\\n            if (front->left && !visited[front->left]) {\\n                q.push(front->left);\\n                visited[front->left] = true;\\n                flag = 1;\\n            }\\n            if (front->right && !visited[front->right]) {\\n                q.push(front->right);\\n                visited[front->right] = true;\\n                flag = 1;\\n            }\\n            if (nodeParent[front] && !visited[nodeParent[front]]) {\\n                flag = 1;\\n                q.push(nodeParent[front]);\\n                visited[nodeParent[front]] = true;\\n            }\\n        }\\n            if (flag) {\\n                time++;\\n            }\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> nodeParent;\\n        TreeNode* targetNode = getTargetParent(root, start, nodeParent);\\n\\n        return infectTree(targetNode, nodeParent);\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"amount-of-time-for-binary-tree-to-be-infected","has_notes":false,"flag_type":1,"frontend_id":174},{"id":1464850163,"question_id":2461,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732780825,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1464850163/","is_pending":"Not Pending","title":"Amount of Time for Binary Tree to Be Infected","memory":"N/A","code":"/**\\n * Definition for a binary tree TreeNode.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* getTargetParent(TreeNode* root, int start,\\n                              unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* res = NULL;\\n\\n        nodeParent[root] = NULL;\\n\\n        while (!q.empty()) {\\n            TreeNode* front = q.front();\\n            q.pop();\\n\\n            if (front->val == start) {\\n                res = front;\\n            }\\n\\n            if (front->left) {\\n                nodeParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if (front->right) {\\n                nodeParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    int infectTree(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& nodeParent) {\\n        if (root == NULL) {\\n            return 0;\\n        }\\n        int time = 0;\\n        unordered_map<TreeNode*,bool>visited;\\n        visited[root]=true;\\n\\n        queue<TreeNode*>q;\\n        q.push(root);\\n\\n\\n        while(!q.empty()){\\n            TreeNode* front = q.front();\\n            int size = q.size();\\n            q.pop();\\n            bool flag = 0;\\n\\n            for(int i=0; i<size; i++){\\n                if(front->left && !visited[front->left]){\\n                    q.push(front->left);\\n                    visited[front->left]=true;\\n                    flag = 1;\\n                }\\n                if(front->right && !visited[front->right]){\\n                    q.push(front->right);\\n                    visited[front->right]=true;\\n                    flag = 1;\\n                }\\n                if(nodeParent[front] && !visited[nodeParent[front]]){\\n                    flag = 1;\\n                    q.push(nodeParent[front]);\\n                    visited[nodeParent[front]]=true;\\n                }\\n            }\\n            if(flag){\\n                time++;\\n            }\\n        }\\n\\n        return time;\\n    }\\n\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> nodeParent;\\n        TreeNode* targetNode = getTargetParent(root ,start , nodeParent);\\n\\n        return infectTree(targetNode, nodeParent);\\n    }\\n};","compare_result":"11110111101111111111111111011111111111111000111111111001010001010111000000000000","title_slug":"amount-of-time-for-binary-tree-to-be-infected","has_notes":false,"flag_type":1,"frontend_id":173},{"id":1464728281,"question_id":106,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732768670,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1464728281/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"27.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* solve(vector<int> &postorder,vector<int>&inorder, int &postIndex,\\n    int inorderStart,int inorderEnd, unordered_map<int,int>&findIndex) {\\n        if (postIndex == -1 || inorderStart > inorderEnd) {\\n            return NULL;\\n        }\\n        int element = postorder[postIndex--];\\n        TreeNode* root = new TreeNode(element);\\n        int pos = findIndex[element];\\n\\n        root->right = solve(postorder,inorder,postIndex,pos+1,inorderEnd,findIndex);\\n        root->left = solve(postorder,inorder,postIndex,inorderStart,pos-1,findIndex);\\n        return root;\\n    }\\n\\npublic:\\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\\n        int size = inorder.size();\\n        unordered_map<int, int> findIndex;\\n        for (int i = 0; i < size; i++) {\\n            findIndex[inorder[i]] = i;\\n        }\\n        int postIndex = size - 1;\\n        TreeNode* ans = solve(postorder,inorder,postIndex,0,size-1,findIndex);\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal","has_notes":false,"flag_type":1,"frontend_id":172},{"id":1464314460,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732721929,"status":10,"status_display":"Accepted","runtime":"103 ms","url":"/submissions/detail/1464314460/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"270.6 MB","code":"\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int find(vector<int> inorder,int s,int e,int element, int n){\\n        for(int i=s; i<=e; i++){\\n            if(inorder[i]==element){\\n                return i;\\n            }\\n        }\\n            return -1;\\n    }\\n    TreeNode* solve(vector<int> preorder, vector<int> inorder,\\n                    int& indexPreorder, int inorderStart,int    inorderEnd, int size) \\n{\\n    if (indexPreorder == size || inorderEnd < inorderStart) {\\n            return NULL;\\n    }\\n\\n    int element = preorder[indexPreorder++];\\n    TreeNode* root = new TreeNode(element);\\n    int pos = find(inorder,inorderStart,inorderEnd,element,size);\\n\\n    root->left = solve(preorder, inorder, indexPreorder, inorderStart, pos - 1, size);\\n        root->right = solve(preorder, inorder, indexPreorder, pos+1, inorderEnd,  size);\\n        return root;\\n}\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n\\n        int n = inorder.size();\\n        \\n        int index = 0;\\n        TreeNode* ans = solve(preorder, inorder, index, 0, n - 1 ,n);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1,"frontend_id":171}],"has_next":true,"last_key":""}'
2026-01-10 09:26:59,942 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:26:59,944 [INFO] __main__.py:245 - Writing symmetric-tree/2024-12-09 02.46.59 - Accepted - runtime 0ms - memory 18.3MB.cpp
2026-01-10 09:26:59,945 [INFO] __main__.py:245 - Writing binary-tree-right-side-view/2024-12-09 02.27.38 - Accepted - runtime 0ms - memory 15.5MB.cpp
2026-01-10 09:27:00,253 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:00,255 [INFO] __main__.py:245 - Writing vertical-order-traversal-of-a-binary-tree/2024-12-08 14.32.24 - Accepted - runtime 0ms - memory 15.8MB.cpp
2026-01-10 09:27:01,765 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:01,768 [INFO] __main__.py:245 - Writing binary-tree-zigzag-level-order-traversal/2024-12-08 00.49.25 - Accepted - runtime 0ms - memory 15.2MB.cpp
2026-01-10 09:27:01,769 [INFO] __main__.py:245 - Writing binary-tree-zigzag-level-order-traversal/2024-12-08 00.36.15 - Accepted - runtime 0ms - memory 15.3MB.cpp
2026-01-10 09:27:01,769 [INFO] __main__.py:245 - Writing same-tree/2024-12-08 00.27.06 - Accepted - runtime 0ms - memory 12.8MB.cpp
2026-01-10 09:27:01,770 [INFO] __main__.py:188 - Skipping binary-tree-maximum-path-sum 2024-12-07 23.55.47 because its status is 'Wrong Answer'
2026-01-10 09:27:01,770 [INFO] __main__.py:245 - Writing diameter-of-binary-tree/2024-12-07 23.38.14 - Accepted - runtime 0ms - memory 23.6MB.cpp
2026-01-10 09:27:01,771 [INFO] __main__.py:245 - Writing balanced-binary-tree/2024-12-07 23.14.20 - Accepted - runtime 0ms - memory 23.1MB.cpp
2026-01-10 09:27:01,772 [INFO] __main__.py:245 - Writing maximum-depth-of-binary-tree/2024-12-07 23.07.01 - Accepted - runtime 0ms - memory 18.8MB.cpp
2026-01-10 09:27:02,083 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:02,086 [INFO] __main__.py:245 - Writing flatten-binary-tree-to-linked-list/2024-11-29 16.46.17 - Accepted - runtime 0ms - memory 17.4MB.cpp
2026-01-10 09:27:02,087 [INFO] __main__.py:245 - Writing flatten-binary-tree-to-linked-list/2024-11-29 16.45.03 - Accepted - runtime 0ms - memory 17.7MB.cpp
2026-01-10 09:27:02,088 [INFO] __main__.py:245 - Writing flatten-binary-tree-to-linked-list/2024-11-29 16.44.47 - Accepted - runtime 2ms - memory 17.4MB.cpp
2026-01-10 09:27:02,089 [INFO] __main__.py:245 - Writing binary-tree-level-order-traversal/2024-11-28 14.56.50 - Accepted - runtime 0ms - memory 17.3MB.cpp
2026-01-10 09:27:03,067 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:03,069 [INFO] __main__.py:245 - Writing all-nodes-distance-k-in-binary-tree/2024-11-28 14.22.05 - Accepted - runtime 0ms - memory 15.5MB.cpp
2026-01-10 09:27:03,070 [INFO] __main__.py:188 - Skipping all-nodes-distance-k-in-binary-tree 2024-11-28 14.15.37 because its status is 'Wrong Answer'
2026-01-10 09:27:03,386 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:03,390 [INFO] __main__.py:245 - Writing amount-of-time-for-binary-tree-to-be-infected/2024-11-28 13.47.40 - Accepted - runtime 151ms - memory 195.1MB.cpp
2026-01-10 09:27:03,390 [INFO] __main__.py:188 - Skipping amount-of-time-for-binary-tree-to-be-infected 2024-11-28 13.30.25 because its status is 'Wrong Answer'
2026-01-10 09:27:03,768 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:03,771 [INFO] __main__.py:245 - Writing construct-binary-tree-from-inorder-and-postorder-traversal/2024-11-28 10.07.50 - Accepted - runtime 0ms - memory 27.5MB.cpp
2026-01-10 09:27:03,772 [INFO] __main__.py:245 - Writing construct-binary-tree-from-preorder-and-inorder-traversal/2024-11-27 21.08.49 - Accepted - runtime 103ms - memory 270.6MB.cpp
2026-01-10 09:27:08,776 [DEBUG] leetcode.py:150 - Exporting submissions from 380 to 400
2026-01-10 09:27:10,843 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=380&limit=20 HTTP/1.1" 200 None
2026-01-10 09:27:10,845 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1464310908,"question_id":105,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732721634,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1464310908/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"N/A","code":"\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\\n * right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* solve(vector<int> preorder, vector<int> inorder,\\n                    int& indexPreorder, int inorderStart,int    inorderEnd, unordered_map<int, int> findIndex, int size) \\n{\\n    if (indexPreorder == size || inorderEnd < inorderStart) {\\n            return NULL;\\n    }\\n\\n    int element = preorder[indexPreorder++];\\n    TreeNode* root = new TreeNode(element);\\n    int pos = findIndex[element];\\n\\n    root->left = solve(preorder, inorder, indexPreorder, inorderStart, pos - 1, findIndex, size);\\n        root->right = solve(preorder, inorder, indexPreorder, pos+1, inorderEnd, findIndex, size);\\n        return root;\\n}\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        unordered_map<int, int> findIndex;\\n        int n = inorder.size();\\n        for (int i = 0; i < n; i++) {\\n            findIndex[inorder[i]] = i;\\n        }\\n        int index = 0;\\n        TreeNode* ans = solve(preorder, inorder, index, 0, n - 1, findIndex,n);\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal","has_notes":false,"flag_type":1,"frontend_id":170},{"id":1462194614,"question_id":437,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732513217,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1462194614/","is_pending":"Not Pending","title":"Path Sum III","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int& count, int targetSum, vector<long long>path){\\n        if(root == NULL){\\n            return;\\n        }\\n        path.push_back(root->val);\\n\\n        solve(root->left, count, targetSum, path);\\n        solve(root->right, count, targetSum, path);\\n\\n        int size = path.size();\\n        long long sum = 0;\\n\\n        for(int i=size-1; i>=0; i--){\\n            sum+=path[i];\\n            if(sum==targetSum){\\n                count++;\\n                break;\\n            }\\n        }\\n\\n        path.pop_back();\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        int count = 0;\\n        vector<long long>path;\\n\\n        solve(root,count,targetSum,path);\\n        return count;\\n    }\\n};","compare_result":"111111111111111111101011111111011111111111111011111111111111111111101111111111111111111111111111111111111111111111100010001111111","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":169},{"id":1462187916,"question_id":437,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732512569,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1462187916/","is_pending":"Not Pending","title":"Path Sum III","memory":"N/A","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    void solve(TreeNode* root, int& count, int targetSum, vector<int>path){\\n        if(root == NULL){\\n            return;\\n        }\\n        path.push_back(root->val);\\n\\n        solve(root->left, count, targetSum, path);\\n        solve(root->right, count, targetSum, path);\\n\\n        int size = path.size();\\n        int sum = 0;\\n\\n        for(int i=size-1; i>=0; i--){\\n            sum+=path[i];\\n            if(sum==targetSum){\\n                count++;\\n            }\\n        }\\n\\n        path.pop_back();\\n    }\\npublic:\\n    int pathSum(TreeNode* root, int targetSum) {\\n        int count = 0;\\n        vector<int>path;\\n\\n        solve(root,count,targetSum,path);\\n        return count;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000","title_slug":"path-sum-iii","has_notes":false,"flag_type":1,"frontend_id":168},{"id":1462138692,"question_id":236,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732507588,"status":10,"status_display":"Accepted","runtime":"13 ms","url":"/submissions/detail/1462138692/","is_pending":"Not Pending","title":"Lowest Common Ancestor of a Binary Tree","memory":"16.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\\n        if (root == NULL) {\\n            return NULL;\\n        }\\n        if (root->val == p->val || root->val == q->val) {\\n            return root;\\n        }\\n\\n        TreeNode* leftAns = lowestCommonAncestor(root->left, p, q);\\n        TreeNode* rightAns = lowestCommonAncestor(root->right, p, q);\\n\\n        if (leftAns != NULL && rightAns != NULL) {\\n            return root;\\n        } else if (leftAns == NULL && rightAns != NULL) {\\n            return rightAns;\\n        } else if (leftAns != NULL && rightAns == NULL) {\\n            return leftAns;\\n        } else {\\n            return NULL;\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-a-binary-tree","has_notes":false,"flag_type":1,"frontend_id":167},{"id":1460638623,"question_id":199,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732354318,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1460638623/","is_pending":"Not Pending","title":"Binary Tree Right Side View","memory":"15 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> rightSideView(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL){\\n            return ans;\\n        }\\n\\n        map<int,int>map;\\n        queue<pair<TreeNode*,int>>q;\\n\\n        q.push(make_pair(root,0));\\n\\n        while(!q.empty()){\\n            pair<TreeNode*,int> temp = q.front();\\n            q.pop();\\n\\n            TreeNode* frontNode = temp.first;\\n            int lvl = temp.second;\\n\\n            map[lvl]=frontNode->val;\\n\\n            if(frontNode->left){\\n                q.push(make_pair(frontNode->left,lvl+1));\\n            }\\n            if(frontNode->right){\\n                q.push(make_pair(frontNode->right,lvl+1));\\n            }\\n        }\\n        for(auto i:map){\\n            ans.push_back(i.second);\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-tree-right-side-view","has_notes":false,"flag_type":1,"frontend_id":166},{"id":1460612712,"question_id":1972,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1732351187,"status":10,"status_display":"Accepted","runtime":"198 ms","url":"/submissions/detail/1460612712/","is_pending":"Not Pending","title":"Rotating the Box","memory":"56.2 MB","code":"class Solution {\\npublic:\\n    vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {\\n        int m = box.size();\\n        int n = box[0].size();\\n\\n        vector<vector<char>> res(n, vector<char>(m));\\n        // Trasposing the matrix\\n        for (int i = 0; i < n; i++) {\\n            for (int j = m - 1; j >= 0; j--) {\\n                res[i][m - 1 - j] = box[j][i];\\n            }\\n        }\\n        // Applying the gravity\\n        for (int i = 0; i < m; i++) {\\n            int start = n - 1;\\n            for (int j = start; j >= 0; j--) {\\n                if (res[j][i] == \'*\') {\\n                    start = j - 1;\\n                } else if (res[j][i] == \'#\') {\\n                    res[j][i] = \'.\';\\n                    res[start][i] = \'#\';\\n                    start--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"rotating-the-box","has_notes":false,"flag_type":1,"frontend_id":165},{"id":1454828348,"question_id":103,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1731811832,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1454828348/","is_pending":"Not Pending","title":"Binary Tree Zigzag Level Order Traversal","memory":"13.3 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\\n        vector<vector<int>>finalans;\\n        queue<TreeNode* > q;\\n        if(root==NULL){\\n            return finalans;\\n        }\\n        q.push(root);\\n        bool leftToRight = true;\\n\\n        while(!q.empty()){\\n            int size=q.size();\\n            int index=0;\\n            vector<int>ans(size);\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode* temp=q.front();\\n                q.pop();\\n\\n                if(leftToRight){\\n                    index = i;\\n                }else{\\n                    index = size-i-1;\\n                }\\n                ans[index]=temp->val;\\n                if(temp->left){\\n                    q.push(temp->left);\\n                }\\n                if(temp->right){\\n                    q.push(temp->right);\\n                }\\n            }\\n            leftToRight=!leftToRight;\\n            finalans.push_back(ans);\\n        }\\n        return finalans;\\n    }\\n};","compare_result":"111111111111111111111111111111111","title_slug":"binary-tree-zigzag-level-order-traversal","has_notes":false,"flag_type":1,"frontend_id":164},{"id":1452728135,"question_id":543,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 1\xc2\xa0month","timestamp":1731600564,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1452728135/","is_pending":"Not Pending","title":"Diameter of Binary Tree","memory":"22.5 MB","code":"/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    pair<int,int> diameter(TreeNode* root){\\n        if(root==NULL){\\n            pair<int,int>p=make_pair(0,0);\\n            return p;\\n        }\\n        pair<int,int>left=diameter(root->left);\\n        pair<int,int>right=diameter(root->right);\\n\\n        int height=left.second+right.second+1;\\n\\n        pair<int,int>ans;\\n        ans.first=max(left.first,max(right.first,height));\\n        ans.second=max(left.second,right.second)+1;\\n        return ans;\\n    }\\npublic:\\n    int diameterOfBinaryTree(TreeNode* root) {\\n        pair<int,int>ans=diameter(root);\\n        return ans.first-1;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"diameter-of-binary-tree","has_notes":false,"flag_type":1,"frontend_id":163},{"id":1435059478,"question_id":84,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1730018153,"status":10,"status_display":"Accepted","runtime":"65 ms","url":"/submissions/detail/1435059478/","is_pending":"Not Pending","title":"Largest Rectangle in Histogram","memory":"90.4 MB","code":"class Solution {\\n    private:\\n    vector<int> nextSmaller(vector<int>&arr, int n){\\n        stack<int>stack;\\n        vector<int>ans(n);\\n        stack.push(-1);\\n\\n        for(int i=n-1; i>=0; i--){\\n            while(stack.top()!=-1 && arr[stack.top()]>=arr[i]){\\n                stack.pop();\\n            }\\n            ans[i]=stack.top();\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\n    vector<int> prevSmaller(vector<int>&arr, int n){\\n        stack<int>stack;\\n        vector<int>ans(n);\\n        stack.push(-1);\\n\\n        for(int i=0; i<n; i++){\\n            while(stack.top()!=-1 && arr[stack.top()]>=arr[i]){\\n                stack.pop();\\n            }\\n            ans[i]=stack.top();\\n            stack.push(i);\\n        }\\n        return ans;\\n    }\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        int n = heights.size();\\n        vector<int> prev(n);\\n        prev = prevSmaller(heights, n);\\n        vector<int> next(n);\\n        next = nextSmaller(heights, n);\\n\\n        int area = INT_MIN;\\n        for (int i = 0; i < n; i++) {\\n            int length = heights[i];\\n            if (next[i] == -1) {\\n                next[i] = n;\\n            }\\n            int breadth = next[i] - prev[i] - 1;\\n            area = max(area, (length * breadth));\\n        }\\n        return area;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"largest-rectangle-in-histogram","has_notes":false,"flag_type":1,"frontend_id":162},{"id":1434887616,"question_id":84,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1730002024,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1434887616/","is_pending":"Not Pending","title":"Largest Rectangle in Histogram","memory":"N/A","code":"class Solution {\\npublic:\\n    int largestRectangleArea(vector<int>& heights) {\\n        stack<int> lstack;\\n        stack<int> rstack;\\n        int n = heights.size();\\n        lstack.push(-1);\\n        rstack.push(-1);\\n        int area = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            int l = i;\\n            while (lstack.top() >= heights[i]) {\\n                lstack.pop();\\n                l--;\\n            }\\n            l--;\\n            lstack.push(heights[i]);\\n\\n            int r = i;\\n            while (rstack.top() >= heights[i]) {\\n                rstack.pop();\\n                r++;\\n            }\\n            r++;\\n            rstack.push(heights[i]);\\n            area = max((heights[i] * (r - l - 1)), area);\\n        }\\n        return area;\\n    }\\n};","compare_result":"111111001101111011000101110010001001000011110000000000000110000010010000001000000000000000000000001","title_slug":"largest-rectangle-in-histogram","has_notes":false,"flag_type":1,"frontend_id":161},{"id":1431379332,"question_id":234,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729684137,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1431379332/","is_pending":"Not Pending","title":"Palindrome Linked List","memory":"116.8 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void rev(ListNode *&head)\\n{\\n    ListNode *curr = head;\\n    ListNode *prev = NULL;\\n    ListNode *fwd = NULL;\\n    if (head == NULL || head->next == NULL)\\n    {\\n        return;\\n    }\\n    while (curr != NULL)\\n    {\\n        fwd = curr->next;\\n        curr->next = prev;\\n        prev = curr;\\n        curr = fwd;\\n    }\\n    head = prev;\\n}\\n\\nListNode *mid(ListNode *&head)\\n{\\n    ListNode *fast = head;\\n    ListNode *slow = head;\\n\\n    while (fast != NULL && fast->next != NULL)\\n    {\\n        fast = fast->next->next;\\n        slow = slow->next;\\n    }\\n    if (fast != NULL)\\n        slow = slow->next;\\n\\n    return slow;\\n}\\n\\nbool isPalindrome(ListNode *&head)\\n{\\n    if (head == NULL || head->next == NULL)\\n        return 1;\\n    int len = 0;\\n    ListNode *temp = head;\\n    ListNode *middle = mid(head);\\n    rev(middle);\\n    cout << endl;\\n    ListNode *f = head;\\n    ListNode *s = middle;\\n    while (s != NULL)\\n    {\\n        if (s->val == f->val)\\n        {\\n            s = s->next;\\n            f = f->next;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    return 1;\\n}\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-linked-list","has_notes":false,"flag_type":1,"frontend_id":160},{"id":1431366807,"question_id":206,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729682826,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1431366807/","is_pending":"Not Pending","title":"Reverse Linked List","memory":"12.9 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseList(ListNode* head) {\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* forward=NULL;\\n        if(head==NULL||head->next==NULL){\\n            return head;\\n        }\\n        while(curr!=NULL){\\n            forward=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=forward;\\n        }\\n        return prev;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"reverse-linked-list","has_notes":false,"flag_type":1,"frontend_id":159},{"id":1431364563,"question_id":234,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729682600,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1431364563/","is_pending":"Not Pending","title":"Palindrome Linked List","memory":"125.1 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isPalindrome(ListNode* head) {\\n        ListNode *temp = head;\\n    int cnt = 0;\\n    while (temp != NULL)\\n    {\\n        temp = temp->next;\\n        cnt++;\\n    }\\n    int *arr = new int[cnt];\\n    temp = head;\\n    int k = 0;\\n    while (temp != NULL)\\n    {\\n        arr[k++] = temp->val;\\n        temp = temp->next;\\n    }\\n    int i = 0, j = cnt - 1;\\n    while (i < j)\\n    {\\n        if (arr[i] != arr[j])\\n        {\\n            delete[] arr;\\n            return 0;\\n        }\\n        else\\n        {\\n            i++;\\n            j--;\\n        }\\n    }\\n    delete[] arr;\\n    return 1;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-linked-list","has_notes":false,"flag_type":1,"frontend_id":158},{"id":1430442454,"question_id":142,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729605325,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1430442454/","is_pending":"Not Pending","title":"Linked List Cycle II","memory":"10.4 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode *detectCycle(ListNode *head) {\\n        ListNode* fast=head;\\n        ListNode* slow=head;\\n        while(fast!=NULL && fast->next!=NULL && slow!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(slow==fast){\\n                slow=head;\\n                while(fast!=slow){\\n                    slow=slow->next;\\n                    fast=fast->next;\\n                }\\n                return slow;\\n            }\\n        }\\n        return NULL;\\n    }\\n};","compare_result":"111111111111111111","title_slug":"linked-list-cycle-ii","has_notes":false,"flag_type":1,"frontend_id":157},{"id":1430411381,"question_id":141,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729603221,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1430411381/","is_pending":"Not Pending","title":"Linked List Cycle","memory":"10.8 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *fast=head;\\n        ListNode *slow=head;\\n        while(fast!=NULL && slow!=NULL && fast->next!=NULL){\\n            fast=fast->next->next;\\n            slow=slow->next;\\n            if(fast==slow){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n};","compare_result":"11111111111111111111111111111","title_slug":"linked-list-cycle","has_notes":false,"flag_type":1,"frontend_id":156},{"id":1429696939,"question_id":25,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729539582,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1429696939/","is_pending":"Not Pending","title":"Reverse Nodes in k-Group","memory":"16.4 MB","code":"/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* reverseKGroup(ListNode* head, int k) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        int size=0;\\n        ListNode* temp=head;\\n        while(temp!=NULL){\\n            temp=temp->next;\\n            size++;\\n        }\\n        if(size<k){\\n            return head;\\n        }\\n\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwd=NULL;\\n        int cnt=0;\\n\\n        while(curr!=NULL && cnt<k){\\n            fwd=curr->next;\\n            curr->next=prev;\\n            prev=curr;\\n            curr=fwd;\\n            cnt++;\\n        }\\n\\n        if(curr!=NULL){\\n            head->next=reverseKGroup(curr,k);\\n        }\\n        return prev;\\n        \\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-nodes-in-k-group","has_notes":false,"flag_type":1,"frontend_id":155},{"id":1425066909,"question_id":670,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729146057,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1425066909/","is_pending":"Not Pending","title":"Maximum Swap","memory":"N/A","code":"class Solution {\\npublic:\\n    int maximumSwap(int num) {\\n        int maxi=-1;\\n        int n=num;\\n        int c=0;\\n        vector<int>ans;\\n        while(n!=0){\\n            maxi=max(maxi,n%10);\\n            ans.push_back(n%10);\\n            n/=10;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size(); i++){\\n            if(ans[i]==maxi){\\n                swap(ans[0],ans[i]);\\n            }\\n        }\\n      \\n        int a=0,fans=0,size=0;\\n        while(a!=ans.size()){\\n            fans=fans*10+ans[a];\\n            a++;\\n        }\\n        num=fans;\\n        return num;\\n    }\\n};","compare_result":"1111111111111111111111011110111111110011011111011111111111010100001110011110000110100001000110001100110101111100","title_slug":"maximum-swap","has_notes":false,"flag_type":1,"frontend_id":154},{"id":1425017924,"question_id":46,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729142724,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1425017924/","is_pending":"Not Pending","title":"Permutations","memory":"10.3 MB","code":"class Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<vector<int>>& ans, int index) {\\n        if (index >= nums.size()) {\\n            ans.push_back(nums);\\n            return;\\n        }\\n\\n        for (int i = index; i < nums.size(); i++) {\\n            swap(nums[index], nums[i]);\\n            solve(nums, ans, index + 1);\\n            swap(nums[index], nums[i]);\\n        }\\n    }\\n\\npublic:\\n    vector<vector<int>> permute(vector<int>& nums) {\\n        \\n    vector<vector<int>> ans;\\n    int index = 0;\\n    solve(nums, ans, index);\\n    return ans;\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"permutations","has_notes":false,"flag_type":1,"frontend_id":153},{"id":1423439149,"question_id":17,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1729013132,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1423439149/","is_pending":"Not Pending","title":"Letter Combinations of a Phone Number","memory":"8.6 MB","code":"class Solution {\\nprivate:\\n    void keypad(vector<string>& ans, string output, string mapping[], int index,\\n                string ques) {\\n        if (index >= ques.size()) {\\n            if (output.size() > 0) {\\n                ans.push_back(output);\\n            }\\n            return;\\n        }\\n        int num = ques[index] - \'0\';\\n        string alphabets = mapping[num];\\n        for (int i = 0; i < alphabets.size(); i++) {\\n            output.push_back(alphabets[i]);\\n            keypad(ans, output, mapping, index + 1, ques);\\n            output.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<string> letterCombinations(string digits) {\\n        if (digits.size() == 0)\\n            cout << \\"\\";\\n        string mapping[10] = {\\"\\", \\"\\", \\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\", \\"mno\\", \\"pqrs\\", \\"tuv\\", \\"wxyz\\"};\\n\\n        vector<string> ans;\\n        string output = \\"\\";\\n        int index = 0;\\n        keypad(ans, output, mapping, index, digits);\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111","title_slug":"letter-combinations-of-a-phone-number","has_notes":false,"flag_type":1,"frontend_id":152},{"id":1423178094,"question_id":78,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 2\xc2\xa0months","timestamp":1728998169,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1423178094/","is_pending":"Not Pending","title":"Subsets","memory":"15.4 MB","code":"class Solution {\\nprivate:\\n    void solve( vector<int>  nums, vector<vector<int>>& ans,\\n               vector<int> output, int index) {\\n\\n        // base case\\n        if (index >= nums.size()) {\\n            ans.push_back(output);\\n            return;\\n        }\\n        // exclude\\n        solve(nums, ans, output, index + 1);\\n\\n        // include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, ans, output, index + 1);\\n    }\\n\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, ans, output, index);\\n        return ans;\\n    }\\n};","compare_result":"1111111111","title_slug":"subsets","has_notes":false,"flag_type":1,"frontend_id":151}],"has_next":true,"last_key":""}'
2026-01-10 09:27:10,846 [INFO] __main__.py:188 - Skipping construct-binary-tree-from-preorder-and-inorder-traversal 2024-11-27 21.03.54 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:10,847 [INFO] __main__.py:188 - Skipping path-sum-iii 2024-11-25 11.10.17 because its status is 'Wrong Answer'
2026-01-10 09:27:10,847 [INFO] __main__.py:188 - Skipping path-sum-iii 2024-11-25 10.59.29 because its status is 'Runtime Error'
2026-01-10 09:27:10,847 [INFO] __main__.py:245 - Writing lowest-common-ancestor-of-a-binary-tree/2024-11-25 09.36.28 - Accepted - runtime 13ms - memory 16.3MB.cpp
2026-01-10 09:27:10,848 [INFO] __main__.py:245 - Writing binary-tree-right-side-view/2024-11-23 15.01.58 - Accepted - runtime 0ms - memory 15MB.cpp
2026-01-10 09:27:11,636 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:11,638 [INFO] __main__.py:245 - Writing rotating-the-box/2024-11-23 14.09.47 - Accepted - runtime 198ms - memory 56.2MB.cpp
2026-01-10 09:27:11,639 [INFO] __main__.py:245 - Writing binary-tree-zigzag-level-order-traversal/2024-11-17 08.20.32 - Accepted - runtime 3ms - memory 13.3MB.cpp
2026-01-10 09:27:11,639 [INFO] __main__.py:245 - Writing diameter-of-binary-tree/2024-11-14 21.39.24 - Accepted - runtime 0ms - memory 22.5MB.cpp
2026-01-10 09:27:11,640 [INFO] __main__.py:245 - Writing largest-rectangle-in-histogram/2024-10-27 14.05.53 - Accepted - runtime 65ms - memory 90.4MB.cpp
2026-01-10 09:27:11,641 [INFO] __main__.py:188 - Skipping largest-rectangle-in-histogram 2024-10-27 09.37.04 because its status is 'Wrong Answer'
2026-01-10 09:27:11,641 [INFO] __main__.py:245 - Writing palindrome-linked-list/2024-10-23 17.18.57 - Accepted - runtime 4ms - memory 116.8MB.cpp
2026-01-10 09:27:11,642 [INFO] __main__.py:245 - Writing reverse-linked-list/2024-10-23 16.57.06 - Accepted - runtime 0ms - memory 12.9MB.cpp
2026-01-10 09:27:11,643 [INFO] __main__.py:245 - Writing palindrome-linked-list/2024-10-23 16.53.20 - Accepted - runtime 0ms - memory 125.1MB.cpp
2026-01-10 09:27:13,759 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:13,761 [INFO] __main__.py:245 - Writing linked-list-cycle-ii/2024-10-22 19.25.25 - Accepted - runtime 4ms - memory 10.4MB.cpp
2026-01-10 09:27:13,762 [INFO] __main__.py:245 - Writing linked-list-cycle/2024-10-22 18.50.21 - Accepted - runtime 8ms - memory 10.8MB.cpp
2026-01-10 09:27:13,762 [INFO] __main__.py:245 - Writing reverse-nodes-in-k-group/2024-10-22 01.09.42 - Accepted - runtime 0ms - memory 16.4MB.cpp
2026-01-10 09:27:13,763 [INFO] __main__.py:188 - Skipping maximum-swap 2024-10-17 11.50.57 because its status is 'Wrong Answer'
2026-01-10 09:27:13,763 [INFO] __main__.py:245 - Writing permutations/2024-10-17 10.55.24 - Accepted - runtime 0ms - memory 10.3MB.cpp
2026-01-10 09:27:13,763 [INFO] __main__.py:245 - Writing letter-combinations-of-a-phone-number/2024-10-15 22.55.32 - Accepted - runtime 0ms - memory 8.6MB.cpp
2026-01-10 09:27:13,764 [INFO] __main__.py:245 - Writing subsets/2024-10-15 18.46.09 - Accepted - runtime 8ms - memory 15.4MB.cpp
2026-01-10 09:27:18,769 [DEBUG] leetcode.py:150 - Exporting submissions from 400 to 420
2026-01-10 09:27:22,992 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=400&limit=20 HTTP/1.1" 200 None
2026-01-10 09:27:22,994 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1416859125,"question_id":1013,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1728468426,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1416859125/","is_pending":"Not Pending","title":"Fibonacci Number","memory":"7.4 MB","code":"class Solution {\\npublic:\\n    int fib(int n) {\\n        // BAse Case n==0, n==1\\n    if (n == 0)\\n    {\\n        return 0;\\n    }\\n    if (n == 1)\\n    {\\n        return 1;\\n    }\\n\\n    return fib(n - 1) + fib(n - 2);\\n    }\\n};","compare_result":"1111111111111111111111111111111","title_slug":"fibonacci-number","has_notes":null,"flag_type":1,"frontend_id":150},{"id":1403689886,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727420134,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1403689886/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i = 0;\\n        if (bannedWords.size() == 0) {\\n            return false;\\n        }\\n        int c = 0;\\n        while (i < message.size()) {\\n            int j=0;\\n            int t=c;\\n            while(j<bannedWords.size()) {\\n                if (message[i] == bannedWords[j]) {\\n                    c++;i++;\\n                    if (c >= 2) {\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n            if(t!=c){\\n                i++;\\n            }\\n            \\n        }\\n\\n        return false;\\n    }\\n};","compare_result":"1010000101101100000000111000000000000100001100000110000110001010000010000111101000000000000100000100000001001100001001101110001010000001100110000101100000110000100101100001001000000010001001000101100010100001010100011000000001010011100001001001100001000010000100101000000000001100010010001000001000000001101001000000000100000000000000000100000100001000000101001000100110001110000000111011100100100000000011000101010010100001110000001000000000000101000001100110000100000100001100001000000000000110000101110011001011111111010001","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":149},{"id":1403682952,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727419595,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1403682952/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i = 0;\\n        if (bannedWords.size() == 0) {\\n            return false;\\n        }\\n        int c = 0;\\n        while (i < message.size()) {\\n            for (int j = 0; j < bannedWords.size(); j++) {\\n                if (message[i] == bannedWords[j]) {\\n                    c++;\\n                    if (c == 2) {\\n                        return true;\\n                    }\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":148},{"id":1403682010,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727419520,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1403682010/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i = 0;\\n        if (bannedWords.size() == 0) {\\n            return false;\\n        }\\n        int c = 0;\\n        while (i < message.size()) {\\n            for (int j = 0; j < bannedWords.size(); j++) {\\n                if (message[i] == bannedWords[j]) {\\n                    c++;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        if (c >= 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":147},{"id":1403681039,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727419444,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1403681039/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i = 0;\\n        if (bannedWords.size() == 0) {\\n            return false;\\n        }\\n        int c = 0;\\n        while (i < message.size()) {\\n            for (int j = 0; j < bannedWords.size(); j++) {\\n                if (message[i] == bannedWords[j]) {\\n                    c++;\\n                    break;\\n                }\\n            }\\n            i++;\\n        }\\n        if (c == 2) {\\n            return true;\\n        }\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111011111011111111111111111111111111111111111111111111111111111111111011110111111111111111111111111111111111111111111111011011111111111111111111111111111111111111011111111111101111111111111111111110111111111111111111111111110111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110101111111111111111111111111111111111110111111111111111111111111111111011111111111111111111111110111111111111111111010011100111110000000000000","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":146},{"id":1403674144,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727418924,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1403674144/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i=0;\\n        if(bannedWords.size()==0){\\n            return false;\\n        }\\n        int c=0;\\n        while( i<message.size()){\\n            for(int j=0; j< bannedWords.size(); j++){\\n                if(message[i]==bannedWords[j]){\\n                    c++;\\n                    if(c==2){\\n                    return true;\\n                    }\\n                }\\n            }i++;\\n    }\\n    return false;}\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":145},{"id":1403672293,"question_id":3541,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 3\xc2\xa0months","timestamp":1727418782,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1403672293/","is_pending":"Not Pending","title":"Report Spam Message","memory":"N/A","code":"class Solution {\\npublic:\\n    bool reportSpam(vector<string>& message, vector<string>& bannedWords) {\\n        int i=0;\\n        if(bannedWords.size()==0){\\n            return false;\\n        }\\n        while( i<message.size()){\\n            for(int j=0; j< bannedWords.size(); j++){\\n                if(message[i]==bannedWords[j]){\\n                    return true;\\n                }\\n            }i++;\\n    }\\n    return false;}\\n};","compare_result":"1010111101101110101100111111111111111101111111011111110111101110101111101111111111101111101111110110110101111111111111111011111111011101111111111011110110111101111111111101011110011011111001111111110110111111111111111101011101010100111111011011111111011111111111111110011011011111111111111111101111111111101111111111010110111111111101111101111110011011110111111011111111011111111110111010111111111111111110111111111111111011111111011100011110101111111111111111101111111111111101011111110011101111111111111111011011111111100000","title_slug":"report-spam-message","has_notes":false,"flag_type":1,"frontend_id":144},{"id":1381839730,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725695460,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1381839730/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int c=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]==1){\\n                c++;\\n            }\\n            for(int j=i*i; j<n; j+=i){\\n                prime[j]=false;\\n            \\n            }\\n        }\\n        return c;\\n    }\\n};","compare_result":"111111111111111110000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":143},{"id":1381836566,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725695197,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1381836566/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int c=0;\\n        for(int i=2; i<n; i++){\\n            for(int j=i*i; j<n; j+=i){\\n                if(prime[j]==1){\\n                prime[j]=false;\\n                c++;\\n            }\\n            \\n            }\\n        }\\n        return c;\\n    }\\n};","compare_result":"111100000000101000000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":142},{"id":1378790081,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725454410,"status":10,"status_display":"Accepted","runtime":"533 ms","url":"/submissions/detail/1378790081/","is_pending":"Not Pending","title":"Count Primes","memory":"11.8 MB","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        int cnt=0;\\n        vector<bool> prime(n+2,true);\\n        prime[0]=prime[1]=false;\\n        \\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":141},{"id":1378788022,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725454256,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1378788022/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        int cnt=0;\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        \\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*i; j<n; j=j+i){\\n\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111110000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":140},{"id":1378782279,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725453831,"status":10,"status_display":"Accepted","runtime":"525 ms","url":"/submissions/detail/1378782279/","is_pending":"Not Pending","title":"Count Primes","memory":"11.8 MB","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        int cnt=0;\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        \\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":139},{"id":1378782168,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725453821,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1378782168/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        int cnt=0;\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        \\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n                    cout<<j<<\\" \\";\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111110000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":138},{"id":1378779888,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725453645,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1378779888/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        int cnt=0;\\n        vector<bool> prime(n,true);\\n        prime[0]=prime[1]=false;\\n        \\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n                    cout<<j<<\\" \\";\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"100000000000000000000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":137},{"id":1377899930,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725381158,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1377899930/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"100000000000000000000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":136},{"id":1377899691,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725381146,"status":10,"status_display":"Accepted","runtime":"526 ms","url":"/submissions/detail/1377899691/","is_pending":"Not Pending","title":"Count Primes","memory":"11.9 MB","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n                for(int j=i*2; j<n; j=j+i){\\n                    prime[j]=0;\\n                }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":135},{"id":1377897815,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725381056,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1377897815/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i*i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n            \\n            for(int j=i*i; j<n; j=j+i){\\n                prime[j]=0;\\n            }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"011100000000000000000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":134},{"id":1377897238,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725381027,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1377897238/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n            \\n            for(int j=i*i; j<n; j=j+i){\\n                prime[j]=0;\\n            }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111110000000000000000000000000000000000000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":133},{"id":1377894542,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725380894,"status":10,"status_display":"Accepted","runtime":"530 ms","url":"/submissions/detail/1377894542/","is_pending":"Not Pending","title":"Count Primes","memory":"11.8 MB","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n            \\n            for(int j=2*i; j<n; j=j+i){\\n                prime[j]=0;\\n            }\\n        }\\n    }\\n    return cnt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111","title_slug":"count-primes","has_notes":null,"flag_type":1,"frontend_id":132},{"id":1377888492,"question_id":204,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725380588,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1377888492/","is_pending":"Not Pending","title":"Count Primes","memory":"N/A","code":"class Solution {\\npublic:\\n    int countPrimes(int n) {\\n        vector<bool> prime(n+1,true);\\n        prime[0]=prime[1]=false;\\n        int cnt=0;\\n        for(int i=2; i<n; i++){\\n            if(prime[i]){\\n                cnt++;\\n            }\\n            for(int j=2*i; j<n; j=j+i){\\n                prime[j]=0;\\n            }\\n        }\\n        return cnt;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111110000000000000000","title_slug":"count-primes","has_notes":false,"flag_type":1,"frontend_id":131}],"has_next":true,"last_key":""}'
2026-01-10 09:27:26,504 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:26,507 [INFO] __main__.py:245 - Writing fibonacci-number/2024-10-09 15.37.06 - Accepted - runtime 12ms - memory 7.4MB.cpp
2026-01-10 09:27:26,507 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.25.34 because its status is 'Wrong Answer'
2026-01-10 09:27:26,508 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.16.35 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:26,508 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.15.20 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:26,508 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.14.04 because its status is 'Wrong Answer'
2026-01-10 09:27:26,509 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.05.24 because its status is 'Wrong Answer'
2026-01-10 09:27:26,509 [INFO] __main__.py:188 - Skipping report-spam-message 2024-09-27 12.03.02 because its status is 'Wrong Answer'
2026-01-10 09:27:26,509 [INFO] __main__.py:188 - Skipping count-primes 2024-09-07 13.21.00 because its status is 'Runtime Error'
2026-01-10 09:27:26,509 [INFO] __main__.py:188 - Skipping count-primes 2024-09-07 13.16.37 because its status is 'Wrong Answer'
2026-01-10 09:27:26,817 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:26,820 [INFO] __main__.py:245 - Writing count-primes/2024-09-04 18.23.30 - Accepted - runtime 533ms - memory 11.8MB.cpp
2026-01-10 09:27:26,821 [INFO] __main__.py:188 - Skipping count-primes 2024-09-04 18.20.56 because its status is 'Runtime Error'
2026-01-10 09:27:26,822 [INFO] __main__.py:245 - Writing count-primes/2024-09-04 18.13.51 - Accepted - runtime 525ms - memory 11.8MB.cpp
2026-01-10 09:27:26,822 [INFO] __main__.py:188 - Skipping count-primes 2024-09-04 18.13.41 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:26,822 [INFO] __main__.py:188 - Skipping count-primes 2024-09-04 18.10.45 because its status is 'Runtime Error'
2026-01-10 09:27:26,823 [INFO] __main__.py:188 - Skipping count-primes 2024-09-03 22.02.38 because its status is 'Runtime Error'
2026-01-10 09:27:26,823 [INFO] __main__.py:245 - Writing count-primes/2024-09-03 22.02.26 - Accepted - runtime 526ms - memory 11.9MB.cpp
2026-01-10 09:27:26,824 [INFO] __main__.py:188 - Skipping count-primes 2024-09-03 22.00.56 because its status is 'Wrong Answer'
2026-01-10 09:27:26,824 [INFO] __main__.py:188 - Skipping count-primes 2024-09-03 22.00.27 because its status is 'Runtime Error'
2026-01-10 09:27:26,824 [INFO] __main__.py:245 - Writing count-primes/2024-09-03 21.58.14 - Accepted - runtime 530ms - memory 11.8MB.cpp
2026-01-10 09:27:26,825 [INFO] __main__.py:188 - Skipping count-primes 2024-09-03 21.53.08 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:31,829 [DEBUG] leetcode.py:150 - Exporting submissions from 420 to 440
2026-01-10 09:27:35,233 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=420&limit=20 HTTP/1.1" 200 None
2026-01-10 09:27:35,235 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1376189655,"question_id":240,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725261033,"status":10,"status_display":"Accepted","runtime":"54 ms","url":"/submissions/detail/1376189655/","is_pending":"Not Pending","title":"Search a 2D Matrix II","memory":"17.7 MB","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=col-1;\\n        while(s<row && e>=0){\\n            int element=matrix[s][e];\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element>target){\\n                e--;\\n            }\\n            else{\\n                s++;\\n            }\\n        }\\n    return 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-a-2d-matrix-ii","has_notes":false,"flag_type":1,"frontend_id":130},{"id":1376189092,"question_id":240,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725260997,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1376189092/","is_pending":"Not Pending","title":"Search a 2D Matrix II","memory":"N/A","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=col-1;\\n        while(s<row && col>=0){\\n            int element=matrix[s][e];\\n            if(element == target){\\n                return 1;\\n            }\\n            if(element>target){\\n                e--;\\n            }\\n            else{\\n                s++;\\n            }\\n        }\\n    return 0;\\n    }\\n};","compare_result":"1110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"search-a-2d-matrix-ii","has_notes":false,"flag_type":1,"frontend_id":129},{"id":1376146327,"question_id":74,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725258280,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1376146327/","is_pending":"Not Pending","title":"Search a 2D Matrix","memory":"12.2 MB","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=row*col-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int element=matrix[mid/col][mid%col];\\n            if(element==target){\\n                return 1;\\n            }if(element>target){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n\\nreturn 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-a-2d-matrix","has_notes":false,"flag_type":1,"frontend_id":128},{"id":1376146145,"question_id":74,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725258270,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1376146145/","is_pending":"Not Pending","title":"Search a 2D Matrix","memory":"N/A","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=row*col-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int element=matrix[mid/col][mid%col];\\n            if(element==target){\\n                return 1;\\n            }if(element>target){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n\\nreturn\\n    }\\n};","compare_result":null,"title_slug":"search-a-2d-matrix","has_notes":false,"flag_type":1,"frontend_id":127},{"id":1376145174,"question_id":74,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725258215,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1376145174/","is_pending":"Not Pending","title":"Search a 2D Matrix","memory":"12.1 MB","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=row*col-1;\\n            int mid=s+(e-s)/2;\\n\\n        while(s<=e){\\n            \\n            int element=matrix[mid/col][mid%col];\\n            if(element==target){\\n                return 1;\\n            }else if(element>target){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n\\nreturn 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-a-2d-matrix","has_notes":false,"flag_type":1,"frontend_id":126},{"id":1376143615,"question_id":74,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725258116,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1376143615/","is_pending":"Not Pending","title":"Search a 2D Matrix","memory":"12 MB","code":"class Solution {\\npublic:\\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int s=0,e=row*col-1;\\n\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            int element=matrix[mid/col][mid%col];\\n            if(element==target){\\n                return 1;\\n            }else if(element>target){\\n                e=mid-1;\\n            }else{\\n                s=mid+1;\\n            }\\n        }\\n\\nreturn 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"search-a-2d-matrix","has_notes":false,"flag_type":1,"frontend_id":125},{"id":1375291831,"question_id":48,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725188715,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1375291831/","is_pending":"Not Pending","title":"Rotate Image","memory":"9 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int row=0; row<n; row++){\\n            for(int col=row; col<n ; col++){\\n                swap(matrix[row][col],matrix[col][row]);\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            reverse(matrix[i].begin(),matrix[i].end());\\n\\n        }\\n    }\\n};","compare_result":"111111111111111111111","title_slug":"rotate-image","has_notes":false,"flag_type":1,"frontend_id":124},{"id":1375042058,"question_id":59,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725170933,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1375042058/","is_pending":"Not Pending","title":"Spiral Matrix II","memory":"8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int total=n*n;\\n        int count=1;\\n        while(count<=total){\\n            if(count<=total){\\n                for(int i=startingCol; i<=endingCol; i++){\\n                ans[startingRow][i]=count;count++;\\n            }startingRow++;\\n            }\\n            if(count<=total){\\n                for(int i=startingRow; i<=endingRow; i++){\\n                    ans[i][endingCol]=count;count++;\\n                }endingCol--;\\n            }\\n            if(count<=total){\\n                for(int i=endingCol; i>=startingCol;i--){\\n                    ans[endingRow][i]=count;count++;\\n                }endingRow--;\\n                \\n            }\\n            if(count<=total){\\n                for(int i=endingRow; i>=startingRow; i--){\\n                    ans[i][startingCol]=count;count++;\\n                }startingCol++;\\n            }\\n\\n            // endingCol=\\n\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111","title_slug":"spiral-matrix-ii","has_notes":false,"flag_type":1,"frontend_id":123},{"id":1375026641,"question_id":59,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725169893,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1375026641/","is_pending":"Not Pending","title":"Spiral Matrix II","memory":"7.8 MB","code":"class Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        \\n        vector<vector<int>> ans(n,vector<int>(n,0));\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int total=n*n;\\n        int count=1;\\n        while(count<=total){\\n            if(count<=total){\\n                for(int i=startingCol; i<=endingCol; i++){\\n                ans[startingRow][i]=count;count++;\\n            }startingRow++;\\n            }\\n            if(count<=total){\\n                for(int i=startingRow; i<=endingRow; i++){\\n                    ans[i][endingCol]=count;count++;\\n                }endingCol--;\\n            }\\n            if(count<=total){\\n                for(int i=endingCol; i>=startingCol;i--){\\n                    ans[endingRow][i]=count;count++;\\n                }endingRow--;\\n                \\n            }\\n            if(count<=total){\\n                for(int i=endingRow; i>=startingRow; i--){\\n                    ans[i][startingCol]=count;count++;\\n                }startingCol++;\\n            }\\n\\n            // endingCol=\\n\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111","title_slug":"spiral-matrix-ii","has_notes":false,"flag_type":1,"frontend_id":122},{"id":1374983952,"question_id":54,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725166891,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1374983952/","is_pending":"Not Pending","title":"Spiral Matrix","memory":"8.5 MB","code":"class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow=matrix.size();\\n        int ncol=matrix[0].size();\\n\\n        int startingRow=0;\\n        int startingCol=0;\\n        int endingRow=nrow-1;\\n        int endingCol=ncol-1;\\n\\n        int count =0;\\n        int total= nrow*ncol;\\n        vector<int> ans;\\n        while(count<total){\\n            if(count<total){\\n                for(int i=startingCol; i<=endingCol; i++){\\n                    ans.push_back(matrix[startingRow][i]);count++;\\n                }startingRow++;\\n            }\\n            if(count<total){\\n                for(int i=startingRow; i<=endingRow; i++){\\n                    ans.push_back(matrix[i][endingCol]);count++;\\n                }endingCol--;\\n            }\\n            if(count<total){\\n                for(int i=endingCol; i>=startingCol; i--){\\n                    ans.push_back(matrix[endingRow][i]);count++;\\n                }endingRow--;\\n            }\\n            if(count<total){\\n                for(int i=endingRow; i>=startingRow; i--){\\n                    ans.push_back(matrix[i][startingCol]);count++;\\n                }startingCol++;;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"spiral-matrix","has_notes":false,"flag_type":1,"frontend_id":121},{"id":1374981605,"question_id":54,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725166713,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1374981605/","is_pending":"Not Pending","title":"Spiral Matrix","memory":"8.2 MB","code":"class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int nrow=matrix.size();\\n        int ncol=matrix[0].size();\\n\\n        int startingRow=0;\\n        int startingCol=0;\\n        int endingRow=nrow-1;\\n        int endingCol=ncol-1;\\n\\n        int count =0;\\n        int total= nrow*ncol;\\n        vector<int> ans;\\n        while(count<total){\\n            if(count<total){\\n                for(int i=startingCol; i<=endingCol; i++){\\n                    ans.push_back(matrix[startingRow][i]);\\n                    count++;\\n                }startingRow++;\\n            }\\n            if(count<total){\\n                for(int i=startingRow; i<=endingRow; i++){\\n                    ans.push_back(matrix[i][endingCol]);\\n                    count++;\\n                }endingCol--;\\n            }\\n            if(count<total){\\n                for(int i=endingCol; i>=startingCol; i--){\\n                    ans.push_back(matrix[endingRow][i]);\\n                    count++;\\n                }endingRow--;\\n            }\\n            if(count<total){\\n                for(int i=endingRow; i>=startingRow; i--){\\n                    ans.push_back(matrix[i][startingCol]);\\n                    count++;\\n                }startingCol++;;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"spiral-matrix","has_notes":null,"flag_type":1,"frontend_id":120},{"id":1374971127,"question_id":54,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725165922,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1374971127/","is_pending":"Not Pending","title":"Spiral Matrix","memory":"8.5 MB","code":"class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n\\n        int startingRow=0;\\n        int startingCol=0;\\n        int endingRow=row-1;\\n        int endingCol=col-1;\\n\\n        int total=row*col;\\n        int count=0;\\n        vector<int> ans;\\n        while(count<total){\\n            if(count<total){\\n                for(int index=startingCol ; index<=endingCol; index++ ){\\n                ans.push_back(matrix[startingRow][index]);count++;\\n            }startingRow++;\\n            }\\n            if(count<total){\\n                for(int index=startingRow; index<=endingRow; index++){\\n                ans.push_back(matrix[index][endingCol]);count++;\\n            }endingCol--;\\n            }\\n            if(count<total){\\n                for(int index=endingCol; index>=startingCol; index--){\\n                ans.push_back(matrix[endingRow][index]);count++;\\n            }endingRow--;\\n            }\\n            if(count<total){\\n               for(int index=endingRow; index>=startingRow; index--){\\n                ans.push_back(matrix[index][startingCol]);count++;\\n            }startingCol++; \\n            }  \\n        }\\n    return ans;\\n    }\\n};","compare_result":"11111111111111111111111111","title_slug":"spiral-matrix","has_notes":false,"flag_type":1,"frontend_id":119},{"id":1374964001,"question_id":54,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725165356,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1374964001/","is_pending":"Not Pending","title":"Spiral Matrix","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        int startingRow=0;\\n int       startingCol=0;\\n    int    endingRow=row-1;\\n       int endingCol=col-1;\\n        int total=row*col;\\n        int count=0;\\n        vector<int> ans;\\n        while(count<total){\\n            if(count<total){\\n                for(int index=0 ; index<=endingCol; index++ ){\\n                ans.push_back(matrix[startingRow][index]);\\n            }startingRow++;\\n            }\\n            if(count<total){\\n                for(int index=0; index<=endingRow; index++){\\n                ans.push_back(matrix[index][endingCol]);\\n            }endingCol--;\\n            }\\n            if(count<total){\\n                for(int index=endingCol; index>=startingCol; index--){\\n                ans.push_back(matrix[endingRow][index]);\\n            }endingRow--;\\n            }\\n            if(count<total){\\n               for(int index=endingRow; index>=startingRow; index++){\\n                ans.push_back(matrix[index][startingCol]);\\n            }startingCol++; \\n            }\\n            \\n        }\\n    return ans;\\n    }\\n};","compare_result":"00000000000000000000000000","title_slug":"spiral-matrix","has_notes":false,"flag_type":1,"frontend_id":118},{"id":1374876752,"question_id":3553,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725160967,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1374876752/","is_pending":"Not Pending","title":"Check if Two Chessboard Squares Have the Same Color","memory":"N/A","code":"class Solution {\\npublic:\\n    bool checkTwoChessboards(string coordinate1, string coordinate2) {\\n        int r1=0,c1=0,r2=0,c2=0;\\n        for(int i=0; i<coordinate1.size(); i++){\\n            if(i==0){\\n                r1=coordinate1[i];\\n            }else{\\n                c1=coordinate1[i];\\n            }\\n        }\\n        r1=r1-\'a\'+1;\\n        for(int i=0; i<coordinate2.size(); i++){\\n            if(i==0){\\n                r2=coordinate2[i];\\n            }else{\\n                c2=coordinate2[i];\\n            }\\n        }\\n        r2=r2-\'a\'+1;\\n        if((((r1*c1)%2!=0 && (r2*c2)%2!=0)||((r1*c1)%2==0 && (r2*c2)%2==0))){\\n            return true;\\n        }\\n        return false;\\n        }\\n    \\n};","compare_result":"11111111101000011110110110011111110110111010111110110111110011001101100111100010110110111111111111110111011011011011111100011011000101011101100100101101101011000111100100111011111100101100111111101111111001011111011111111111101010101011001110000001111100111011110001000110110111111110101111001111010010110010111101010101101010011110111001111010001101101101111110111110010100111111110110110111110101111100001000010111111111011110010111110111101011110110010100000001111111011101011110101000110100101111111101","title_slug":"check-if-two-chessboard-squares-have-the-same-color","has_notes":false,"flag_type":1,"frontend_id":117},{"id":1374872546,"question_id":3553,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1725160826,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1374872546/","is_pending":"Not Pending","title":"Check if Two Chessboard Squares Have the Same Color","memory":"N/A","code":"class Solution {\\npublic:\\n    bool checkTwoChessboards(string coordinate1, string coordinate2) {\\n        int r1=0,c1=0,r2=0,c2=0;\\n        for(int i=0; i<coordinate1.size(); i++){\\n            if(i==0){\\n                r1=coordinate1[i];\\n            }else{\\n                c1=coordinate1[i];\\n            }\\n        }\\n        r1=r1-\'a\'+1;\\n        for(int i=0; i<coordinate2.size(); i++){\\n            if(i==0){\\n                r2=coordinate2[i];\\n            }else{\\n                c2=coordinate2[i];\\n            }\\n        }\\n        r2=r2-\'a\'+1;\\n        if(((r1*c1)%2!=0 && (r2*c2)%2!=0)){\\n            return true;\\n        }\\n        return false;\\n        }\\n    \\n};","compare_result":"11100110110010100111111100010101001111101111111001101010110000000101100100111101010111111010011000011000100101110011001111001000001011111010101101111111011101001001111011011011100011001111100011010001110100111000110001110101001101001110110110110011101011000111011100010001010000101010110111010000011101101111100010101100000111101100011111000110101010110000011001001100111111011001010111100110101000010001100111101110000000000011111101101110010100000001100001111001111001100100111010111011110111100001111001","title_slug":"check-if-two-chessboard-squares-have-the-same-color","has_notes":false,"flag_type":1,"frontend_id":116},{"id":1372623495,"question_id":443,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724962908,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1372623495/","is_pending":"Not Pending","title":"String Compression","memory":"14 MB","code":"class Solution {\\npublic:\\n    int compress(vector<char>& chars) {\\n        int i=0, index=0;\\n        while(i<chars.size()){\\n            int j=i+1;\\n            while(j<chars.size() && chars[i]==chars[j]){\\n                j++;\\n            }\\n\\n            chars[index++]=chars[i];\\n            int count = j-i;\\n           \\n            if(count>1){\\n                string cnt=to_string(count);\\n                \\n                for(char ch:cnt){\\n                    \\n                    chars[index++]=ch;\\n            }\\n            }\\n            \\n            i=j;\\n        }\\n        return index;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-compression","has_notes":false,"flag_type":1,"frontend_id":115},{"id":1372623259,"question_id":443,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724962886,"status":10,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/1372623259/","is_pending":"Not Pending","title":"String Compression","memory":"14 MB","code":"class Solution {\\npublic:\\n    int compress(vector<char>& chars) {\\n        int i=0, index=0;\\n        while(i<chars.size()){\\n            int j=i+1;\\n            while(j<chars.size() && chars[i]==chars[j]){\\n                j++;\\n            }\\n            cout << j<<\\" \\";\\n            chars[index++]=chars[i];\\n            int count = j-i;\\n            cout<<count<<\\" \\";\\n            if(count>1){\\n                string cnt=to_string(count);\\n                \\n                for(char ch:cnt){\\n                    cout<<ch<<endl;\\n                    chars[index++]=ch;\\n            }\\n            }\\n            \\n            i=j;\\n        }\\n        return index;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-compression","has_notes":false,"flag_type":1,"frontend_id":114},{"id":1372622420,"question_id":443,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724962807,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1372622420/","is_pending":"Not Pending","title":"String Compression","memory":"14 MB","code":"class Solution {\\npublic:\\n    int compress(vector<char>& chars) {\\n        int i=0, index=0, n=chars.size();\\n        while(i<n){\\n            int j=i+1;\\n            while(j<n && chars[i]==chars[j]){\\n                j++;\\n            }\\n            cout << j<<\\" \\";\\n            chars[index++]=chars[i];\\n            int count = j-i;\\n            cout<<count<<\\" \\";\\n            if(count>1){\\n                string cnt=to_string(count);\\n                \\n                for(char ch:cnt){\\n                    cout<<ch<<endl;\\n                    chars[index++]=ch;\\n            }\\n            }\\n            \\n            i=j;\\n        }\\n        return index;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"string-compression","has_notes":false,"flag_type":1,"frontend_id":113},{"id":1372579673,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724959346,"status":10,"status_display":"Accepted","runtime":"2371 ms","url":"/submissions/detail/1372579673/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"11.3 MB","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int n=s.length();\\n        while(i<n){\\n            if(s[i]==s[i+1]){\\n                s.erase(i,2);\\n                i=0;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":112},{"id":1372576874,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724959147,"status":10,"status_display":"Accepted","runtime":"2849 ms","url":"/submissions/detail/1372576874/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"11.4 MB","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        for(int i=0;i<s.size();i++){\\n            if(s.size()==1) return s;\\n            if(s[i]==s[i+1]){\\n                s.erase(i,2);\\n                i=-1;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":111}],"has_next":true,"last_key":""}'
2026-01-10 09:27:39,068 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:39,071 [INFO] __main__.py:245 - Writing search-a-2d-matrix-ii/2024-09-02 12.40.33 - Accepted - runtime 54ms - memory 17.7MB.cpp
2026-01-10 09:27:39,072 [INFO] __main__.py:188 - Skipping search-a-2d-matrix-ii 2024-09-02 12.39.57 because its status is 'Runtime Error'
2026-01-10 09:27:39,376 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:39,378 [INFO] __main__.py:245 - Writing search-a-2d-matrix/2024-09-02 11.54.40 - Accepted - runtime 3ms - memory 12.2MB.cpp
2026-01-10 09:27:39,379 [INFO] __main__.py:188 - Skipping search-a-2d-matrix 2024-09-02 11.54.30 because its status is 'Compile Error'
2026-01-10 09:27:39,379 [INFO] __main__.py:245 - Writing search-a-2d-matrix/2024-09-02 11.53.35 - Accepted - runtime 3ms - memory 12.1MB.cpp
2026-01-10 09:27:39,380 [INFO] __main__.py:245 - Writing search-a-2d-matrix/2024-09-02 11.51.56 - Accepted - runtime 8ms - memory 12MB.cpp
2026-01-10 09:27:39,381 [INFO] __main__.py:245 - Writing rotate-image/2024-09-01 16.35.15 - Accepted - runtime 0ms - memory 9MB.cpp
2026-01-10 09:27:39,712 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:39,713 [INFO] __main__.py:245 - Writing spiral-matrix-ii/2024-09-01 11.38.53 - Accepted - runtime 0ms - memory 8MB.cpp
2026-01-10 09:27:39,713 [INFO] __main__.py:245 - Writing spiral-matrix-ii/2024-09-01 11.21.33 - Accepted - runtime 0ms - memory 7.8MB.cpp
2026-01-10 09:27:39,713 [INFO] __main__.py:245 - Writing spiral-matrix/2024-09-01 10.31.31 - Accepted - runtime 0ms - memory 8.5MB.cpp
2026-01-10 09:27:39,714 [INFO] __main__.py:245 - Writing spiral-matrix/2024-09-01 10.28.33 - Accepted - runtime 4ms - memory 8.2MB.cpp
2026-01-10 09:27:39,714 [INFO] __main__.py:245 - Writing spiral-matrix/2024-09-01 10.15.22 - Accepted - runtime 0ms - memory 8.5MB.cpp
2026-01-10 09:27:39,714 [INFO] __main__.py:188 - Skipping spiral-matrix 2024-09-01 10.05.56 because its status is 'Runtime Error'
2026-01-10 09:27:39,714 [INFO] __main__.py:188 - Skipping check-if-two-chessboard-squares-have-the-same-color 2024-09-01 08.52.47 because its status is 'Wrong Answer'
2026-01-10 09:27:39,715 [INFO] __main__.py:188 - Skipping check-if-two-chessboard-squares-have-the-same-color 2024-09-01 08.50.26 because its status is 'Wrong Answer'
2026-01-10 09:27:40,036 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:40,039 [INFO] __main__.py:245 - Writing string-compression/2024-08-30 01.51.48 - Accepted - runtime 0ms - memory 14MB.cpp
2026-01-10 09:27:40,040 [INFO] __main__.py:245 - Writing string-compression/2024-08-30 01.51.26 - Accepted - runtime 8ms - memory 14MB.cpp
2026-01-10 09:27:40,041 [INFO] __main__.py:245 - Writing string-compression/2024-08-30 01.50.07 - Accepted - runtime 12ms - memory 14MB.cpp
2026-01-10 09:27:40,367 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:40,370 [INFO] __main__.py:245 - Writing remove-all-adjacent-duplicates-in-string/2024-08-30 00.52.26 - Accepted - runtime 2371ms - memory 11.3MB.cpp
2026-01-10 09:27:40,371 [INFO] __main__.py:245 - Writing remove-all-adjacent-duplicates-in-string/2024-08-30 00.49.07 - Accepted - runtime 2849ms - memory 11.4MB.cpp
2026-01-10 09:27:45,376 [DEBUG] leetcode.py:150 - Exporting submissions from 440 to 460
2026-01-10 09:27:53,977 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=440&limit=20 HTTP/1.1" 200 None
2026-01-10 09:27:53,979 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1372575895,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724959077,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1372575895/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"N/A","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==s[i+1]){\\n                s.erase(i,2);\\n                \\n                i=-1;\\n            }if(s.size()==1){\\n                return s;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":110},{"id":1372575554,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724959054,"status":13,"status_display":"Output Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1372575554/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"N/A","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i]==s[i+1]){\\n                s.erase(i,2);\\n                cout<<\\"S=\\"<<s<<\\", i= \\"<<i<<endl;\\n                i=-1;\\n            }if(s.size()==1){\\n                return s;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000000","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":109},{"id":1372561098,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724958008,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1372561098/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"N/A","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        for(int i=0; i<s.size(); i++){\\n            int j=0;\\n            while(j<=s.size()-1. && s.size()>1){\\n                if(s[j]==s[j+1]){\\n                    s.erase(j,2);\\n                }j++;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111101111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":108},{"id":1372558673,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724957847,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1372558673/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"N/A","code":"class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        for(int i=0; i<s.size(); i++){\\n            int j=0;\\n            while(j<s.size()-1. && s.size()>1){\\n                if(s[j]==s[j+1]){\\n                    s.erase(j,2);\\n                }j++;\\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"1111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111000000000000000","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":107},{"id":1372535676,"question_id":1128,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724956393,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1372535676/","is_pending":"Not Pending","title":"Remove All Adjacent Duplicates In String","memory":"N/A","code":"class Solution {\\npublic:\\n    \\n    string removeDuplicates(string s) {\\n\\n        int i = 0;\\n\\n        while (i < s.size()) {\\n            int j = 0;\\n            while (j < s.size() - 1) {\\n                if (s[j] == s[j + 1]) {\\n\\n                    s.erase(j, 2);\\n                }\\n                j++;\\n            }\\n\\n            i++;\\n        }\\n        return s;\\n    }\\n};","compare_result":"1100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"remove-all-adjacent-duplicates-in-string","has_notes":false,"flag_type":1,"frontend_id":106},{"id":1372397715,"question_id":567,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724949104,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1372397715/","is_pending":"Not Pending","title":"Permutation in String","memory":"N/A","code":"class Solution {\\npublic:\\n    bool check(int a[26],b[26]){\\n        for(int i=0; i<26; i++){\\n            if(a[i]!=b[i])\\n            return 0;\\n        }\\n        return 1;\\n    }\\n    bool checkInclusion(string s1, string s2) {\\n        int c1[26]={0};\\n        int c2[26]={0};\\n        for(int i=0; i<s1.size()){\\n            c1[s1[i]-\'a\']++;\\n        }\\n        while(i<s1.size() && i<s2.size()){\\n            c2[s2[i]-\'a\']++;\\n            i++;\\n        }\\n        if(check(c1,c2)){\\n            return 1;\\n        }\\n        while(i<s2.size()){\\n            c2[s2[i]-\'a\']++;\\n            c2[s2[i-s1.size()]]--;\\n            if(check(c1,c2)){\\n                return 1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};","compare_result":null,"title_slug":"permutation-in-string","has_notes":false,"flag_type":1,"frontend_id":105},{"id":1372388197,"question_id":567,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724948595,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1372388197/","is_pending":"Not Pending","title":"Permutation in String","memory":"8.8 MB","code":"class Solution {\\npublic:\\n    bool check(int a[26], int b[26]){\\n        for(int i=0; i<26; i++){\\n            if(a[i]!=b[i])\\n            return 0;\\n        }return 1;\\n    }\\n    bool checkInclusion(string s1, string s2) {\\n        int c1[26]={0};\\n        int c2[26]={0};\\n        int window=s1.size();\\n        for(int i=0; i< s1.size(); i++){\\n            c1[s1[i]-\'a\']++;\\n        }\\n        int i=0;\\n        while(i<s1.size()&& i<s2.size()){\\n            c2[s2[i]-\'a\']++;\\n            i++;\\n        }\\n        if(check(c1,c2)){\\n            \\n            return 1;\\n        }\\n\\n        while(i<s2.size() ){\\n            int newchar=s2[i]-\'a\';\\n            c2[newchar]++;\\n            int old=s2[i-s1.size()]-\'a\';\\n            c2[old]--;\\n\\n            if (check(c1,c2)){\\n            return 1;\\n        }\\n            i++;\\n        }\\n        \\n        return 0;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"permutation-in-string","has_notes":null,"flag_type":1,"frontend_id":104},{"id":1372387561,"question_id":567,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724948559,"status":10,"status_display":"Accepted","runtime":"23 ms","url":"/submissions/detail/1372387561/","is_pending":"Not Pending","title":"Permutation in String","memory":"8.8 MB","code":"class Solution {\\npublic:\\n    bool check(int a[26], int b[26]){\\n        for(int i=0; i<26; i++){\\n            if(a[i]!=b[i])\\n            return 0;\\n        }return 1;\\n    }\\n    bool checkInclusion(string s1, string s2) {\\n        int c1[26]={0};\\n        int c2[26]={0};\\n        int window=s1.size();\\n        for(int i=0; i< s1.size(); i++){\\n            c1[s1[i]-\'a\']++;\\n        }\\n        int i=0;\\n        while(i<s1.size()&& i<s2.size()){\\n            c2[s2[i]-\'a\']++;\\n            i++;\\n        }cout<<\\"Check: \\"<<check(c1,c2)<<endl;\\n        if(check(c1,c2)){\\n            \\n            return 1;\\n        }\\n\\n        while(i<s2.size() ){\\n            int newchar=s2[i]-\'a\';\\n            c2[newchar]++;\\n            int old=s2[i-s1.size()]-\'a\';\\n            c2[old]--;\\n            cout<<\\"Check \\"<<i<<\\" \\"<<check(c1,c2)<<endl;\\n            if (check(c1,c2)){\\n            return 1;\\n        }\\n            i++;\\n        }\\n        \\n        return 0;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"permutation-in-string","has_notes":false,"flag_type":1,"frontend_id":103},{"id":1372332979,"question_id":9,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724945347,"status":10,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/1372332979/","is_pending":"Not Pending","title":"Palindrome Number","memory":"8.5 MB","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }long  r=0;\\n        long  num=x;\\n        \\n        while(num!=0){\\n            int rem=num%10;\\n            r=r*10+rem;\\n            num/=10;\\n        }\\n        \\n\\n        return r==x;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-number","has_notes":null,"flag_type":1,"frontend_id":102},{"id":1372332281,"question_id":9,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724945304,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1372332281/","is_pending":"Not Pending","title":"Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        if(x<0){\\n            return false;\\n        }int  r=0;\\n        int num=x;\\n        \\n        while(num!=0){\\n            int rem=num%10;\\n            r=r*10+rem;\\n            num/=10;\\n        }\\n        \\n\\n        return r==x;\\n    }\\n};","compare_result":"111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":101},{"id":1372311137,"question_id":3555,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724943982,"status":10,"status_display":"Accepted","runtime":"32 ms","url":"/submissions/detail/1372311137/","is_pending":"Not Pending","title":"Final Array State After K Multiplication Operations I","memory":"26.5 MB","code":"class Solution {\\n\\npublic:\\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\\n        int c=0;\\n        vector <int> finals;\\n        while(c<k){\\n            int min=nums[0],mul=1,ans=0;\\n            int i=0;\\n            while(i<nums.size()){\\n                if(nums[i]<min){\\n                    min=nums[i];\\n                    ans=i;\\n                }\\n                    i++;\\n                \\n                \\n            }\\n            mul=multiplier*min;\\n            nums[ans]=mul;\\n            for(int i=0; i<nums.size(); i++){\\n                cout<<nums[i]<<\\" \\";\\n            }cout<<endl;\\n            int j=0;\\n            while(j<nums.size() && c==k-1){\\n                if(j==ans){\\n                    finals.push_back(mul);\\n                }else{\\n                    finals.push_back(nums[j]);\\n                }j++;\\n            }\\n            c++;\\n        }\\n        return finals;\\n    }\\n};\\n    \\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"final-array-state-after-k-multiplication-operations-i","has_notes":false,"flag_type":1,"frontend_id":100},{"id":1372309092,"question_id":3555,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724943854,"status":10,"status_display":"Accepted","runtime":"50 ms","url":"/submissions/detail/1372309092/","is_pending":"Not Pending","title":"Final Array State After K Multiplication Operations I","memory":"26.5 MB","code":"class Solution {\\npublic:\\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\\n        int c=0;\\n        vector <int> finals;\\n        while(c<k){\\n            int min=nums[0],mul=1,ans=0;\\n            int i=0;\\n            while(i<nums.size()){\\n                if(nums[i]<min){\\n                    min=nums[i];\\n                    ans=i;\\n                }\\n                    i++;\\n                \\n                \\n            }\\n            mul=multiplier*min;\\n            nums[ans]=mul;\\n            for(int i=0; i<nums.size(); i++){\\n                cout<<nums[i]<<\\" \\";\\n            }cout<<endl;\\n            int j=0;\\n            while(j<nums.size() && c==k-1){\\n                if(j==ans){\\n                    finals.push_back(mul);\\n                }else{\\n                    finals.push_back(nums[j]);\\n                }j++;\\n            }\\n            c++;\\n        }\\n        return finals;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"final-array-state-after-k-multiplication-operations-i","has_notes":false,"flag_type":1,"frontend_id":99},{"id":1372308136,"question_id":3555,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724943796,"status":10,"status_display":"Accepted","runtime":"43 ms","url":"/submissions/detail/1372308136/","is_pending":"Not Pending","title":"Final Array State After K Multiplication Operations I","memory":"26.5 MB","code":"class Solution {\\npublic:\\n    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {\\n        int c=0;\\n        vector <int> finals;\\n        while(c<k){\\n            int min=nums[0],mul=1,ans=0;\\n            int i=0;\\n            while(i<nums.size()){\\n                if(nums[i]<min){\\n                    min=nums[i];\\n                    ans=i;\\n                }\\n                    i++;\\n                \\n                \\n            }\\n            mul=multiplier*min;\\n            nums[ans]=mul;\\n            for(int i=0; i<nums.size(); i++){\\n                cout<<nums[i]<<\\" \\";\\n            }cout<<endl;\\n            int j=0;\\n            while(j<nums.size() && c==k-1){\\n                if(j==ans){\\n                    finals.push_back(mul);\\n                }else{\\n                    finals.push_back(nums[j]);\\n                }j++;\\n            }\\n            c++;\\n        }\\n        return finals;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"final-array-state-after-k-multiplication-operations-i","has_notes":false,"flag_type":1,"frontend_id":98},{"id":1371581928,"question_id":567,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724878108,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1371581928/","is_pending":"Not Pending","title":"Permutation in String","memory":"N/A","code":"class Solution {\\npublic:\\n    string rev(string s1){\\n        int s=0,e=s1.length()-1;\\n        while(s<e){\\n            swap(s1[s],s1[e]);\\n            s++;e--;\\n        }\\n        return s1;\\n    }\\n    bool checkInclusion(string s1, string s2) {\\n        string s3=rev(s1);\\n\\n        if((s2.find(s1)<s2.length()) || (s2.find(s3)<s2.length())){\\n            return true;\\n        }\\n            return false;\\n        \\n    }\\n};","compare_result":"111111011111111111111111111111110111111111111111111111111111010111011110000000000000000000000111111111110111","title_slug":"permutation-in-string","has_notes":false,"flag_type":1,"frontend_id":97},{"id":1371566209,"question_id":2021,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724876679,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1371566209/","is_pending":"Not Pending","title":"Remove All Occurrences of a Substring","memory":"8.2 MB","code":"class Solution {\\npublic:\\n    string removeOccurrences(string s, string part) {\\n        while(s.length()!=0 && s.find(part)<s.length()){\\n            s.erase(s.find(part),part.length());\\n        }\\n        return s;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-all-occurrences-of-a-substring","has_notes":null,"flag_type":1,"frontend_id":96},{"id":1371561322,"question_id":2021,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724876250,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1371561322/","is_pending":"Not Pending","title":"Remove All Occurrences of a Substring","memory":"7.9 MB","code":"class Solution {\\npublic:\\n    string removeOccurrences(string s, string part) {\\n        while(s.length()!=0 && s.find(part)<s.length()){\\n            s.erase(s.find(part),part.length());\\n        }\\n        return s;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"remove-all-occurrences-of-a-substring","has_notes":false,"flag_type":1,"frontend_id":95},{"id":1371072705,"question_id":125,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724845815,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1371072705/","is_pending":"Not Pending","title":"Valid Palindrome","memory":"8.9 MB","code":"class Solution {\\npublic:\\n    \\n    bool isPalindrome(string s) {\\n        int start=0,e=s.length()-1,i=0;\\n        while(i<s.length()){\\n            if(s[i]>=\'A\' && s[i]<=\'Z\'){\\n                s[i]=s[i]-\'A\'+\'a\';\\n            }i++;\\n        }\\n       \\n        \\n        while(start<e){\\n            if(s[start]==s[e]){\\n                start++;e--;\\n            }while(!isalnum(s[start]) && start<e){\\n                start++;\\n            }while(!isalnum(s[e])&& start<e){\\n                e--;\\n            }\\n            if(s[start]!=s[e]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-palindrome","has_notes":false,"flag_type":1,"frontend_id":94},{"id":1371072461,"question_id":125,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724845793,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1371072461/","is_pending":"Not Pending","title":"Valid Palindrome","memory":"8.9 MB","code":"class Solution {\\npublic:\\n    \\n    bool isPalindrome(string s) {\\n        int start=0,e=s.length()-1,i=0;\\n        while(i<s.length()){\\n            if(s[i]>=\'A\' && s[i]<=\'Z\'){\\n                s[i]=s[i]-\'A\'+\'a\';\\n            }i++;\\n        }\\n        cout<<s;\\n        start=0;\\n        while(start<e){\\n            if(s[start]==s[e]){\\n                start++;e--;\\n            }while(!isalnum(s[start]) && start<e){\\n                start++;\\n            }while(!isalnum(s[e])&& start<e){\\n                e--;\\n            }\\n            if(s[start]!=s[e]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-palindrome","has_notes":false,"flag_type":1,"frontend_id":93},{"id":1371071947,"question_id":125,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724845753,"status":10,"status_display":"Accepted","runtime":"9 ms","url":"/submissions/detail/1371071947/","is_pending":"Not Pending","title":"Valid Palindrome","memory":"9 MB","code":"class Solution {\\npublic:\\n    \\n    bool isPalindrome(string s) {\\n        int start=0,e=s.length()-1,i=0;\\n        while(start<s.length()){\\n            if(s[start]>=\'A\' && s[start]<=\'Z\'){\\n                s[start]=s[start]-\'A\'+\'a\';\\n            }start++;\\n        }\\n        cout<<s;\\n        start=0;\\n        while(start<e){\\n            if(s[start]==s[e]){\\n                start++;e--;\\n            }while(!isalnum(s[start]) && start<e){\\n                start++;\\n            }while(!isalnum(s[e])&& start<e){\\n                e--;\\n            }\\n            if(s[start]!=s[e]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"valid-palindrome","has_notes":false,"flag_type":1,"frontend_id":92},{"id":1366529416,"question_id":344,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724491195,"status":10,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/1366529416/","is_pending":"Not Pending","title":"Reverse String","memory":"27.2 MB","code":"class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int i=0,j=s.size()-1;\\n       while(i<j){\\n            char t=s[i];\\n            s[i]=s[j];\\n            s[j]=t;\\n            i++;j--;\\n       } \\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-string","has_notes":false,"flag_type":1,"frontend_id":91}],"has_next":true,"last_key":""}'
2026-01-10 09:27:53,981 [INFO] __main__.py:188 - Skipping remove-all-adjacent-duplicates-in-string 2024-08-30 00.47.57 because its status is 'Time Limit Exceeded'
2026-01-10 09:27:53,981 [INFO] __main__.py:188 - Skipping remove-all-adjacent-duplicates-in-string 2024-08-30 00.47.34 because its status is 'Output Limit Exceeded'
2026-01-10 09:27:53,982 [INFO] __main__.py:188 - Skipping remove-all-adjacent-duplicates-in-string 2024-08-30 00.30.08 because its status is 'Wrong Answer'
2026-01-10 09:27:53,982 [INFO] __main__.py:188 - Skipping remove-all-adjacent-duplicates-in-string 2024-08-30 00.27.27 because its status is 'Wrong Answer'
2026-01-10 09:27:53,982 [INFO] __main__.py:188 - Skipping remove-all-adjacent-duplicates-in-string 2024-08-30 00.03.13 because its status is 'Runtime Error'
2026-01-10 09:27:53,983 [INFO] __main__.py:188 - Skipping permutation-in-string 2024-08-29 22.01.44 because its status is 'Compile Error'
2026-01-10 09:27:55,090 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:55,091 [INFO] __main__.py:245 - Writing permutation-in-string/2024-08-29 21.53.15 - Accepted - runtime 4ms - memory 8.8MB.cpp
2026-01-10 09:27:55,092 [INFO] __main__.py:245 - Writing permutation-in-string/2024-08-29 21.52.39 - Accepted - runtime 23ms - memory 8.8MB.cpp
2026-01-10 09:27:55,093 [INFO] __main__.py:245 - Writing palindrome-number/2024-08-29 20.59.07 - Accepted - runtime 12ms - memory 8.5MB.cpp
2026-01-10 09:27:55,094 [INFO] __main__.py:188 - Skipping palindrome-number 2024-08-29 20.58.24 because its status is 'Runtime Error'
2026-01-10 09:27:56,504 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:56,505 [INFO] __main__.py:245 - Writing final-array-state-after-k-multiplication-operations-i/2024-08-29 20.36.22 - Accepted - runtime 32ms - memory 26.5MB.cpp
2026-01-10 09:27:56,505 [INFO] __main__.py:245 - Writing final-array-state-after-k-multiplication-operations-i/2024-08-29 20.34.14 - Accepted - runtime 50ms - memory 26.5MB.cpp
2026-01-10 09:27:56,506 [INFO] __main__.py:245 - Writing final-array-state-after-k-multiplication-operations-i/2024-08-29 20.33.16 - Accepted - runtime 43ms - memory 26.5MB.cpp
2026-01-10 09:27:56,506 [INFO] __main__.py:188 - Skipping permutation-in-string 2024-08-29 02.18.28 because its status is 'Wrong Answer'
2026-01-10 09:27:56,887 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:56,890 [INFO] __main__.py:245 - Writing remove-all-occurrences-of-a-substring/2024-08-29 01.54.39 - Accepted - runtime 5ms - memory 8.2MB.cpp
2026-01-10 09:27:56,890 [INFO] __main__.py:245 - Writing remove-all-occurrences-of-a-substring/2024-08-29 01.47.30 - Accepted - runtime 5ms - memory 7.9MB.cpp
2026-01-10 09:27:56,890 [INFO] __main__.py:245 - Writing valid-palindrome/2024-08-28 17.20.15 - Accepted - runtime 0ms - memory 8.9MB.cpp
2026-01-10 09:27:56,891 [INFO] __main__.py:245 - Writing valid-palindrome/2024-08-28 17.19.53 - Accepted - runtime 6ms - memory 8.9MB.cpp
2026-01-10 09:27:56,891 [INFO] __main__.py:245 - Writing valid-palindrome/2024-08-28 17.19.13 - Accepted - runtime 9ms - memory 9MB.cpp
2026-01-10 09:27:58,267 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:27:58,270 [INFO] __main__.py:245 - Writing reverse-string/2024-08-24 14.49.55 - Accepted - runtime 19ms - memory 27.2MB.cpp
2026-01-10 09:28:03,275 [DEBUG] leetcode.py:150 - Exporting submissions from 460 to 480
2026-01-10 09:28:06,502 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=460&limit=20 HTTP/1.1" 200 None
2026-01-10 09:28:06,503 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1366525271,"question_id":344,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724490868,"status":10,"status_display":"Accepted","runtime":"18 ms","url":"/submissions/detail/1366525271/","is_pending":"Not Pending","title":"Reverse String","memory":"27.3 MB","code":"class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       \\n        int i=0,j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-string","has_notes":false,"flag_type":1,"frontend_id":90},{"id":1366436922,"question_id":1878,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724483723,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1366436922/","is_pending":"Not Pending","title":"Check if Array Is Sorted and Rotated","memory":"10.3 MB","code":"class Solution {\\npublic:\\n    bool check(vector<int>& nums) {\\n\\n        int i=0,c=0;\\n        while(i<nums.size()-1){\\n            if(nums[i]>nums[i+1]){\\n                c++;\\n            }\\n            i++;\\n        }if(nums[nums.size()-1]>nums[0]){\\n                c++;\\n            }\\n        if(c<=1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"check-if-array-is-sorted-and-rotated","has_notes":false,"flag_type":1,"frontend_id":89},{"id":1366431649,"question_id":1878,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724483338,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1366431649/","is_pending":"Not Pending","title":"Check if Array Is Sorted and Rotated","memory":"N/A","code":"class Solution {\\npublic:\\n    bool check(vector<int>& nums) {\\n        vector <int> temp(nums.size());\\n        int i=0,c=0;\\n        while(i<nums.size()-1){\\n            if(nums[i]>nums[i+1]){\\n                c++;\\n            }\\n            i++;\\n        }if(nums[nums.size()-1]>nums[0]){\\n                c++;\\n            }\\n        return c==1;\\n        \\n    }\\n};","compare_result":"1110101111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111001111111111","title_slug":"check-if-array-is-sorted-and-rotated","has_notes":false,"flag_type":1,"frontend_id":88},{"id":1366431028,"question_id":1878,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724483293,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1366431028/","is_pending":"Not Pending","title":"Check if Array Is Sorted and Rotated","memory":"10.8 MB","code":"class Solution {\\npublic:\\n    bool check(vector<int>& nums) {\\n        vector <int> temp(nums.size());\\n        int i=0,c=0;\\n        while(i<nums.size()-1){\\n            if(nums[i]>nums[i+1]){\\n                c++;\\n            }\\n            i++;\\n        }if(nums[nums.size()-1]>nums[0]){\\n                c++;\\n            }\\n        if(c<=1){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n        \\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"check-if-array-is-sorted-and-rotated","has_notes":false,"flag_type":1,"frontend_id":87},{"id":1366408261,"question_id":189,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724481723,"status":10,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/1366408261/","is_pending":"Not Pending","title":"Rotate Array","memory":"27.7 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n        reverse(nums.begin(),nums.end());\\n};\\n};","compare_result":"11111111111111111111111111111111111111","title_slug":"rotate-array","has_notes":null,"flag_type":1,"frontend_id":86},{"id":1366408058,"question_id":189,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724481708,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1366408058/","is_pending":"Not Pending","title":"Rotate Array","memory":"N/A","code":"class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int k=k%nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n        reverse(nums.begin(),nums.end());\\n};\\n};","compare_result":null,"title_slug":"rotate-array","has_notes":false,"flag_type":1,"frontend_id":85},{"id":1366407727,"question_id":189,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724481686,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1366407727/","is_pending":"Not Pending","title":"Rotate Array","memory":"N/A","code":"class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        reverse(nums.begin(),nums.begin()+(nums.size()-k));\\n        reverse(nums.begin()+(nums.size()-k),nums.end());\\n        reverse(nums.begin(),nums.end());\\n};\\n};","compare_result":"11110000000000000000000000000000000000","title_slug":"rotate-array","has_notes":false,"flag_type":1,"frontend_id":84},{"id":1366388088,"question_id":189,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724480335,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1366388088/","is_pending":"Not Pending","title":"Rotate Array","memory":"N/A","code":"class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int c=0,i=0;\\n        vector<int> temp(nums.size());\\n        while(c<nums.size()){\\n            if(i+k==nums.size()){\\n                i=0;\\n                k=0;\\n            }\\n            temp[i+k]=nums[c];\\n            c++;i++;\\n        }\\n        nums=temp;\\n    }\\n};","compare_result":"11110000000000000000000000000000000000","title_slug":"rotate-array","has_notes":false,"flag_type":1,"frontend_id":83},{"id":1366378504,"question_id":189,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724479651,"status":10,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/1366378504/","is_pending":"Not Pending","title":"Rotate Array","memory":"28.2 MB","code":"class Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int i=0,n=nums.size();\\n        vector <int> temp(n);\\n        while(i<n){\\n            int s=(i+k)%n;\\n            temp[s]=nums[i++];\\n            \\n        }\\n        nums=temp;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111","title_slug":"rotate-array","has_notes":false,"flag_type":1,"frontend_id":82},{"id":1361772699,"question_id":283,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724098969,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1361772699/","is_pending":"Not Pending","title":"Move Zeroes","memory":"21.8 MB","code":"class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        for(int j=0; j<nums.size(); j++){\\n            if(nums[j]!=0){\\n                swap(nums[j],nums[i]);\\n                i++;\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"move-zeroes","has_notes":false,"flag_type":1,"frontend_id":81},{"id":1361763644,"question_id":283,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724098173,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1361763644/","is_pending":"Not Pending","title":"Move Zeroes","memory":"N/A","code":"class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        \\n        while(i<nums.size()){\\n            int j=i;\\n            while(j<nums.size()-1){\\n                if(nums[j]==0){\\n                    swap(nums[j],nums[j+1]);\\n                }j++;\\n            }i++;\\n        }\\n    }\\n};","compare_result":"11111111110111111101101011111111111110111101111111011111111111111111101101","title_slug":"move-zeroes","has_notes":false,"flag_type":1,"frontend_id":80},{"id":1361761187,"question_id":283,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724097962,"status":10,"status_display":"Accepted","runtime":"1060 ms","url":"/submissions/detail/1361761187/","is_pending":"Not Pending","title":"Move Zeroes","memory":"21.9 MB","code":"class Solution {\\npublic:\\n    void moveZeroes(vector<int>& nums) {\\n        int i=0;\\n        \\n        while(i<nums.size()){\\n            int j=0;\\n            while(j<nums.size()-1){\\n                if(nums[j]==0){\\n                    swap(nums[j],nums[j+1]);\\n                }j++;\\n            }i++;\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"move-zeroes","has_notes":null,"flag_type":1,"frontend_id":79},{"id":1361735786,"question_id":88,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724095914,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1361735786/","is_pending":"Not Pending","title":"Merge Sorted Array","memory":"11.1 MB","code":"class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i = m - 1;\\n        int j = n - 1;\\n        int k = m + n - 1;\\n        while (j >= 0) {\\n            if (i >= 0 && nums1[i] > nums2[j]) {\\n                nums1[k--] = nums1[i--];\\n\\n            } else {\\n                nums1[k--] = nums2[j--];\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"merge-sorted-array","has_notes":false,"flag_type":1,"frontend_id":78},{"id":1361735317,"question_id":88,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724095875,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1361735317/","is_pending":"Not Pending","title":"Merge Sorted Array","memory":"11.1 MB","code":"class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m-1;\\n        int j=n-1;\\n        int k=m+n-1;\\n        while(j>=0){\\n            if(i>=0 && nums1[i]>nums2[j]){\\n                nums1[k]=nums1[i];\\n                k--;\\n                i--;\\n            }else{\\n                nums1[k]=nums2[j];\\n                k--;\\n                j--;\\n            }\\n        }\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"merge-sorted-array","has_notes":false,"flag_type":1,"frontend_id":77},{"id":1361726292,"question_id":88,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724095206,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1361726292/","is_pending":"Not Pending","title":"Merge Sorted Array","memory":"11.4 MB","code":"class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m,j=0;\\n \\n        while(j<n){\\n            nums1[i++]=nums2[j++];\\n            \\n            \\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"merge-sorted-array","has_notes":null,"flag_type":6,"frontend_id":76},{"id":1361725921,"question_id":88,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 4\xc2\xa0months","timestamp":1724095179,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1361725921/","is_pending":"Not Pending","title":"Merge Sorted Array","memory":"11.3 MB","code":"class Solution {\\npublic:\\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\\n        int i=m,j=0;\\n \\n        while(i<m+n){\\n            nums1[i++]=nums2[j++];\\n            \\n            \\n        }\\n        sort(nums1.begin(),nums1.end());\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111","title_slug":"merge-sorted-array","has_notes":null,"flag_type":6,"frontend_id":75},{"id":1345564932,"question_id":724,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722874399,"status":10,"status_display":"Accepted","runtime":"18 ms","url":"/submissions/detail/1345564932/","is_pending":"Not Pending","title":"Find Pivot Index","memory":"34.6 MB","code":"class Solution {\\npublic:\\n    int pivotIndex(vector<int>& nums) {\\n        int lsum = 0, rsum = 0, i = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            rsum+=nums[i];\\n        }\\n        while (i < nums.size()) {\\n            if (lsum == (rsum-nums[i])) {\\n                return i;\\n            }else{\\n                lsum+=nums[i];\\n                rsum-=nums[i];\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-pivot-index","has_notes":false,"flag_type":1,"frontend_id":74},{"id":1345558397,"question_id":724,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722874065,"status":10,"status_display":"Accepted","runtime":"18 ms","url":"/submissions/detail/1345558397/","is_pending":"Not Pending","title":"Find Pivot Index","memory":"34.7 MB","code":"class Solution {\\npublic:\\n    int pivotIndex(vector<int>& nums) {\\n        int lsum = 0, rsum = 0, i = 0;\\n        rsum = accumulate(nums.begin(), nums.end(), 0);\\n        while (i < nums.size()) {\\n            if (lsum == (rsum-nums[i])) {\\n                return i;\\n            }else{\\n                lsum+=nums[i];\\n                rsum-=nums[i];\\n            }\\n            i++;\\n        }\\n        return -1;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"find-pivot-index","has_notes":null,"flag_type":1,"frontend_id":73},{"id":1345532563,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722872730,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1345532563/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"N/A","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        vector<int> ans;\\n        sort(arr.begin(),arr.end());\\n        int c=0,i=0;\\n        while(i<arr.size()){\\n            if(arr.size()==2){\\n                if(arr[0]!=arr[1]){\\n                    return 0;\\n                }\\n            }\\n            if(arr[i]==arr[i+1]){\\n                c++;\\n                \\n            }else{\\n                ans.push_back(c);\\n                c=0;\\n            }i++;\\n        }\\n        for(int i=0; i<ans.size()-1; i++){\\n            if(ans[i]==ans[i+1]){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n};","compare_result":"11111111100000000000000000000000000000000000000000000000000000000000000","title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":72},{"id":1345509249,"question_id":1,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722871475,"status":10,"status_display":"Accepted","runtime":"119 ms","url":"/submissions/detail/1345509249/","is_pending":"Not Pending","title":"Two Sum","memory":"12.9 MB","code":"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        vector<vector<int>> ans;\\n        int s=0,e=nums.size()-1;\\n        while(s<e){\\n            if(nums[s]+nums[e]==target){\\n                return{s,e};\\n                \\n            }e--;\\n            if(e==s){\\n                s++;\\n                e=nums.size()-1;\\n            }\\n            \\n        }\\n        return {};\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"two-sum","has_notes":null,"flag_type":1,"frontend_id":71}],"has_next":true,"last_key":""}'
2026-01-10 09:28:06,504 [INFO] __main__.py:245 - Writing reverse-string/2024-08-24 14.44.28 - Accepted - runtime 18ms - memory 27.3MB.cpp
2026-01-10 09:28:07,127 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:07,129 [INFO] __main__.py:245 - Writing check-if-array-is-sorted-and-rotated/2024-08-24 12.45.23 - Accepted - runtime 5ms - memory 10.3MB.cpp
2026-01-10 09:28:07,129 [INFO] __main__.py:188 - Skipping check-if-array-is-sorted-and-rotated 2024-08-24 12.38.58 because its status is 'Wrong Answer'
2026-01-10 09:28:07,130 [INFO] __main__.py:245 - Writing check-if-array-is-sorted-and-rotated/2024-08-24 12.38.13 - Accepted - runtime 2ms - memory 10.8MB.cpp
2026-01-10 09:28:08,385 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:08,386 [INFO] __main__.py:245 - Writing rotate-array/2024-08-24 12.12.03 - Accepted - runtime 19ms - memory 27.7MB.cpp
2026-01-10 09:28:08,387 [INFO] __main__.py:188 - Skipping rotate-array 2024-08-24 12.11.48 because its status is 'Compile Error'
2026-01-10 09:28:08,388 [INFO] __main__.py:188 - Skipping rotate-array 2024-08-24 12.11.26 because its status is 'Runtime Error'
2026-01-10 09:28:08,388 [INFO] __main__.py:188 - Skipping rotate-array 2024-08-24 11.48.55 because its status is 'Runtime Error'
2026-01-10 09:28:08,389 [INFO] __main__.py:245 - Writing rotate-array/2024-08-24 11.37.31 - Accepted - runtime 20ms - memory 28.2MB.cpp
2026-01-10 09:28:09,393 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:09,396 [INFO] __main__.py:245 - Writing move-zeroes/2024-08-20 01.52.49 - Accepted - runtime 15ms - memory 21.8MB.cpp
2026-01-10 09:28:09,396 [INFO] __main__.py:188 - Skipping move-zeroes 2024-08-20 01.39.33 because its status is 'Wrong Answer'
2026-01-10 09:28:09,397 [INFO] __main__.py:245 - Writing move-zeroes/2024-08-20 01.36.02 - Accepted - runtime 1060ms - memory 21.9MB.cpp
2026-01-10 09:28:10,512 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:10,515 [INFO] __main__.py:245 - Writing merge-sorted-array/2024-08-20 01.01.54 - Accepted - runtime 3ms - memory 11.1MB.cpp
2026-01-10 09:28:10,516 [INFO] __main__.py:245 - Writing merge-sorted-array/2024-08-20 01.01.15 - Accepted - runtime 3ms - memory 11.1MB.cpp
2026-01-10 09:28:10,517 [INFO] __main__.py:245 - Writing merge-sorted-array/2024-08-20 00.50.06 - Accepted - runtime 0ms - memory 11.4MB.cpp
2026-01-10 09:28:10,517 [INFO] __main__.py:245 - Writing merge-sorted-array/2024-08-20 00.49.39 - Accepted - runtime 5ms - memory 11.3MB.cpp
2026-01-10 09:28:10,874 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:10,877 [INFO] __main__.py:245 - Writing find-pivot-index/2024-08-05 21.43.19 - Accepted - runtime 18ms - memory 34.6MB.cpp
2026-01-10 09:28:10,878 [INFO] __main__.py:245 - Writing find-pivot-index/2024-08-05 21.37.45 - Accepted - runtime 18ms - memory 34.7MB.cpp
2026-01-10 09:28:10,879 [INFO] __main__.py:188 - Skipping unique-number-of-occurrences 2024-08-05 21.15.30 because its status is 'Runtime Error'
2026-01-10 09:28:10,879 [INFO] __main__.py:245 - Writing two-sum/2024-08-05 20.54.35 - Accepted - runtime 119ms - memory 12.9MB.cpp
2026-01-10 09:28:15,885 [DEBUG] leetcode.py:150 - Exporting submissions from 480 to 500
2026-01-10 09:28:17,830 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=480&limit=20 HTTP/1.1" 200 None
2026-01-10 09:28:17,832 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1345467139,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722869152,"status":10,"status_display":"Accepted","runtime":"53 ms","url":"/submissions/detail/1345467139/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"37.3 MB","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0 ; i<nums.size()-1; ){\\n            if(nums[i]==nums[i+1]){\\n                ans.push_back(nums[i]);\\n                i++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":70},{"id":1345465361,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722869057,"status":10,"status_display":"Accepted","runtime":"53 ms","url":"/submissions/detail/1345465361/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"37.3 MB","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0 ; i<nums.size()-1; ){\\n            if(nums[i]==nums[i+1]){\\n                ans.push_back(nums[i]);\\n                i+=2;\\n            }else{\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"find-all-duplicates-in-an-array","has_notes":null,"flag_type":1,"frontend_id":69},{"id":1345457873,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722868649,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1345457873/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int n=0,rev=0;\\n        n=x;\\n        while(x!=0){\\n            int rem=0;\\n            rem=x%10;\\n            if(rev>INT_MAX/10||rev<<INT_MIN){\\n                return 0;\\n            }\\n            rev=rev*10+rem;\\n            x/=10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":68},{"id":1345455464,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722868517,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1345455464/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int n=0,rev=0;\\n        n=x;\\n        while(x!=0){\\n            int rem=0;\\n            rem=x%10;\\n            rev=rev*10+rem;\\n            x/=10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":67},{"id":1344686507,"question_id":724,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722803717,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1344686507/","is_pending":"Not Pending","title":"Find Pivot Index","memory":"N/A","code":"class Solution {\\npublic:\\n    int pivotIndex(vector<int>& nums) {\\n        int lsum=0,rsum=0;\\n        for(int i=0; i<nums.size(); i++){\\n            rsum+=nums[i];\\n        }\\n        for(int j=0; j<nums.size(); j++){\\n            lsum+=nums[j];\\n            rsum-=(nums[j]);\\n            cout<<lsum<<\\" \\"<<rsum<<endl;\\n            if(lsum==rsum){\\n                cout<<j;\\n            }\\n        }\\n        return -1;\\n        \\n        \\n    }\\n};","compare_result":"01010101010101010101010101010100000101000101010101000100010101010100000100010100010101010000000000000100000100010000000100000100000100010100000100000000000100010001010101010100000100010100010101000000010000000100000001010100010100010000010101010101010101000101010001000000010000000000000000000000000101000000010000000100000001010101010000000000010000000101000000010000000100000001010000000100000000000101010101000000010000000100000001010000000000000000000000000100000001000101010001010101010101010100000100010100010101000000010000000100000001010100010100010000010101010101000100010000000000010000010100010000010000010000000100010000010000000000000101010100010100010000010101010100010001010101010001010000010101010101010101010101010100100000001000","title_slug":"find-pivot-index","has_notes":false,"flag_type":1,"frontend_id":66},{"id":1344638654,"question_id":882,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722799617,"status":10,"status_display":"Accepted","runtime":"78 ms","url":"/submissions/detail/1344638654/","is_pending":"Not Pending","title":"Peak Index in a Mountain Array","memory":"62.4 MB","code":"class Solution {\\npublic:\\n    int peakIndexInMountainArray(vector<int>& arr) {\\n        int s=0,e=arr.size()-1;\\n        int mid=s+(e-s)/2;\\n        while(s<e){\\n            \\n            if(arr[mid]<arr[mid+1]){\\n                s=mid+1;\\n            }else{\\n                e=mid;\\n                \\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return s;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111","title_slug":"peak-index-in-a-mountain-array","has_notes":false,"flag_type":1,"frontend_id":65},{"id":1344638272,"question_id":882,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722799589,"status":10,"status_display":"Accepted","runtime":"78 ms","url":"/submissions/detail/1344638272/","is_pending":"Not Pending","title":"Peak Index in a Mountain Array","memory":"62.4 MB","code":"class Solution {\\npublic:\\n    int peakIndexInMountainArray(vector<int>& arr) {\\n        int s=0,e=arr.size()-1;\\n        \\n        while(s<e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]<arr[mid+1]){\\n                s=mid+1;\\n            }else{\\n                e=mid;\\n                \\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111","title_slug":"peak-index-in-a-mountain-array","has_notes":false,"flag_type":1,"frontend_id":64},{"id":1344637318,"question_id":882,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722799520,"status":10,"status_display":"Accepted","runtime":"86 ms","url":"/submissions/detail/1344637318/","is_pending":"Not Pending","title":"Peak Index in a Mountain Array","memory":"62.4 MB","code":"class Solution {\\npublic:\\n    int peakIndexInMountainArray(vector<int>& arr) {\\n        int s=0,e=arr.size()-1;\\n        \\n        while(s<e){\\n            int mid=s+(e-s)/2;\\n            if(arr[mid]<arr[mid+1]){\\n                s=mid+1;\\n            }else if(arr[mid]>arr[mid+1]){\\n                e=mid;\\n                \\n            }\\n        }\\n        return s;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111","title_slug":"peak-index-in-a-mountain-array","has_notes":false,"flag_type":1,"frontend_id":63},{"id":1344175274,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722770835,"status":10,"status_display":"Accepted","runtime":"44 ms","url":"/submissions/detail/1344175274/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"37.3 MB","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i]==nums[i+1]){\\n                ans.push_back(nums[i]);\\n                i+=2;\\n            }else{\\n                i++;}\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":62},{"id":1344174632,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722770792,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1344174632/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0; i<nums.size()-1;){\\n            if(nums[i]==nums[i+1]){\\n                ans.push_back(nums[i]);\\n                i++;\\n            }\\n        }return ans;\\n    }\\n};","compare_result":"0000000000000000000000000000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":61},{"id":1344173038,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722770677,"status":10,"status_display":"Accepted","runtime":"49 ms","url":"/submissions/detail/1344173038/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"37.3 MB","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0; i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                ans.push_back(nums[i]);\\n                \\n            }\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111111","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":60},{"id":1344166151,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722770200,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1344166151/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i; j<nums.size()-1;j++){\\n                if(nums[i]==nums[j+1]){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":59},{"id":1344141759,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722768436,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1344141759/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        int i=0;\\n        while(i<nums.size()){\\n            for(int j=i; j<nums.size()-1;j++){\\n                if(nums[i]==nums[j+1]){\\n                    ans.push_back(nums[i]);\\n                }\\n            }i++;\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":58},{"id":1344140226,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722768319,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1344140226/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i; j<nums.size()-1;j++){\\n                if(nums[i]==nums[j+1]){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":57},{"id":1344139822,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722768288,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1344139822/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i; j<=nums.size()-1;j++){\\n                if(nums[i]==nums[j+1]){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }return ans;\\n    }\\n};","compare_result":"0000000000000000000000000000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":56},{"id":1344137951,"question_id":442,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722768149,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1344137951/","is_pending":"Not Pending","title":"Find All Duplicates in an Array","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> findDuplicates(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i; j<nums.size()-1;j++){\\n                if(nums[i]==nums[j+1]){\\n                    ans.push_back(nums[i]);\\n                }\\n            }\\n        }return ans;\\n    }\\n};","compare_result":"1111111111111111111111111000","title_slug":"find-all-duplicates-in-an-array","has_notes":false,"flag_type":1,"frontend_id":55},{"id":1344077258,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722763696,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1344077258/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"10.8 MB","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        vector<int> ans;\\n        int i=0;\\n        sort(arr.begin(),arr.end());\\n        while(i<arr.size()){\\n            int count=1;\\n            for(int j=i; j<arr.size()-1;j++){\\n                if(arr[i]==arr[j+1]){\\n                    count++;\\n                }\\n                \\n            }\\n            ans.push_back(count);\\n            i+=count;\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            if(ans[i]==ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":54},{"id":1344076240,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722763623,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1344076240/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"N/A","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        vector<int> ans;\\n        int i=0;\\n        sort(arr.begin(),arr.end());\\n        while(i<arr.size()){\\n            int count=1;\\n            for(int j=i+1; j<arr.size()-1;j++){\\n                if(arr[i]==arr[j]){\\n                    count++;\\n                }\\n                \\n            }\\n            ans.push_back(count);\\n            i+=count;\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            if(ans[i]==ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"11110101010101010101110101110101010101010101010101011101111101110111100","title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":53},{"id":1343985832,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722756645,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1343985832/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"N/A","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        vector<int> ans;\\n        \\n        sort(arr.begin(),arr.end());\\n        while(i<arr.size()){\\n            int count=1,i=0;\\n            for(int j=i+1; j<arr.size();j++){\\n                if(arr[i]==arr[j]){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            i+=count;\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            if(ans[i]==ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":null,"title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":52},{"id":1343985021,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722756591,"status":10,"status_display":"Accepted","runtime":"6 ms","url":"/submissions/detail/1343985021/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"10.7 MB","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        vector<int> ans;\\n        int i=0;\\n        sort(arr.begin(),arr.end());\\n        while(i<arr.size()){\\n            int count=1;\\n            for(int j=i+1; j<arr.size();j++){\\n                if(arr[i]==arr[j]){\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n            i+=count;\\n        }\\n        sort(ans.begin(),ans.end());\\n        for(int i=0; i<ans.size()-1; i++){\\n            if(ans[i]==ans[i+1]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":51}],"has_next":true,"last_key":""}'
2026-01-10 09:28:18,405 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:18,407 [INFO] __main__.py:245 - Writing find-all-duplicates-in-an-array/2024-08-05 20.15.52 - Accepted - runtime 53ms - memory 37.3MB.cpp
2026-01-10 09:28:18,408 [INFO] __main__.py:245 - Writing find-all-duplicates-in-an-array/2024-08-05 20.14.17 - Accepted - runtime 53ms - memory 37.3MB.cpp
2026-01-10 09:28:18,409 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-05 20.07.29 because its status is 'Runtime Error'
2026-01-10 09:28:18,409 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-05 20.05.17 because its status is 'Runtime Error'
2026-01-10 09:28:18,410 [INFO] __main__.py:188 - Skipping find-pivot-index 2024-08-05 02.05.17 because its status is 'Wrong Answer'
2026-01-10 09:28:18,730 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:18,731 [INFO] __main__.py:245 - Writing peak-index-in-a-mountain-array/2024-08-05 00.56.57 - Accepted - runtime 78ms - memory 62.4MB.cpp
2026-01-10 09:28:18,732 [INFO] __main__.py:245 - Writing peak-index-in-a-mountain-array/2024-08-05 00.56.29 - Accepted - runtime 78ms - memory 62.4MB.cpp
2026-01-10 09:28:18,732 [INFO] __main__.py:245 - Writing peak-index-in-a-mountain-array/2024-08-05 00.55.20 - Accepted - runtime 86ms - memory 62.4MB.cpp
2026-01-10 09:28:18,732 [INFO] __main__.py:245 - Writing find-all-duplicates-in-an-array/2024-08-04 16.57.15 - Accepted - runtime 44ms - memory 37.3MB.cpp
2026-01-10 09:28:18,733 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.56.32 because its status is 'Time Limit Exceeded'
2026-01-10 09:28:18,733 [INFO] __main__.py:245 - Writing find-all-duplicates-in-an-array/2024-08-04 16.54.37 - Accepted - runtime 49ms - memory 37.3MB.cpp
2026-01-10 09:28:18,733 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.46.40 because its status is 'Time Limit Exceeded'
2026-01-10 09:28:18,733 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.17.16 because its status is 'Time Limit Exceeded'
2026-01-10 09:28:18,734 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.15.19 because its status is 'Time Limit Exceeded'
2026-01-10 09:28:18,734 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.14.48 because its status is 'Runtime Error'
2026-01-10 09:28:18,734 [INFO] __main__.py:188 - Skipping find-all-duplicates-in-an-array 2024-08-04 16.12.29 because its status is 'Time Limit Exceeded'
2026-01-10 09:28:20,530 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:20,532 [INFO] __main__.py:245 - Writing unique-number-of-occurrences/2024-08-04 14.58.16 - Accepted - runtime 0ms - memory 10.8MB.cpp
2026-01-10 09:28:20,533 [INFO] __main__.py:188 - Skipping unique-number-of-occurrences 2024-08-04 14.57.03 because its status is 'Wrong Answer'
2026-01-10 09:28:20,534 [INFO] __main__.py:188 - Skipping unique-number-of-occurrences 2024-08-04 13.00.45 because its status is 'Compile Error'
2026-01-10 09:28:20,534 [INFO] __main__.py:245 - Writing unique-number-of-occurrences/2024-08-04 12.59.51 - Accepted - runtime 6ms - memory 10.7MB.cpp
2026-01-10 09:28:25,539 [DEBUG] leetcode.py:150 - Exporting submissions from 500 to 520
2026-01-10 09:28:26,262 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=500&limit=20 HTTP/1.1" 200 None
2026-01-10 09:28:26,318 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1343201250,"question_id":1319,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722699093,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1343201250/","is_pending":"Not Pending","title":"Unique Number of Occurrences","memory":"N/A","code":"class Solution {\\npublic:\\n    bool uniqueOccurrences(vector<int>& arr) {\\n        int ans=0;\\n        for(int i=0; i<arr.size(); i++){\\n            ans=ans^arr[i];\\n        }\\n        return ans;\\n    }\\n};","compare_result":"10101010101010111010101010101010001010101010101010100010000010111000011","title_slug":"unique-number-of-occurrences","has_notes":false,"flag_type":1,"frontend_id":50},{"id":1343178932,"question_id":342,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722698384,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1343178932/","is_pending":"Not Pending","title":"Power of Four","memory":"7.6 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        int i=0;\\n        while(i<=30){\\n            if(pow(4,i)==n){\\n                return 1;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-four","has_notes":false,"flag_type":1,"frontend_id":49},{"id":1343174278,"question_id":342,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722698241,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1343174278/","is_pending":"Not Pending","title":"Power of Four","memory":"7.7 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        for(int i=0; i<=30; i++){\\n            if(pow(4,i)==n){\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-four","has_notes":false,"flag_type":1,"frontend_id":48},{"id":1342784237,"question_id":326,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677383,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1342784237/","is_pending":"Not Pending","title":"Power of Three","memory":"8.7 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfThree(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(3,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-three","has_notes":false,"flag_type":1,"frontend_id":47},{"id":1342784054,"question_id":326,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677372,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1342784054/","is_pending":"Not Pending","title":"Power of Three","memory":"8.7 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfThree(int n) {\\n        for(int i=0;i<=30;i++){\\n            if(pow(3,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-three","has_notes":false,"flag_type":1,"frontend_id":46},{"id":1342783762,"question_id":326,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677354,"status":10,"status_display":"Accepted","runtime":"11 ms","url":"/submissions/detail/1342783762/","is_pending":"Not Pending","title":"Power of Three","memory":"8.8 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfThree(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(3,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-three","has_notes":false,"flag_type":1,"frontend_id":45},{"id":1342782653,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677284,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1342782653/","is_pending":"Not Pending","title":"Power of Two","memory":"7.5 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":44},{"id":1342782002,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677241,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1342782002/","is_pending":"Not Pending","title":"Power of Two","memory":"7.3 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":43},{"id":1342781831,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677230,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342781831/","is_pending":"Not Pending","title":"Power of Two","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<30;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":42},{"id":1342781511,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677209,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1342781511/","is_pending":"Not Pending","title":"Power of Two","memory":"7.6 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":41},{"id":1342781120,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722677185,"status":10,"status_display":"Accepted","runtime":"5 ms","url":"/submissions/detail/1342781120/","is_pending":"Not Pending","title":"Power of Two","memory":"7.5 MB","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":40},{"id":1342763176,"question_id":231,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722675982,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342763176/","is_pending":"Not Pending","title":"Power of Two","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int i = 0;\\n        while (i>30) {\\n            \\n            if (pow(2, i)== n) {              \\n                return true;  \\n            } \\n            i++;\\n        }\\n        \\n            return false;\\n        \\n        \\n    }\\n};","compare_result":"001011101111111011111111111111101111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011011011011011011011011011011011011011011011011011011011011011111111111111111111111111","title_slug":"power-of-two","has_notes":false,"flag_type":1,"frontend_id":39},{"id":1342728232,"question_id":1054,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722673493,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1342728232/","is_pending":"Not Pending","title":"Complement of Base 10 Integer","memory":"7.6 MB","code":"class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int mask = 0;\\n        int m = n;\\n        if (n == 0) {\\n            return 1;\\n        }\\n        while (m != 0) {\\n            m = m >> 1;\\n            mask = (mask << 1) | 1;\\n        }\\n\\n        int ans;\\n        ans = (~n) & mask;\\n        return ans;\\n    }\\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"complement-of-base-10-integer","has_notes":false,"flag_type":1,"frontend_id":38},{"id":1342724344,"question_id":1054,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722673208,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342724344/","is_pending":"Not Pending","title":"Complement of Base 10 Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int bitwiseComplement(int n) {\\n        int mask=0;\\n        int m=n;\\n        while(m!=0){\\n            m=m>>1;\\n            mask=(mask<<1)|1;\\n            \\n        }\\n        int ans;\\n        ans=(~n)&mask;\\n        return ans;\\n    }\\n};","compare_result":"11101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"complement-of-base-10-integer","has_notes":false,"flag_type":1,"frontend_id":37},{"id":1342687004,"question_id":190,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722670498,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342687004/","is_pending":"Not Pending","title":"Reverse Bits","memory":"N/A","code":"class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int ans=0;\\n        int bit=0;\\n        int i=0;\\n        while(n!=0){\\n            \\n            bit=n%10;\\n            \\n            if(bit==1){\\n                ans+=bit*pow(2,i);\\n            }\\n            i++;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"000100000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-bits","has_notes":false,"flag_type":1,"frontend_id":36},{"id":1342684317,"question_id":190,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722670318,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342684317/","is_pending":"Not Pending","title":"Reverse Bits","memory":"N/A","code":"class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int ans=0;\\n        int bit=0;\\n        int i=0;\\n        while(n!=0){\\n            \\n            bit=n%10;\\n            \\n            if(bit==1){\\n                ans+=bit*pow(2,i);\\n            }\\n            i++;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n};","compare_result":"000100000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-bits","has_notes":false,"flag_type":1,"frontend_id":35},{"id":1342680823,"question_id":190,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722670090,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1342680823/","is_pending":"Not Pending","title":"Reverse Bits","memory":"N/A","code":"class Solution {\\npublic:\\n    uint32_t reverseBits(uint32_t n) {\\n        int ans=0;\\n        while(n!=0){\\n            int bit=0;\\n            int bit=n%10;\\n            int i=0;\\n            if(bit==1){\\n                ans+=bit*pow(2,i);\\n            }\\n            i++;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n};","compare_result":null,"title_slug":"reverse-bits","has_notes":false,"flag_type":1,"frontend_id":34},{"id":1342676746,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669828,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1342676746/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.4 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                        return 0;\\n                    }\\n            rev = (rev * 10) + rem;\\n            \\n            x = x / 10;\\n        }\\n        \\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":33},{"id":1342676452,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669808,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342676452/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            \\n            rev = (rev * 10) + rem;\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                        return 0;\\n                    }\\n            x = x / 10;\\n        }\\n        \\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011101001011111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":32},{"id":1342675636,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669757,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1342675636/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.4 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                        return 0;\\n                    }\\n            rev = (rev * 10) + rem;\\n            x = x / 10;\\n        }\\n        \\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":31}],"has_next":true,"last_key":""}'
2026-01-10 09:28:26,321 [INFO] __main__.py:188 - Skipping unique-number-of-occurrences 2024-08-03 21.01.33 because its status is 'Wrong Answer'
2026-01-10 09:28:35,477 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:35,479 [INFO] __main__.py:245 - Writing power-of-four/2024-08-03 20.49.44 - Accepted - runtime 5ms - memory 7.6MB.cpp
2026-01-10 09:28:35,479 [INFO] __main__.py:245 - Writing power-of-four/2024-08-03 20.47.21 - Accepted - runtime 5ms - memory 7.7MB.cpp
2026-01-10 09:28:38,499 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:38,500 [INFO] __main__.py:245 - Writing power-of-three/2024-08-03 14.59.43 - Accepted - runtime 11ms - memory 8.7MB.cpp
2026-01-10 09:28:38,501 [INFO] __main__.py:245 - Writing power-of-three/2024-08-03 14.59.32 - Accepted - runtime 15ms - memory 8.7MB.cpp
2026-01-10 09:28:38,501 [INFO] __main__.py:245 - Writing power-of-three/2024-08-03 14.59.14 - Accepted - runtime 11ms - memory 8.8MB.cpp
2026-01-10 09:28:39,177 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:39,179 [INFO] __main__.py:245 - Writing power-of-two/2024-08-03 14.58.04 - Accepted - runtime 0ms - memory 7.5MB.cpp
2026-01-10 09:28:39,180 [INFO] __main__.py:245 - Writing power-of-two/2024-08-03 14.57.21 - Accepted - runtime 5ms - memory 7.3MB.cpp
2026-01-10 09:28:39,181 [INFO] __main__.py:188 - Skipping power-of-two 2024-08-03 14.57.10 because its status is 'Wrong Answer'
2026-01-10 09:28:39,181 [INFO] __main__.py:245 - Writing power-of-two/2024-08-03 14.56.49 - Accepted - runtime 0ms - memory 7.6MB.cpp
2026-01-10 09:28:39,182 [INFO] __main__.py:245 - Writing power-of-two/2024-08-03 14.56.25 - Accepted - runtime 5ms - memory 7.5MB.cpp
2026-01-10 09:28:39,183 [INFO] __main__.py:188 - Skipping power-of-two 2024-08-03 14.36.22 because its status is 'Wrong Answer'
2026-01-10 09:28:44,589 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:44,590 [INFO] __main__.py:245 - Writing complement-of-base-10-integer/2024-08-03 13.54.53 - Accepted - runtime 0ms - memory 7.6MB.cpp
2026-01-10 09:28:44,590 [INFO] __main__.py:188 - Skipping complement-of-base-10-integer 2024-08-03 13.50.08 because its status is 'Wrong Answer'
2026-01-10 09:28:44,590 [INFO] __main__.py:188 - Skipping reverse-bits 2024-08-03 13.04.58 because its status is 'Wrong Answer'
2026-01-10 09:28:44,591 [INFO] __main__.py:188 - Skipping reverse-bits 2024-08-03 13.01.58 because its status is 'Wrong Answer'
2026-01-10 09:28:44,591 [INFO] __main__.py:188 - Skipping reverse-bits 2024-08-03 12.58.10 because its status is 'Compile Error'
2026-01-10 09:28:44,591 [INFO] __main__.py:245 - Writing reverse-integer/2024-08-03 12.53.48 - Accepted - runtime 0ms - memory 8.4MB.cpp
2026-01-10 09:28:44,591 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.53.28 because its status is 'Wrong Answer'
2026-01-10 09:28:44,591 [INFO] __main__.py:245 - Writing reverse-integer/2024-08-03 12.52.37 - Accepted - runtime 0ms - memory 8.4MB.cpp
2026-01-10 09:28:49,596 [DEBUG] leetcode.py:150 - Exporting submissions from 520 to 540
2026-01-10 09:28:50,912 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=520&limit=20 HTTP/1.1" 200 None
2026-01-10 09:28:50,913 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1342674391,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669679,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1342674391/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n\\n            rev = (rev * 10) + rem;\\n            x = x / 10;\\n        }\\n        if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n            return 0;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":30},{"id":1342673429,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669615,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1342673429/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.3 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                return 0;\\n            }\\n            rev = (rev * 10) + rem;\\n            x =x/10;\\n        }\\n\\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":29},{"id":1342672806,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669576,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1342672806/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.3 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                return 0;\\n            }\\n            rev = (rev * 10) + rem;\\n            x /= 10;\\n        }\\n\\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":28},{"id":1342672066,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669525,"status":10,"status_display":"Accepted","runtime":"2 ms","url":"/submissions/detail/1342672066/","is_pending":"Not Pending","title":"Reverse Integer","memory":"8.3 MB","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n\\n            \\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                return 0;\\n            }\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n\\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":27},{"id":1342670471,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669426,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342670471/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n\\n            rev = rev * 10 + rem;\\n            if ((rev > INT_MAX / 10) || (rev < INT_MIN / 10)) {\\n                return 0;\\n            }\\n            x /= 10;\\n        }\\n\\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011101001011111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":26},{"id":1342669760,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669381,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342669760/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            \\n            rev = rev * 10 + rem;\\n            if(rev>INT_MAX/10||rev<INT_MIN/10){\\n            return 0;\\n        }\\n            x /= 10;\\n        }\\n        \\n        return rev;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011101001011111111111111","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":25},{"id":1342669304,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669352,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1342669304/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        if(rev>INT_MAX/10||rev<INT_MIN/10){\\n            return 0;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":24},{"id":1342668348,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669292,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1342668348/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        if(rev>INT_MAX/10||rev<INT_MIN/10){\\n            return 0;\\n        }else{\\n            return rev;\\n        }\\n        \\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":23},{"id":1342667383,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722669232,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1342667383/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        if(rev>INT_MAX/10){\\n            return 0;\\n        }else{\\n            return rev;\\n        }\\n        \\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":22},{"id":1342659092,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722668730,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1342659092/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n\\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        cout<<rev;\\n        return 0;\\n    }\\n};","compare_result":"0001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":21},{"id":1340869447,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526626,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1340869447/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        double rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":20},{"id":1340865402,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526399,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1340865402/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        long rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111110101111111110000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":19},{"id":1340865131,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526384,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1340865131/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        long rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n        return 0;\\n    }\\n};","compare_result":"1111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111110101111111110000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":18},{"id":1340860891,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526141,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1340860891/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n        return 0;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":17},{"id":1340859430,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526055,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1340859430/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":16},{"id":1340858669,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722526013,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1340858669/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        int rev = 0;\\n        while (x != 0) {\\n            \\n            int rem = x % 10;\\n            rev = rev * 10 + rem;\\n            x /= 10;\\n        }\\n        return rev;\\n    }\\n};","compare_result":"1111111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":15},{"id":1340842291,"question_id":191,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722525099,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1340842291/","is_pending":"Not Pending","title":"Number of 1 Bits","memory":"7.9 MB","code":"class Solution {\\npublic:\\n    int hammingWeight(int n) {\\n        int num = 0;\\n        while (n != 0) {\\n            if ((n % 2) == 1) {\\n                num++;\\n            }\\n            n /= 2;\\n        }\\n        return num;\\n    }\\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-1-bits","has_notes":false,"flag_type":1,"frontend_id":14},{"id":1340821554,"question_id":1406,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722523948,"status":10,"status_display":"Accepted","runtime":"0 ms","url":"/submissions/detail/1340821554/","is_pending":"Not Pending","title":"Subtract the Product and Sum of Digits of an Integer","memory":"7.5 MB","code":"class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p=1,s=0;\\n        while(n!=0){\\n            int r=n%10;\\n            s+=r;\\n            p*=r;\\n            n/=10;\\n        }\\n        return p-s;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subtract-the-product-and-sum-of-digits-of-an-integer","has_notes":false,"flag_type":1,"frontend_id":13},{"id":1340819629,"question_id":1406,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722523840,"status":10,"status_display":"Accepted","runtime":"3 ms","url":"/submissions/detail/1340819629/","is_pending":"Not Pending","title":"Subtract the Product and Sum of Digits of an Integer","memory":"7.6 MB","code":"class Solution {\\npublic:\\n    int subtractProductAndSum(int n) {\\n        int p=1,s=0,r;\\n        while(n!=0){\\n            r=n%10;\\n            s+=r;\\n            p*=r;\\n            n/=10;\\n        }\\n        return p-s;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"subtract-the-product-and-sum-of-digits-of-an-integer","has_notes":false,"flag_type":1,"frontend_id":12},{"id":1336371736,"question_id":169,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722180773,"status":10,"status_display":"Accepted","runtime":"16 ms","url":"/submissions/detail/1336371736/","is_pending":"Not Pending","title":"Majority Element","memory":"27 MB","code":"class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        map <int,int> mpp;\\n        int maj=0;\\n        int num=nums.size()/2;\\n        for(auto a:nums){\\n            mpp[a]++;\\n        }\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second>num){\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"majority-element","has_notes":false,"flag_type":1,"frontend_id":11}],"has_next":true,"last_key":""}'
2026-01-10 09:28:50,913 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.51.19 because its status is 'Runtime Error'
2026-01-10 09:28:50,914 [INFO] __main__.py:245 - Writing reverse-integer/2024-08-03 12.50.15 - Accepted - runtime 2ms - memory 8.3MB.cpp
2026-01-10 09:28:50,914 [INFO] __main__.py:245 - Writing reverse-integer/2024-08-03 12.49.36 - Accepted - runtime 2ms - memory 8.3MB.cpp
2026-01-10 09:28:50,915 [INFO] __main__.py:245 - Writing reverse-integer/2024-08-03 12.48.45 - Accepted - runtime 2ms - memory 8.3MB.cpp
2026-01-10 09:28:50,915 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.47.06 because its status is 'Wrong Answer'
2026-01-10 09:28:50,915 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.46.21 because its status is 'Wrong Answer'
2026-01-10 09:28:50,915 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.45.52 because its status is 'Runtime Error'
2026-01-10 09:28:50,915 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.44.52 because its status is 'Runtime Error'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.43.52 because its status is 'Runtime Error'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-03 12.35.30 because its status is 'Wrong Answer'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 21.07.06 because its status is 'Runtime Error'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 21.03.19 because its status is 'Wrong Answer'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 21.03.04 because its status is 'Wrong Answer'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 20.59.01 because its status is 'Runtime Error'
2026-01-10 09:28:50,916 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 20.57.35 because its status is 'Runtime Error'
2026-01-10 09:28:50,917 [INFO] __main__.py:188 - Skipping reverse-integer 2024-08-01 20.56.53 because its status is 'Runtime Error'
2026-01-10 09:28:52,924 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:52,926 [INFO] __main__.py:245 - Writing number-of-1-bits/2024-08-01 20.41.39 - Accepted - runtime 0ms - memory 7.9MB.cpp
2026-01-10 09:28:53,738 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:53,741 [INFO] __main__.py:245 - Writing subtract-the-product-and-sum-of-digits-of-an-integer/2024-08-01 20.22.28 - Accepted - runtime 0ms - memory 7.5MB.cpp
2026-01-10 09:28:53,742 [INFO] __main__.py:245 - Writing subtract-the-product-and-sum-of-digits-of-an-integer/2024-08-01 20.20.40 - Accepted - runtime 3ms - memory 7.6MB.cpp
2026-01-10 09:28:55,518 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "POST /graphql HTTP/1.1" 200 None
2026-01-10 09:28:55,520 [INFO] __main__.py:245 - Writing majority-element/2024-07-28 21.02.53 - Accepted - runtime 16ms - memory 27MB.cpp
2026-01-10 09:29:00,525 [DEBUG] leetcode.py:150 - Exporting submissions from 540 to 560
2026-01-10 09:29:01,505 [DEBUG] connectionpool.py:544 - https://leetcode.com:443 "GET /api/submissions/?offset=540&limit=20 HTTP/1.1" 200 None
2026-01-10 09:29:01,507 [DEBUG] leetcode.py:152 - b'{"submissions_dump":[{"id":1336371579,"question_id":169,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722180761,"status":10,"status_display":"Accepted","runtime":"23 ms","url":"/submissions/detail/1336371579/","is_pending":"Not Pending","title":"Majority Element","memory":"28.2 MB","code":"class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        unordered_map <int,int> mpp;\\n        int maj=0;\\n        int num=nums.size()/2;\\n        for(auto a:nums){\\n            mpp[a]++;\\n        }\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second>num){\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"majority-element","has_notes":false,"flag_type":1,"frontend_id":10},{"id":1336371146,"question_id":169,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722180728,"status":10,"status_display":"Accepted","runtime":"15 ms","url":"/submissions/detail/1336371146/","is_pending":"Not Pending","title":"Majority Element","memory":"27 MB","code":"class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        map <int,int> mpp;\\n        int maj=0;\\n        int num=nums.size()/2;\\n        for(auto a:nums){\\n            mpp[a]++;\\n        }\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second>num){\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"majority-element","has_notes":false,"flag_type":1,"frontend_id":9},{"id":1336370654,"question_id":169,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722180694,"status":10,"status_display":"Accepted","runtime":"18 ms","url":"/submissions/detail/1336370654/","is_pending":"Not Pending","title":"Majority Element","memory":"27.1 MB","code":"class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        map <int,int> mpp;\\n        int maj=0;\\n        int num=nums.size();\\n        for(auto a:nums){\\n            mpp[a]++;\\n        }\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second>num/2){\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"majority-element","has_notes":false,"flag_type":1,"frontend_id":8},{"id":1336369756,"question_id":169,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 5\xc2\xa0months","timestamp":1722180633,"status":10,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/1336369756/","is_pending":"Not Pending","title":"Majority Element","memory":"26.9 MB","code":"class Solution {\\npublic:\\n    int majorityElement(vector<int>& nums) {\\n        map <int,int> mpp;\\n        int maj=0;\\n        int num=nums.size();\\n        for(int i=0;i<num;i++){\\n            mpp[nums[i]]++;\\n        }\\n        int ans=0;\\n        for(auto it : mpp){\\n            if(it.second>num/2){\\n                ans= it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111","title_slug":"majority-element","has_notes":false,"flag_type":1,"frontend_id":7},{"id":1249035372,"question_id":9,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714825305,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1249035372/","is_pending":"Not Pending","title":"Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int r,rem,num;\\n        num=x;\\n        \\n        while(x!=0){\\n            rem=x%10;\\n            r=r*10+rem;\\n            x/=10;\\n        }\\n        \\nif(r==num){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};","compare_result":"101010111111111111111111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":6},{"id":1249035238,"question_id":9,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714825291,"status":20,"status_display":"Compile Error","runtime":"N/A","url":"/submissions/detail/1249035238/","is_pending":"Not Pending","title":"Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int r,rem,num;\\n        num=x;\\n        \\n        while(x!=0){\\n            rem=x%10;\\n            r=r*10+rem;\\n            x/=10;\\n        }\\n        \\n        else if(r==num){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};","compare_result":null,"title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":5},{"id":1249034998,"question_id":9,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714825265,"status":15,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/1249034998/","is_pending":"Not Pending","title":"Palindrome Number","memory":"N/A","code":"class Solution {\\npublic:\\n    bool isPalindrome(int x) {\\n        int r,rem,num;\\n        num=x;\\n        \\n        while(x!=0){\\n            rem=x%10;\\n            r=r*10+rem;\\n            x/=10;\\n        }\\n        if(num<0){\\n            return 0;\\n        }\\n        \\n        else if(r==num){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};","compare_result":"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"palindrome-number","has_notes":false,"flag_type":1,"frontend_id":4},{"id":1249030004,"question_id":7,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714824772,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1249030004/","is_pending":"Not Pending","title":"Reverse Integer","memory":"N/A","code":"class Solution {\\npublic:\\n    int reverse(int x) {\\n        long rem;\\n        int r;\\n        while(x!=0){\\n            r=x%10;\\n            rem=r+(rem*10);\\n            x=x/10;\\n        }\\n        return (int)rem;\\n    }\\n};","compare_result":"1111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111110101111111110000","title_slug":"reverse-integer","has_notes":false,"flag_type":1,"frontend_id":3},{"id":1249020340,"question_id":1,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714823808,"status":10,"status_display":"Accepted","runtime":"53 ms","url":"/submissions/detail/1249020340/","is_pending":"Not Pending","title":"Two Sum","memory":"12.6 MB","code":"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int flag,c;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=i+1;j<size(nums);j++){\\n                c=nums[i]+nums[j];\\n                if(c==target){\\n                    return{i,j};\\n                    \\n                    }\\n            }\\n        }\\n        return{};\\n    }\\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"two-sum","has_notes":false,"flag_type":1,"frontend_id":2},{"id":1249019144,"question_id":1,"lang":"cpp","lang_name":"C++","time":"1\xc2\xa0year, 8\xc2\xa0months","timestamp":1714823689,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1249019144/","is_pending":"Not Pending","title":"Two Sum","memory":"N/A","code":"class Solution {\\npublic:\\n    vector<int> twoSum(vector<int>& nums, int target) {\\n        int flag,c;\\n        for(int i=0;i<size(nums);i++){\\n            for(int j=1;j<size(nums);j++){\\n                c=nums[i]+nums[j];\\n                if(c==target){\\n                    return{i,j};\\n                    \\n                    }\\n            }\\n        }\\n        return{};\\n    }\\n};","compare_result":"111101111111111010101111111111111111111111111111111111111110111","title_slug":"two-sum","has_notes":false,"flag_type":1,"frontend_id":1}],"has_next":false,"last_key":""}'
2026-01-10 09:29:01,508 [INFO] __main__.py:245 - Writing majority-element/2024-07-28 21.02.41 - Accepted - runtime 23ms - memory 28.2MB.cpp
2026-01-10 09:29:01,509 [INFO] __main__.py:245 - Writing majority-element/2024-07-28 21.02.08 - Accepted - runtime 15ms - memory 27MB.cpp
2026-01-10 09:29:01,510 [INFO] __main__.py:245 - Writing majority-element/2024-07-28 21.01.34 - Accepted - runtime 18ms - memory 27.1MB.cpp
2026-01-10 09:29:01,511 [INFO] __main__.py:245 - Writing majority-element/2024-07-28 21.00.33 - Accepted - runtime 19ms - memory 26.9MB.cpp
2026-01-10 09:29:01,511 [INFO] __main__.py:188 - Skipping palindrome-number 2024-05-04 17.51.45 because its status is 'Wrong Answer'
2026-01-10 09:29:01,512 [INFO] __main__.py:188 - Skipping palindrome-number 2024-05-04 17.51.31 because its status is 'Compile Error'
2026-01-10 09:29:01,512 [INFO] __main__.py:188 - Skipping palindrome-number 2024-05-04 17.51.05 because its status is 'Runtime Error'
2026-01-10 09:29:01,512 [INFO] __main__.py:188 - Skipping reverse-integer 2024-05-04 17.42.52 because its status is 'Wrong Answer'
2026-01-10 09:29:01,513 [INFO] __main__.py:245 - Writing two-sum/2024-05-04 17.26.48 - Accepted - runtime 53ms - memory 12.6MB.cpp
2026-01-10 09:29:01,513 [INFO] __main__.py:188 - Skipping two-sum 2024-05-04 17.24.49 because its status is 'Wrong Answer'
